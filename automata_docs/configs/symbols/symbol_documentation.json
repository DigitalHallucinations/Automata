{"Symbol(scip-python python automata_docs 99b66dcb026f3dfe43908622482c17a9874b380c `core.symbol.symbol_types`/Symbol#, scip-python, Package(python automata_docs 99b66dcb026f3dfe43908622482c17a9874b380c), (Descriptor(core.symbol.symbol_types, 1), Descriptor(Symbol, 2)))": {"py/tuple": ["@dataclass\nclass Symbol:\n    \"\"\"\n    Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n\n    Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n\n    # (<x>)+ stands for one or more repetitions of <x>\n    <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n    <package>              ::= <manager> ' ' <package-name> ' ' <version>\n    <scheme>               ::= any UTF-8, escape spaces with double space.\n    <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n    <package-name>         ::= same as above\n    <version>              ::= same as above\n    <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n    <namespace>            ::= <name> '/'\n    <type>                 ::= <name> '#'\n    <term>                 ::= <name> '.'\n    <meta>                 ::= <name> ':'\n    <macro>                ::= <name> '!'\n    <method>               ::= <name> '(' <method-disambiguator> ').'\n    <type-parameter>       ::= '[' <name> ']'\n    <parameter>            ::= '(' <name> ')'\n    <name>                 ::= <identifier>\n    <method-disambiguator> ::= <simple-identifier>\n    <identifier>           ::= <simple-identifier> | <escaped-identifier>\n    <simple-identifier>    ::= (<identifier-character>)+\n    <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n    <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n    <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n\n    Examples -\n    from automata_docs.core.search.symbol_parser import parse_symbol\n\n    symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata_docs.core.agent.automata_agent_enums`/ActionIndicator#\"\n    )\n\n    symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata_docs.core.base.tool`/ToolNotFoundError#__init__().\"\n    )\n    \"\"\"\n\n    uri: str\n    scheme: str\n    package: Package\n    descriptors: Tuple[Descriptor, ...]\n\n    def __repr__(self):\n        return f\"Symbol({self.uri}, {self.scheme}, {self.package}, {self.descriptors})\"\n\n    def __hash__(self) -> int:\n        return hash(self.uri)\n\n    def __eq__(self, other):\n        if isinstance(other, Symbol):\n            return self.uri == other.uri\n        elif isinstance(other, str):\n            return self.uri == other\n        return False\n\n    def symbol_kind_by_suffix(self) -> Descriptor.PythonKinds:\n        return Descriptor.convert_scip_to_python_suffix(self.symbol_raw_kind_by_suffix())\n\n    def symbol_raw_kind_by_suffix(self) -> DescriptorProto:\n        if self.uri.startswith(\"local\"):\n            return Descriptor.ScipSuffix.Local\n        if self.uri.endswith(\"/\"):\n            return Descriptor.ScipSuffix.Namespace\n        elif self.uri.endswith(\"#\"):\n            return Descriptor.ScipSuffix.Type\n        elif self.uri.endswith(\").\"):\n            return Descriptor.ScipSuffix.Method\n        elif self.uri.endswith(\".\"):\n            return Descriptor.ScipSuffix.Term\n        elif self.uri.endswith(\":\"):\n            return Descriptor.ScipSuffix.Meta\n        elif self.uri.endswith(\")\"):\n            return Descriptor.ScipSuffix.Parameter\n        elif self.uri.endswith(\"]\"):\n            return Descriptor.ScipSuffix.TypeParameter\n        else:\n            raise ValueError(f\"Invalid descriptor suffix: {self.uri}\")\n\n    def parent(self) -> \"Symbol\":\n        parent_descriptors = list(self.descriptors)[:-1]\n        return Symbol(self.uri, self.scheme, self.package, tuple(parent_descriptors))\n\n    @property\n    def path(self) -> StrPath:\n        return \".\".join([ele.name for ele in self.descriptors])\n\n    @property\n    def module_name(self) -> str:\n        return self.descriptors[0].name\n\n    @staticmethod\n    def is_local(symbol: \"Symbol\") -> bool:\n        return symbol.descriptors[0].suffix == Descriptor.ScipSuffix.Local\n\n    @staticmethod\n    def is_meta(symbol: \"Symbol\") -> bool:\n        return symbol.descriptors[0].suffix == Descriptor.ScipSuffix.Meta\n\n    @staticmethod\n    def is_parameter(symbol: \"Symbol\") -> bool:\n        return symbol.descriptors[0].suffix == Descriptor.ScipSuffix.Parameter\n\n    @staticmethod\n    def is_protobuf(symbol: \"Symbol\") -> bool:\n        return symbol.module_name.endswith(\"pb2\")\n\n    @classmethod\n    def from_string(cls, symbol_str: str) -> \"Symbol\":\n        \"\"\"\n        Creates a Symbol instance from a string representation\n\n        :param symbol_str: The string representation of the Symbol\n        :return: A Symbol instance\n        \"\"\"\n        # Assuming symbol_str is in the format: \"Symbol({uri}, {scheme}, Package({manager} {name} {version}), [{Descriptor},...])\"\n        # Parse the symbol_str to extract the uri, scheme, package_str, and descriptors_str\n        match = re.search(r\"Symbol\\((.*?), (.*?), Package\\((.*?)\\), \\((.*?)\\)\\)\", symbol_str)\n        if not match:\n            raise ValueError(f\"Invalid symbol_str: {symbol_str}\")\n        uri, _, __, ___ = match.groups()\n        # In current implementation, only the uri is used in re-construcing the symbol\n        from automata_docs.core.symbol.symbol_parser import parse_symbol\n\n        return parse_symbol(uri)\n\n\n", "Context for -\ncore.symbol.symbol_types.Symbol -\n\n  Class Docstring:\n    Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n    \n    Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n    \n    # (<x>)+ stands for one or more repetitions of <x>\n    <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n    <package>              ::= <manager> ' ' <package-name> ' ' <version>\n    <scheme>               ::= any UTF-8, escape spaces with double space.\n    <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n    <package-name>         ::= same as above\n    <version>              ::= same as above\n    <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n    <namespace>            ::= <name> '/'\n    <type>                 ::= <name> '#'\n    <term>                 ::= <name> '.'\n    <meta>                 ::= <name> ':'\n    <macro>                ::= <name> '!'\n    <method>               ::= <name> '(' <method-disambiguator> ').'\n    <type-parameter>       ::= '[' <name> ']'\n    <parameter>            ::= '(' <name> ')'\n    <name>                 ::= <identifier>\n    <method-disambiguator> ::= <simple-identifier>\n    <identifier>           ::= <simple-identifier> | <escaped-identifier>\n    <simple-identifier>    ::= (<identifier-character>)+\n    <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n    <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n    <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n    \n    Examples -\n    from automata_docs.core.search.symbol_parser import parse_symbol\n    \n    symbol_class = parse_symbol(\n    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata_docs.core.agent.automata_agent_enums`/ActionIndicator#\"\n    )\n    \n    symbol_method = parse_symbol(\n    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata_docs.core.base.tool`/ToolNotFoundError#__init__().\"\n    )\n    \n  Variables:\n    \n  Methods:\n    def __eq__(self, other):\n            if isinstance(other, Symbol):\n                return self.uri == other.uri\n            elif isinstance(other, str):\n                return self.uri == other\n            return False\n    \n        \n    def __hash__(self) -> int:\n            return hash(self.uri)\n    \n        \n    def __repr__(self):\n            return f\"Symbol({self.uri}, {self.scheme}, {self.package}, {self.descriptors})\"\n    \n        \n    @classmethod\n        def from_string(cls, symbol_str: str) -> \"Symbol\":\n            \"\"\"\n            Creates a Symbol instance from a string representation\n    \n            :param symbol_str: The string representation of the Symbol\n            :return: A Symbol instance\n            \"\"\"\n            # Assuming symbol_str is in the format: \"Symbol({uri}, {scheme}, Package({manager} {name} {version}), [{Descriptor},...])\"\n            # Parse the symbol_str to extract the uri, scheme, package_str, and descriptors_str\n            match = re.search(r\"Symbol\\((.*?), (.*?), Package\\((.*?)\\), \\((.*?)\\)\\)\", symbol_str)\n            if not match:\n                raise ValueError(f\"Invalid symbol_str: {symbol_str}\")\n            uri, _, __, ___ = match.groups()\n            # In current implementation, only the uri is used in re-construcing the symbol\n            from automata_docs.core.symbol.symbol_parser import parse_symbol\n    \n            return parse_symbol(uri)\n    \n    \n    \n    @staticmethod\n        def is_local(symbol: \"Symbol\") -> bool:\n            return symbol.descriptors[0].suffix == Descriptor.ScipSuffix.Local\n    \n        \n    @staticmethod\n        def is_meta(symbol: \"Symbol\") -> bool:\n            return symbol.descriptors[0].suffix == Descriptor.ScipSuffix.Meta\n    \n        \n    @staticmethod\n        def is_parameter(symbol: \"Symbol\") -> bool:\n            return symbol.descriptors[0].suffix == Descriptor.ScipSuffix.Parameter\n    \n        \n    @staticmethod\n        def is_protobuf(symbol: \"Symbol\") -> bool:\n            return symbol.module_name.endswith(\"pb2\")\n    \n        \n    @property\n        def module_name(self) -> str:\n            return self.descriptors[0].name\n    \n        \n    def parent(self) -> \"Symbol\":\n            parent_descriptors = list(self.descriptors)[:-1]\n            return Symbol(self.uri, self.scheme, self.package, tuple(parent_descriptors))\n    \n        \n    @property\n        def path(self) -> StrPath:\n            return \".\".join([ele.name for ele in self.descriptors])\n    \n        \n    def symbol_kind_by_suffix(self) -> Descriptor.PythonKinds:\n            return Descriptor.convert_scip_to_python_suffix(self.symbol_raw_kind_by_suffix())\n    \n        \n    def symbol_raw_kind_by_suffix(self) -> DescriptorProto:\n            if self.uri.startswith(\"local\"):\n                return Descriptor.ScipSuffix.Local\n            if self.uri.endswith(\"/\"):\n                return Descriptor.ScipSuffix.Namespace\n            elif self.uri.endswith(\"#\"):\n                return Descriptor.ScipSuffix.Type\n            elif self.uri.endswith(\").\"):\n                return Descriptor.ScipSuffix.Method\n            elif self.uri.endswith(\".\"):\n                return Descriptor.ScipSuffix.Term\n            elif self.uri.endswith(\":\"):\n                return Descriptor.ScipSuffix.Meta\n            elif self.uri.endswith(\")\"):\n                return Descriptor.ScipSuffix.Parameter\n            elif self.uri.endswith(\"]\"):\n                return Descriptor.ScipSuffix.TypeParameter\n            else:\n                raise ValueError(f\"Invalid descriptor suffix: {self.uri}\")\n    \n        \n  Closely Related Symbols:\n    Context for -\n    core.symbol.symbol_types.SymbolReference -\n    \n        \n      Methods:\n    Context for -\n    core.context.python_context.python_context_retriever.PythonContextRetriever -\n    \n      Variables:\n        self.graph=graph\n        self.config=config\n        self.indent_level=0\n        self.indent_level=1\n        self.indent_level=1\n        self.message=\"\\n\".join([f\"{indent()}{ele}\" for ele in message.split(\"\\n\")]) + \"\\n\"\n        self.message=\"\"\n        self.obs_symbols=set([])\n        self.global_level=0\n        \n      Methods:\n        def __init__(\n                self,\n                graph: SymbolGraph,\n                config: PythonContextRetrieverConfig = PythonContextRetrieverConfig(),\n            ):\n                self.graph = graph\n                self.config = config\n                self.indent_level = 0\n                self.reset()\n        \n            \n      core.symbol.tests.test_symbol_parser.test_parse_symbol\n      \n        def test_parse_symbol(symbols):\n            for symbol in symbols:\n                assert symbol.scheme == \"scip-python\"\n                assert symbol.package.manager == \"python\"\n                assert symbol.package.name == \"automata\"\n                assert symbol.package.version == \"75482692a6fe30c72db516201a6f47d9fb4af065\"\n                assert len(symbol.descriptors) > 0\n        \n        \n        \n    Context for -\n    core.search.symbol_graph.SymbolGraph -\n    \n      Variables:\n        self._graph=builder.build_graph()\n        self.navigator=_SymbolGraphNavigator(self._graph)\n        \n      Methods:\n        def __init__(self, index_path: str, build_caller_relationships: bool = False):\n                \"\"\"\n                Initializes SymbolGraph with the path of an index protobuf file.\n        \n                Args:\n                    index_path (str): Path to index protobuf file\n                Returns:\n                    SymbolGraph instance\n                \"\"\"\n                index = self._load_index_protobuf(index_path)\n                builder = GraphBuilder(index, build_caller_relationships)\n                self._graph = builder.build_graph()\n                self.navigator = _SymbolGraphNavigator(self._graph)\n        \n            \n      core.symbol.tests.test_symbol_parser.test_is_local_symbol\n      \n        def test_is_local_symbol(symbols):\n            for symbol in symbols:\n                assert is_local_symbol(\"local \" + symbol.uri)\n        \n        \n        \n    Context for -\n    core.symbol.symbol_parser.SymbolParser -\n    \n      Class Docstring:\n        Translation of the logic defined in\n        https://github.com/sourcegraph/scip/blob/ee677ba3756cdcdb55b39942b5701f0fde9d69fa/bindings/go/scip/symbol.go\n        to parse URIs into structured objects.\n        It's not great that this implementation is not in hard sync with the Go one, but it's good enough for now.\n        \n      Variables:\n        self.symbol=symbol\n        self.index=0\n        self.symbol_str=symbol\n        self.index=1\n        self.index=1\n        self.index=1\n        self.index=1\n        self.index=1\n        self.index=1\n        self.index=1\n        self.index=1\n        \n      Methods:\n        def __init__(self, symbol: str):\n                self.symbol = symbol\n                self.index = 0\n                self.symbol_str = symbol\n        \n            \n      core.embedding.tests.conftest.get_sem\n      \n        def get_sem(monkeypatch, mock_symbols, build_new_embedding_map=False):\n            monkeypatch.setattr(\n                \"automata_docs.core.search.symbol_utils.convert_to_fst_object\",\n                lambda args: \"symbol_source\",\n            )\n            return SymbolEmbeddingMap(\n                # Symbols with kind 'Method' are processed, 'Local' are skipped\n                all_defined_symbols=mock_symbols,\n                build_new_embedding_map=build_new_embedding_map,\n            )\n        \n        \n        \n      core.search.tests.test_symbol_graph.test_get_all_symbols\n      \n        def test_get_all_symbols(symbol_graph):\n            graph_symbols = symbol_graph.get_all_defined_symbols()\n            assert isinstance(graph_symbols, list)\n            assert all(isinstance(s, Symbol) for s in graph_symbols)\n        \n    Context for -\n    core.embedding.symbol_embedding_map.SymbolEmbeddingMap -\n    \n      Variables:\n        self.embedding_provider=embedding_provider or EmbeddingsProvider()\n        self.embedding_dict=self._build_embedding_map(all_defined_symbols)\n        self.embedding_dict=SymbolEmbeddingMap.load(kwargs[\"embedding_path\"])\n        self.embedding_dict=kwargs[\"embedding_dict\"]\n        self.embedding_dict[symbol]=SymbolEmbedding(\n                                symbol=symbol,\n                                vector=symbol_embedding,\n                                source_code=symbol_source,\n                            )\n        self.embedding_dict[symbol]=SymbolEmbedding(\n                                    symbol=symbol,\n                                    vector=symbol_embedding,\n                                    source_code=symbol_source,\n                                )\n        self.embedding_dict[symbol]=symbol_embedding\n        self.embedding_dict={\n                    symbol: embedding\n                    for symbol, embedding in self.embedding_dict.items()\n                    if symbol in selected_symbols\n                }\n        \n      Methods:\n        def __init__(\n                self,\n                *args,\n                embedding_provider=None,\n                build_new_embedding_map=False,\n                load_embedding_map=False,\n                **kwargs,\n            ):\n                \"\"\"\n                Initialize SymbolEmbeddingMap\n                Args:\n                    *args: Variable length argument list\n                    embedding_provider (EmbeddingsProvider): EmbeddingsProvider object\n                    build_new_embedding_map (bool): Whether to build a new embedding map\n                    load_embedding_map (bool): Whether to load an existing embedding map\n                    **kwargs: Arbitrary keyword arguments\n                Result:\n                    An instance of SymbolEmbeddingMap\n                \"\"\"\n                self.embedding_provider = embedding_provider or EmbeddingsProvider()\n        \n                if build_new_embedding_map and load_embedding_map:\n                    raise ValueError(\"Cannot specify both build_new_embedding_map and load_embedding_map\")\n        \n                if build_new_embedding_map:\n                    try:\n                        all_defined_symbols = kwargs[\"all_defined_symbols\"]\n                        self.embedding_dict = self._build_embedding_map(all_defined_symbols)\n                    except KeyError as e:\n                        raise ValueError(f\"Missing required argument: {e}\")\n        \n                elif load_embedding_map:\n                    try:\n                        # If given an embedding path, load the embedding map from that path\n                        # This results in calling cls constructor again with the loaded embedding map\n                        if \"embedding_path\" in kwargs:\n                            self.embedding_dict = SymbolEmbeddingMap.load(kwargs[\"embedding_path\"])\n                        # Otherwise, load the embedding map from the kwargs\n                        elif \"embedding_dict\" in kwargs:\n                            self.embedding_dict = kwargs[\"embedding_dict\"]\n                    except KeyError as e:\n                        raise ValueError(f\"Missing required argument: {e}\")\n        \n            \n    Context for -\n    core.symbol.symbol_types.SymbolFile -\n    \n        \n      Methods:\n", "# Symbol\n\n`Symbol` is a class designed to identify and work with elements like classes, methods, or local variables in a standardized way. It uses a string representation to uniquely identify symbols, including a scheme, package, and one or more descriptors. This representation enables easy interaction with the metadata related to symbols, such as their docstrings.\n\n## Overview\n\nA `Symbol` can be instantiated from a string representation using the `from_string` class method, and provides handy ways to compare instances, extract useful information, and work with parent symbols. The class also includes a set of static methods for checking specific attributes of a symbol, like whether it is local, meta, a parameter, or protobuf.\n\n## Related Symbols\n\n- `core.symbol.symbol_types.SymbolReference`\n- `core.context.python_context.python_context_retriever.PythonContextRetriever`\n- `core.search.symbol_graph.SymbolGraph`\n- `core.symbol.symbol_parser.SymbolParser`\n- `core.embedding.symbol_embedding_map.SymbolEmbeddingMap`\n- `core.symbol.symbol_types.SymbolFile`\n\n## Example\n\nHere is an example demonstrating how to create a `Symbol` instance and some of its functionalities:\n\n```python\nfrom automata_docs.core.symbol.symbol_parser import parse_symbol\n\nsymbol_class = parse_symbol(\n    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata_docs.core.agent.automata_agent_enums`/ActionIndicator#\"\n)\n\nsymbol_method = parse_symbol(\n    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata_docs.core.base.tool`/ToolNotFoundError#__init__().\"\n)\n\n# Checking equality between symbols\nassert symbol_class != symbol_method\nassert symbol_class == \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata_docs.core.agent.automata_agent_enums`/ActionIndicator#\"\n\n# Getting the parent of a symbol\nparent_symbol = symbol_method.parent()\nassert parent_symbol == \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata_docs.core.base.tool`/ToolNotFoundError#\"\n```\n\n## Limitations\n\nThe current implementation of the `Symbol` class relies on the specific representation format as defined by the context. If the format changes or is extended, the current parsing logic might need to be updated to handle these modifications.\n\n## Follow-up Questions:\n\n- How can the `Symbol` class be extended to support custom representation formats or additional functionality?\n- Are there any potential performance issues when working with large numbers of `Symbol` instances?", "The `Symbol` class is designed for identifying and working with elements like classes, methods, or local variables in a standardized way. It uses a string representation to uniquely identify symbols and allows for easy interaction with their metadata. The class can be instantiated from a string representation using the `from_string` class method and provides functionality for comparing instances, extracting information, and working with parent symbols. There are also static methods for checking specific attributes of a symbol. Note that the current implementation relies on the context's specific representation format, so it may need updates if the format changes or is extended.\n\nExample:\n```python\nfrom automata_docs.core.symbol.symbol_parser import parse_symbol\n\nsymbol_class = parse_symbol(\n    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata_docs.core.agent.automata_agent_enums`/ActionIndicator#\"\n)\n\nsymbol_method = parse_symbol(\n    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata_docs.core.base.tool`/ToolNotFoundError#__init__().\"\n)\n\n# Checking equality between symbols\nassert symbol_class != symbol_method\nassert symbol_class == \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata_docs.core.agent.automata_agent_enums`/ActionIndicator#\"\n\n# Getting the parent of a symbol\nparent_symbol = symbol_method.parent()\nassert parent_symbol == \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata_docs.core.base.tool`/ToolNotFoundError#\"\n```"]}, "Symbol(scip-python python automata_docs 99b66dcb026f3dfe43908622482c17a9874b380c `core.search.symbol_graph`/SymbolGraph#, scip-python, Package(python automata_docs 99b66dcb026f3dfe43908622482c17a9874b380c), (Descriptor(core.search.symbol_graph, 1), Descriptor(SymbolGraph, 2)))": {"py/tuple": ["class SymbolGraph:\n    def __init__(self, index_path: str, build_caller_relationships: bool = False):\n        \"\"\"\n        Initializes SymbolGraph with the path of an index protobuf file.\n\n        Args:\n            index_path (str): Path to index protobuf file\n        Returns:\n            SymbolGraph instance\n        \"\"\"\n        index = self._load_index_protobuf(index_path)\n        builder = GraphBuilder(index, build_caller_relationships)\n        self._graph = builder.build_graph()\n        self.navigator = _SymbolGraphNavigator(self._graph)\n\n    def get_all_files(self) -> List[SymbolFile]:\n        \"\"\"\n        Gets all file nodes in the graph.\n\n        Args:\n            None\n        Returns:\n            List of all defined symbols.\n        \"\"\"\n        return self.navigator.get_all_files()\n\n    def get_all_defined_symbols(self) -> List[Symbol]:\n        \"\"\"\n        Gets all symbols defined in the graph.\n\n        Args:\n            None\n        Returns:\n            List[Symbol]: List of all defined symbols.\n        \"\"\"\n        return list(set(self.navigator.get_all_defined_symbols()))\n\n    def get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]:\n        \"\"\"\n        Gets all symbols which contain a specified partial path\n\n        Args:\n            partial_py_path (PyPath): The partial path to explain\n        Returns:\n            Set[Symbol]: Set of symbols that follow the partial path\n        \"\"\"\n        return self.navigator.get_symbol_dependencies(symbol)\n\n    def get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]:\n        \"\"\"\n        Gets the set of symbols with relationships to the given symbol.\n\n        Args:\n            symbol (Symbol): The symbol to get relationships for.\n        Returns:\n            Set[Symbol]: The list of relationships for the symbol.\n\n        # TODO: Consider implications of using list instead of set\n        \"\"\"\n        return self.navigator.get_symbol_relationships(symbol)\n\n    def get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]:\n        \"\"\"\n        Gets the (potential) callers of the given symbol.\n        Requires downstream filtering to remove non-call statements.\n\n        Args:\n            symbol (Symbol): The symbol to get callers for.\n        Returns:\n            Dict[Symbol]: The map of callers to callees for the symbol.\n        \"\"\"\n\n        return self.navigator.get_potential_symbol_callers(symbol)\n\n    def get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]:\n        \"\"\"\n        Gets the callers of the given symbol.\n        Requires downstream filtering to remove non-call statements.\n\n        Args:\n            symbol (Symbol): The symbol to get callees for.\n        Returns:\n            Dict[Symbol]: The map of callees to callers for the symbol.\n        \"\"\"\n        return self.navigator.get_potential_symbol_callees(symbol)\n\n    def get_references_to_symbol(self, symbol: Symbol) -> Dict[StrPath, List[SymbolReference]]:\n        \"\"\"\n        Gets all references to a given module in the symbol graph.\n\n        Args:\n            module (Symbol): The module to locate references for\n        Returns:\n            List[SymbolReference]: List of symbol references\n        \"\"\"\n        return self.navigator.get_references_to_symbol(symbol)\n\n    def get_rankable_symbol_subgraph(\n        self, flow_rank=\"to_dependents\", path_filter: Optional[str] = None\n    ) -> nx.DiGraph:\n        \"\"\"\n        Gets a detailed subgraph of rankable symbols.\n\n        Args:\n            symbol (str): The symbol in the form 'module`/ClassOrMethod#'\n\n        Returns:\n            List[str]: The list of dependencies for the symbol.\n        TODO: Can thi sbe made more efficient?\n        TODO: Can we better handle edge cases that are not handled in obvious ways\n        \"\"\"\n        G = nx.DiGraph()\n\n        # Filter the symbols based on the provided path filter\n\n        filtered_symbols = get_rankable_symbols(self.get_all_defined_symbols())\n\n        if path_filter is not None:\n            filtered_symbols = [\n                sym for sym in filtered_symbols if sym.path.startswith(path_filter)  # type: ignore\n            ]\n\n        for symbol in tqdm(filtered_symbols):\n            try:\n                dependencies = self.get_symbol_dependencies(symbol)\n                relationships = self.get_symbol_relationships(symbol)\n                filtered_related_symbols = get_rankable_symbols(\n                    list(dependencies.union(relationships))\n                )\n                for dependency in filtered_related_symbols:\n                    if flow_rank == \"to_dependents\":\n                        G.add_edge(symbol, dependency)\n                    elif flow_rank == \"from_dependents\":\n                        G.add_edge(dependency, symbol)\n                    elif flow_rank == \"bidirectional\":\n                        G.add_edge(symbol, dependency)\n                        G.add_edge(dependency, symbol)\n                    else:\n                        raise ValueError(\n                            \"flow_rank must be one of 'to_dependents', 'from_dependents', or 'bidirectional'\"\n                        )\n\n            except Exception as e:\n                logger.error(f\"Error processing {symbol.uri}: {e}\")\n\n        return G\n\n    @staticmethod\n    def _load_index_protobuf(path: StrPath) -> Index:\n        index = Index()\n        with open(path, \"rb\") as f:\n            index.ParseFromString(f.read())\n        return index\n", "Context for -\ncore.search.symbol_graph.SymbolGraph -\n\n  Variables:\n    self._graph=builder.build_graph()\n    self.navigator=_SymbolGraphNavigator(self._graph)\n    \n  Methods:\n    def __init__(self, index_path: str, build_caller_relationships: bool = False):\n            \"\"\"\n            Initializes SymbolGraph with the path of an index protobuf file.\n    \n            Args:\n                index_path (str): Path to index protobuf file\n            Returns:\n                SymbolGraph instance\n            \"\"\"\n            index = self._load_index_protobuf(index_path)\n            builder = GraphBuilder(index, build_caller_relationships)\n            self._graph = builder.build_graph()\n            self.navigator = _SymbolGraphNavigator(self._graph)\n    \n        \n    def get_all_defined_symbols(self) -> List[Symbol]:\n            \"\"\"\n            Gets all symbols defined in the graph.\n    \n            Args:\n                None\n            Returns:\n                List[Symbol]: List of all defined symbols.\n            \"\"\"\n            return list(set(self.navigator.get_all_defined_symbols()))\n    \n        \n    def get_all_files(self) -> List[SymbolFile]:\n            \"\"\"\n            Gets all file nodes in the graph.\n    \n            Args:\n                None\n            Returns:\n                List of all defined symbols.\n            \"\"\"\n            return self.navigator.get_all_files()\n    \n        \n    def get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]:\n            \"\"\"\n            Gets the callers of the given symbol.\n            Requires downstream filtering to remove non-call statements.\n    \n            Args:\n                symbol (Symbol): The symbol to get callees for.\n            Returns:\n                Dict[Symbol]: The map of callees to callers for the symbol.\n            \"\"\"\n            return self.navigator.get_potential_symbol_callees(symbol)\n    \n        \n    def get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]:\n            \"\"\"\n            Gets the (potential) callers of the given symbol.\n            Requires downstream filtering to remove non-call statements.\n    \n            Args:\n                symbol (Symbol): The symbol to get callers for.\n            Returns:\n                Dict[Symbol]: The map of callers to callees for the symbol.\n            \"\"\"\n    \n            return self.navigator.get_potential_symbol_callers(symbol)\n    \n        \n    def get_rankable_symbol_subgraph(\n            self, flow_rank=\"to_dependents\", path_filter: Optional[str] = None\n        ) -> nx.DiGraph:\n            \"\"\"\n            Gets a detailed subgraph of rankable symbols.\n    \n            Args:\n                symbol (str): The symbol in the form 'module`/ClassOrMethod#'\n    \n            Returns:\n                List[str]: The list of dependencies for the symbol.\n            TODO: Can thi sbe made more efficient?\n            TODO: Can we better handle edge cases that are not handled in obvious ways\n            \"\"\"\n            G = nx.DiGraph()\n    \n            # Filter the symbols based on the provided path filter\n    \n            filtered_symbols = get_rankable_symbols(self.get_all_defined_symbols())\n    \n            if path_filter is not None:\n                filtered_symbols = [\n                    sym for sym in filtered_symbols if sym.path.startswith(path_filter)  # type: ignore\n                ]\n    \n            for symbol in tqdm(filtered_symbols):\n                try:\n                    dependencies = self.get_symbol_dependencies(symbol)\n                    relationships = self.get_symbol_relationships(symbol)\n                    filtered_related_symbols = get_rankable_symbols(\n                        list(dependencies.union(relationships))\n                    )\n                    for dependency in filtered_related_symbols:\n                        if flow_rank == \"to_dependents\":\n                            G.add_edge(symbol, dependency)\n                        elif flow_rank == \"from_dependents\":\n                            G.add_edge(dependency, symbol)\n                        elif flow_rank == \"bidirectional\":\n                            G.add_edge(symbol, dependency)\n                            G.add_edge(dependency, symbol)\n                        else:\n                            raise ValueError(\n                                \"flow_rank must be one of 'to_dependents', 'from_dependents', or 'bidirectional'\"\n                            )\n    \n                except Exception as e:\n                    logger.error(f\"Error processing {symbol.uri}: {e}\")\n    \n            return G\n    \n        \n    def get_references_to_symbol(self, symbol: Symbol) -> Dict[StrPath, List[SymbolReference]]:\n            \"\"\"\n            Gets all references to a given module in the symbol graph.\n    \n            Args:\n                module (Symbol): The module to locate references for\n            Returns:\n                List[SymbolReference]: List of symbol references\n            \"\"\"\n            return self.navigator.get_references_to_symbol(symbol)\n    \n        \n    def get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]:\n            \"\"\"\n            Gets all symbols which contain a specified partial path\n    \n            Args:\n                partial_py_path (PyPath): The partial path to explain\n            Returns:\n                Set[Symbol]: Set of symbols that follow the partial path\n            \"\"\"\n            return self.navigator.get_symbol_dependencies(symbol)\n    \n        \n    def get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]:\n            \"\"\"\n            Gets the set of symbols with relationships to the given symbol.\n    \n            Args:\n                symbol (Symbol): The symbol to get relationships for.\n            Returns:\n                Set[Symbol]: The list of relationships for the symbol.\n    \n            # TODO: Consider implications of using list instead of set\n            \"\"\"\n            return self.navigator.get_symbol_relationships(symbol)\n    \n        \n  Closely Related Symbols:\n    Context for -\n    core.symbol.symbol_types.Symbol -\n    \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata_docs.core.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata_docs.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata_docs.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Variables:\n        \n      Methods:\n    Context for -\n    core.search.symbol_graph.GraphBuilder -\n    \n      Class Docstring:\n        Builds a symbol graph from an Index.\n        \n      Variables:\n        self.index=index\n        self.build_caller_relationships=build_caller_relationships\n        self._graph=nx.MultiDiGraph()\n        \n      Methods:\n        def __init__(self, index: Index, build_caller_relationships: bool = False):\n                self.index = index\n                self.build_caller_relationships = build_caller_relationships\n                self._graph = nx.MultiDiGraph()\n        \n            \n    Context for -\n    core.context.python_context.python_context_retriever.PythonContextRetriever -\n    \n      Variables:\n        self.graph=graph\n        self.config=config\n        self.indent_level=0\n        self.indent_level=1\n        self.indent_level=1\n        self.message=\"\\n\".join([f\"{indent()}{ele}\" for ele in message.split(\"\\n\")]) + \"\\n\"\n        self.message=\"\"\n        self.obs_symbols=set([])\n        self.global_level=0\n        \n      Methods:\n        def __init__(\n                self,\n                graph: SymbolGraph,\n                config: PythonContextRetrieverConfig = PythonContextRetrieverConfig(),\n            ):\n                self.graph = graph\n                self.config = config\n                self.indent_level = 0\n                self.reset()\n        \n            \n      core.search.tests.test_symbol_graph.test_get_all_symbols\n      \n        def test_get_all_symbols(symbol_graph):\n            graph_symbols = symbol_graph.get_all_defined_symbols()\n            assert isinstance(graph_symbols, list)\n            assert all(isinstance(s, Symbol) for s in graph_symbols)\n        \n      core.search.tests.conftest.symbol_graph_mock\n      \n        @pytest.fixture\n        def symbol_graph_mock(mocker):\n            mock = mocker.MagicMock(spec=SymbolGraph)\n            return mock\n        \n      core.search.symbol_rank.tests.test_symbol_rank.test_get_ranks_small_graph\n      \n        def test_get_ranks_small_graph():\n            G = DiGraph()\n            G.add_edge(1, 2)\n            G.add_edge(2, 3)\n            G.add_edge(3, 1)\n            config = SymbolRankConfig()\n            pagerank = SymbolRank(G, config)\n        \n            ranks = pagerank.get_ranks()\n            assert len(ranks) == 3\n            assert sum([ele[1] for ele in ranks]) == pytest.approx(1.0)\n        \n      core.search.tests.conftest.symbol_graph\n      \n        @pytest.fixture\n        def symbol_graph():\n            # assuming the path to a valid index protobuf file, you should replace it with your own file path\n            file_dir = os.path.dirname(os.path.abspath(__file__))\n            index_path = os.path.join(file_dir, \"index.scip\")\n            graph = SymbolGraph(index_path)\n            return graph\n        \n        \n        \n    Context for -\n    core.search.symbol_graph._RelationshipManager -\n    \n      Class Docstring:\n        Manages the relationships between symbols in a graph.\n        \n      Variables:\n        self._graph=graph\n        self.symbol_information=symbol_information\n        \n      Methods:\n        def __init__(self, graph: nx.MultiDiGraph, symbol_information: Any):\n                self._graph = graph\n                self.symbol_information = symbol_information\n        \n            \n    Context for -\n    core.search.symbol_graph._CallerCalleeManager -\n    \n      Class Docstring:\n        Manages the caller-callee relationships of a symbol in a graph.\n        \n      Variables:\n        self._graph=graph\n        self.navigator=_SymbolGraphNavigator(graph)\n        self.document=document\n        \n      Methods:\n        def __init__(self, graph: nx.MultiDiGraph, document: Any):\n                self._graph = graph\n                self.navigator = _SymbolGraphNavigator(graph)\n                self.document = document\n        \n            \n    Context for -\n    core.symbol.symbol_types.SymbolReference -\n    \n        \n      Methods:\n", "# SymbolGraph\n\n`SymbolGraph` is a class that represents a graph of program symbols, created from an index protobuf file. It facilitates efficient program analysis tasks such as querying symbol relationships, retrieving all files and symbols defined in the graph, and creating rankable symbol subgraphs. The class includes closely related symbols like `Symbol`, `GraphBuilder`, and `PythonContextRetriever`.\n\n## Overview\n\n`SymbolGraph` can be initialized with an index protobuf file and offers various methods to explore and analyze the symbol graph. With these methods, it is possible to query defined symbols, retrieve all file nodes, get callees and callers of a symbol, get relationships and dependencies of a symbol, and more. It interacts with other classes and utilities such as `Symbol`, `GraphBuilder`, and `PythonContextRetriever` to build and manage the graph.\n\n## Related Symbols\n\n- `core.symbol.symbol_types.Symbol`: Represents a class, method, or local variable with a standardized string representation.\n- `core.search.symbol_graph.GraphBuilder`: Builds a symbol graph from an index.\n- `core.context.python_context.python_context_retriever.PythonContextRetriever`: Retrieves context information related to a symbol.\n\n## Example\n\nThe following example demonstrates how to create an instance of `SymbolGraph` and use its methods to explore the graph.\n\n```python\nfrom core.search.symbol_graph import SymbolGraph\n\nindex_path = \"path/to/index.protobuf\"\nsymbol_graph = SymbolGraph(index_path)\n\n# Retrieve all defined symbols in the graph\ngraph_symbols = symbol_graph.get_all_defined_symbols()\n\n# Retrieve all file nodes from the graph\nfile_nodes = symbol_graph.get_all_files()\n```\n\n## Limitations\n\nThe `SymbolGraph` class relies on an index protobuf file provided during initialization, and assumes a specific directory structure. It might be difficult to use it with custom protobuf files or directory structures. Additionally, callers and callees of a symbol require downstream filtering for accurate results.\n\n## Follow-up Questions:\n\n- Can the `SymbolGraph` class be made more efficient in its current form, and can edge cases not handled in apparent ways be better managed?\n- Can the class be adapted to load custom configuration files and support more flexible directory structures?", "`SymbolGraph` is a class representing a graph of program symbols created from an index protobuf file, enabling efficient program analysis tasks such as querying symbol relationships and retrieving defined files and symbols. It can be initialized with an index protobuf file and provides various methods to explore and analyze the symbol graph, interacting with related symbols like `Symbol`, `GraphBuilder`, and `PythonContextRetriever` to build and manage the graph. However, it relies on a specific directory structure and index protobuf file, which may make it challenging to use with custom files or directory structures.\n\n```\nfrom core.search.symbol_graph import SymbolGraph\n\nindex_path = \"path/to/index.protobuf\"\nsymbol_graph = SymbolGraph(index_path)\n\ngraph_symbols = symbol_graph.get_all_defined_symbols()\nfile_nodes = symbol_graph.get_all_files()\n```"]}}