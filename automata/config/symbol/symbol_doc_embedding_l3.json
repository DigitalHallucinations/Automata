[{"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.config.config_enums`/ConfigCategory#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.config.config_enums", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "ConfigCategory", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# ConfigCategory\n\n`ConfigCategory` is an enumeration class that maps the names of folders holding config files. It helps in organizing the application configuration files by allowing the categorization of configurations.\n\n## Related Symbols\n\n- `automata.config.config_enums.ConfigCategory`\n- `automata.tests.unit.test_py_writer.MockCodeGenerator`\n- `automata.tests.unit.sample_modules.sample.EmptyClass`\n- `automata.cli.commands.cli`\n- `automata.core.context.py_context.retriever.PyContextRetrieverConfig`\n- `automata.tests.unit.sample_modules.sample_module_2.ObNMl`\n- `automata.core.context.py_context.retriever.PyContextRetriever`\n\n## Example\n\nHere's a simple example demonstrating how to use the `ConfigCategory` enumeration.\n\n```python\nfrom automata.config.config_enums import ConfigCategory\n\nconfig_category = ConfigCategory.PROMPT\nprint(config_category)  # Output: ConfigCategory.PROMPT\n```\n\nIt can be used to categorize and manage different configuration files in the application, making it easier to maintain and organize complex configuration settings.\n\n## Limitations\n\n`ConfigCategory` itself has no significant limitations. However, it relies on the directory structure of the application and the presence of the corresponding config folders. If the folder names change or are removed, the enumeration must be updated accordingly.\n\n## Follow-up Questions:\n\n- How can we dynamically update the `ConfigCategory` enumeration when the folder structure changes?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/reduce": [{"py/type": "numpy.dtype"}, {"py/tuple": ["f8", false, true]}, {"py/tuple": [3, "<", null, null, null, -1, -1, 0]}]}, false, {"py/b64": "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"}]}]}, "source_code": "class ConfigCategory(Enum):\n    \"\"\"\n    An enum which corresponds to the name of a folder holding config\n    \"\"\"\n\n    PROMPT = \"prompt\"\n    SYMBOL = \"symbol\"\n", "summary": "`ConfigCategory` is an enumeration class used to map the names of folders holding config files for better organization and management of application configuration files. It allows categorization of configurations and relies on the application's directory structure and the presence of corresponding config folders. For example, to use `ConfigCategory`:\n\n```python\nfrom automata.config.config_enums import ConfigCategory\n\nconfig_category = ConfigCategory.PROMPT\nprint(config_category)  # Output: ConfigCategory.PROMPT\n```\n\nHowever, if folder names change or are removed, the enumeration must be updated accordingly.", "context": "\n    Generate the documentation for ConfigCategory using the context shown below -\n  Building context for primary symbol - automata.config.config_enums.ConfigCategory -\n  \n      class ConfigCategory(Enum):\n          \"\"\"\n          An enum which corresponds to the name of a folder holding config\n          \"\"\"\n      \n          PROMPT = \"prompt\"\n          SYMBOL = \"symbol\"\n      \n      \n  Building context for related symbols -\n  \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample.EmptyClass\n    \n        class EmptyClass:\n            pass\n        \n        \n        \n        \n    automata.cli.commands.cli\n    \n      Methods:\n        cli(ctx) -> None\n        \n    automata.core.context.py_context.retriever.PyContextRetrieverConfig\n    \n        class PyContextRetrieverConfig:\n            \"\"\"The configuration for the PyContextRetriever\"\"\"\n        \n            def __init__(\n                self,\n                spacer: str = \"  \",\n                max_dependencies_to_process: int = 10,\n                max_related_symbols_to_process: int = 10,\n                model_name: str = \"gpt-4\",\n                max_context: int = 6_500,\n            ):\n                \"\"\"\n                Args:\n                    spacer (str): The string to use for indentation\n                    max_dependency_print_depth (int): The maximum depth to print dependencies\n                    max_recursion_depth (int): The maximum depth to recurse into dependencies\n                    max_related_symbols_to_process (int): The number of nearest symbols to print\n                \"\"\"\n                self.spacer = spacer\n                self.max_dependencies_to_process = max_dependencies_to_process\n                self.max_related_symbols_to_process = max_related_symbols_to_process\n                self.model_name = model_name\n                self.max_context = max_context\n        \n        \n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator.generate_code\n    \n        def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            \n        \n    automata.tests.unit.test_py_code_retriever.test_build_overview\n    \n        def test_build_overview():\n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            result = build_repository_overview(sample_dir)\n            first_module_overview = \"sample\\n     - func sample_function\\n     - cls Person\\n       - func __init__\\n       - func say_hello\\n       - func run\\n     - func f\\n     - cls EmptyClass\\n     - cls OuterClass\\n       - cls InnerClass\\n         - func inner_method\\nsample2\\n     - cls PythonAgentToolBuilder\\n       - func __init__\\n       - func build_tools\\n         - func python_agent_python_task\"\n        \n            assert first_module_overview in result\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl\n    \n        class ObNMl:\n            \"\"\"zFsdXovhQSBlqDNpXSvl\"\"\"\n        \n            def __init__(self):\n                pass\n        \n            def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.core.context.py_context.retriever.PyContextRetriever\n    \n        PyContextRetriever is a class that retrieves the context of a symbol in a Python project, helping generate documentation and understanding symbol relationships. It processes abstract syntax tree (AST) nodes and operates on a SymbolGraph with a PyContextRetrieverConfig object. To use it, create a SymbolGraph instance, instantiate the PyContextRetriever with the graph, process a symbol using the `process_symbol` method, and retrieve the context buffer. Note that PyContextRetriever relies on accurate SymbolGraph and PyContextRetrieverConfig inputs; errors in these may cause issues when processing symbols. \n        \n        Usage Example:\n        \n        ```python\n        from automata.core.context.py_context.retriever import PyContextRetriever\n        from automata.core.symbol.graph import SymbolGraph\n        \n        graph = SymbolGraph()\n        py_context_retriever = PyContextRetriever(graph)\n        symbol = some_symbol\n        \n        # Process the context of the symbol\n        py_context_retriever.process_symbol(symbol)\n        \n        # Retrieve the context buffer\n        context_buffer = py_context_retriever.get_context_buffer()\n        ```\n        \n      Class Docstring:\n        The PyContextRetriever is used to retrieve the context of a symbol in a Python project\n        \n      Methods:\n        IndentManager(self) -> None\n        \n        def __init__(\n                self,\n                graph: SymbolGraph,\n                config: PyContextRetrieverConfig = PyContextRetrieverConfig(),\n                doc_embedding_db: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                Args:\n                    graph (SymbolGraph): The symbol graph to use\n                    config (PyContextRetrieverConfig): The configuration to use\n                \"\"\"\n                self.graph = graph\n                self.config = config\n                self.indent_level = 0\n                self.doc_embedding_db = doc_embedding_db\n                self.encoding = tiktoken.encoding_for_model(self.config.model_name)\n        \n                self.reset()\n        \n            \n        get_context_buffer(self) -> str\n        \n        indent() -> str\n        \n        process_ast(self, symbol: Symbol) -> None\n        \n        process_docstring(self, ast_object: RedBaron) -> None\n        \n        process_documentation(self, symbol: Symbol, is_main_symbol: bool) -> None\n        \n        process_headline(self, symbol: Symbol) -> None\n        \n        process_imports(self, symbol: Symbol) -> None\n        \n        process_message(self, message: str) -> None\n        \n        process_method(self, method: RedBaron, is_main_symbol: bool) -> None\n        \n        process_symbol(self,\n                symbol: Symbol,\n                related_symbols: List[Symbol] = [],\n            ) -> None\n        \n        reset(self) -> None\n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl.method\n    \n        def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.core.symbol.search.rank.SymbolRankConfig\n    \n        class SymbolRankConfig(BaseModel):\n            \"\"\"A configuration class for SymbolRank\"\"\"\n        \n            alpha: float = 0.25\n            max_iterations: int = 100\n            tolerance: float = 1.0e-6\n            weight_key: str = \"weight\"\n        \n            @classmethod\n            def validate(cls, config):\n                \"\"\"\n                Validate configuration parameters.\n        \n                Args:\n                    config (SymbolRankConfig): Configuration parameters.\n        \n                Raises:\n                    ValueError: If alpha is not in (0, 1), or tolerance is not in (1e-4, 1e-8).\n                \"\"\"\n                if not 0 < config.alpha < 1:\n                    raise ValueError(f\"alpha must be in (0,1), but got {config.alpha}\")\n        \n                if not 1.0e-8 < config.tolerance < 1.0e-4:\n                    raise ValueError(f\"tolerance must be in (1e-4,1e-8), but got {config.tolerance}\")\n        \n        \n        \n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.coding.directory`/Directory#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.coding.directory", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "Directory", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# Directory\n\n`Directory` represents a directory, which can contain other directories or files as children. It provides methods for working with directory structures like adding child nodes, getting file names and subdirectories, checking if a directory is a leaf or root directory, and more.\n\n## Overview\n\nThe `Directory` class is designed for working with directory structures. It extends the abstract base class `Node`. Its main purpose is to model directories, but it also provides relevant functionality for working with those directories. Building context and understanding the Directory class allows you to work more easily with file systems and directory settings in your project.\n\n## Import Statements\n\n```python\nimport logging\nimport os\nfrom typing import Dict, List, Optional\n```\n\n## Related Symbols\n\n- `automata.tests.unit.test_directory_manager.test_load_directory_structure`\n- `automata.tests.unit.test_directory_manager.test_get_files_in_dir`\n- `automata.tests.unit.test_directory_manager.test_get_subdirectories`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.database.vector.JSONVectorDatabase`\n- `automata.tests.unit.test_directory_manager.test_get_node_for_path`\n- `automata.core.coding.directory.File`\n- `automata.tests.unit.sample_modules.sample.OuterClass`\n- `automata.core.coding.py_coding.module_tree.LazyModuleTreeMap`\n\n## Examples\n\n```python\nfrom automata.core.coding.directory import Directory\n\n# Create a sample root directory\nroot_dir = Directory(name=\"root\")\n\n# Create a sample child directory\nchild_dir = Directory(name=\"child\", parent=root_dir)\n\n# Add the child directory to the root directory\nroot_dir.add_child(child_dir)\n\n# Get the subdirectories of the root directory\nsubdirectories = root_dir.get_subdirectories()\nprint(subdirectories)  # Output: ['child']\n```\n\n## Limitations\n\nThe primary limitation of the `Directory` class is that it doesn't provide advanced functionality for working with the contents of directories or files, such as searching for a specific file or directory, moving or renaming files/directories, etc. Additionally, it models only a simple file tree structure without support for links or other more complex features found in actual file systems.\n\n## Follow-up Questions:\n\n- How can we implement more advanced features for working with files and directories, like searching or moving/renaming files and directories within a `Directory` object's structure?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class Directory(Node):\n    \"\"\"Represents a directory. Has children which can be directories or files\"\"\"\n\n    def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n        \"\"\"\n        Args:\n            name (str): Name of the directory\n            parent (Node): Parent node of this directory\n        \"\"\"\n        super().__init__(name, parent)\n        self.children: Dict[str, Node] = {}\n\n    def add_child(self, child: \"Node\"):\n        \"\"\"\n        Adds a child node to this directory\n\n        Args:\n            child (Node): Child node to add\n        \"\"\"\n        self.children[child.name] = child\n\n    def get_file_names(self) -> List[str]:\n        \"\"\"\n        Get a list of file names in the directory\n\n        Args:\n            directory (Directory): Directory to get file names from\n\n        Returns:\n            List[str]: List of file names in the directory\n        \"\"\"\n        return [name for name, child in self.children.items() if isinstance(child, File)]\n\n    def get_subdirectories(self) -> List[str]:\n        \"\"\"\n        Get a list of subdirectory names in the directory\n\n        Args:\n            directory (Directory): Directory to get subdirectory names from\n\n        Returns:\n            List[str]: List of subdirectory names in the directory\n        \"\"\"\n        return [name for name, child in self.children.items() if isinstance(child, Directory)]\n\n    def is_root_dir(self) -> bool:\n        \"\"\"\n        Check if this directory is the root directory\n\n        Returns:\n            bool: True if this directory is the root directory, False otherwise\n        \"\"\"\n        return self.parent is None\n\n    def is_leaf_dir(self) -> bool:\n        \"\"\"\n        Check if this directory is a leaf directory (has no subdirectories)\n\n        Returns:\n            bool: True if this directory is a leaf directory, False otherwise\n        \"\"\"\n        subdirectories = [\n            child\n            for child in self.children.values()\n            if isinstance(child, Directory) and \"__pycache__\" not in child.name\n        ]\n        return len(subdirectories) == 0\n\n\n", "summary": "The `Directory` class represents a directory structure and extends from the abstract base class `Node`. It includes methods for adding child nodes, obtaining file names and subdirectories, and determining if a directory is a leaf or root. However, it has some limitations such as lacking advanced functionality for working with files and directories, such as searching or moving/renaming files and directories. To illustrate, here's an example of how to use the `Directory` class:\n\n```python\nfrom automata.core.coding.directory import Directory\n\n# Create a sample root directory\nroot_dir = Directory(name=\"root\")\n\n# Create a sample child directory\nchild_dir = Directory(name=\"child\", parent=root_dir)\n\n# Add the child directory to the root directory\nroot_dir.add_child(child_dir)\n\n# Get the subdirectories of the root directory\nsubdirectories = root_dir.get_subdirectories()\nprint(subdirectories)  # Output: ['child']\n```", "context": "\n    Generate the documentation for Directory using the context shown below -\n  Building context for primary symbol - automata.core.coding.directory.Directory -\n  \n    Import Statements:\n      import logging\n      import os\n      from typing import Dict, List, Optional\n      \n      # Directory\n      \n      `Directory` represents a directory, which can contain other directories or files as children. It provides methods for working with directory structures like adding child nodes, getting file names and subdirectories, checking if a directory is a leaf or root directory, and more.\n      \n      ## Overview\n      \n      The `Directory` class is designed for working with directory structures. It extends the abstract base class `Node`. Its main purpose is to model directories, but it also provides relevant functionality for working with those directories. Building context and understanding the Directory class allows you to work more easily with file systems and directory settings in your project.\n      \n      ## Import Statements\n      \n      ```python\n      import logging\n      import os\n      from typing import Dict, List, Optional\n      ```\n      \n      ## Related Symbols\n      \n      - `automata.tests.unit.test_directory_manager.test_load_directory_structure`\n      - `automata.tests.unit.test_directory_manager.test_get_files_in_dir`\n      - `automata.tests.unit.test_directory_manager.test_get_subdirectories`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.database.vector.JSONVectorDatabase`\n      - `automata.tests.unit.test_directory_manager.test_get_node_for_path`\n      - `automata.core.coding.directory.File`\n      - `automata.tests.unit.sample_modules.sample.OuterClass`\n      - `automata.core.coding.py_coding.module_tree.LazyModuleTreeMap`\n      \n      ## Examples\n      \n      ```python\n      from automata.core.coding.directory import Directory\n      \n      # Create a sample root directory\n      root_dir = Directory(name=\"root\")\n      \n      # Create a sample child directory\n      child_dir = Directory(name=\"child\", parent=root_dir)\n      \n      # Add the child directory to the root directory\n      root_dir.add_child(child_dir)\n      \n      # Get the subdirectories of the root directory\n      subdirectories = root_dir.get_subdirectories()\n      print(subdirectories)  # Output: ['child']\n      ```\n      \n      ## Limitations\n      \n      The primary limitation of the `Directory` class is that it doesn't provide advanced functionality for working with the contents of directories or files, such as searching for a specific file or directory, moving or renaming files/directories, etc. Additionally, it models only a simple file tree structure without support for links or other more complex features found in actual file systems.\n      \n      ## Follow-up Questions:\n      \n      - How can we implement more advanced features for working with files and directories, like searching or moving/renaming files and directories within a `Directory` object's structure?\n      \n    Class Docstring:\n      Represents a directory. Has children which can be directories or files\n      \n    Methods:\n      def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n              \"\"\"\n              Args:\n                  name (str): Name of the directory\n                  parent (Node): Parent node of this directory\n              \"\"\"\n              super().__init__(name, parent)\n              self.children: Dict[str, Node] = {}\n      \n          \n      def add_child(self, child: \"Node\"):\n              \"\"\"\n              Adds a child node to this directory\n      \n              Args:\n                  child (Node): Child node to add\n              \"\"\"\n              self.children[child.name] = child\n      \n          \n      def get_file_names(self) -> List[str]:\n              \"\"\"\n              Get a list of file names in the directory\n      \n              Args:\n                  directory (Directory): Directory to get file names from\n      \n              Returns:\n                  List[str]: List of file names in the directory\n              \"\"\"\n              return [name for name, child in self.children.items() if isinstance(child, File)]\n      \n          \n      def get_subdirectories(self) -> List[str]:\n              \"\"\"\n              Get a list of subdirectory names in the directory\n      \n              Args:\n                  directory (Directory): Directory to get subdirectory names from\n      \n              Returns:\n                  List[str]: List of subdirectory names in the directory\n              \"\"\"\n              return [name for name, child in self.children.items() if isinstance(child, Directory)]\n      \n          \n      def is_leaf_dir(self) -> bool:\n              \"\"\"\n              Check if this directory is a leaf directory (has no subdirectories)\n      \n              Returns:\n                  bool: True if this directory is a leaf directory, False otherwise\n              \"\"\"\n              subdirectories = [\n                  child\n                  for child in self.children.values()\n                  if isinstance(child, Directory) and \"__pycache__\" not in child.name\n              ]\n              return len(subdirectories) == 0\n      \n      \n      \n      def is_root_dir(self) -> bool:\n              \"\"\"\n              Check if this directory is the root directory\n      \n              Returns:\n                  bool: True if this directory is the root directory, False otherwise\n              \"\"\"\n              return self.parent is None\n      \n          \n  Building context for related symbols -\n  \n    automata.tests.unit.test_directory_manager.test_load_directory_structure\n    \n        def test_load_directory_structure(tmp_path):\n            test_dir = create_test_dir_structure(tmp_path)\n            dir_manager = DirectoryManager(str(test_dir))\n            assert dir_manager.root.name == str(test_dir)\n            assert len(dir_manager.root.children) == 2  # 2 directories: dir1, dir2\n        \n        \n        \n        \n    automata.tests.unit.test_directory_manager.test_get_files_in_dir\n    \n        def test_get_files_in_dir(tmp_path):\n            test_dir = create_test_dir_structure(tmp_path)\n            dir_manager = DirectoryManager(str(test_dir))\n            files_in_dir1 = dir_manager.get_files_in_dir(\"dir1\")\n            assert len(files_in_dir1) == 2  # 2 files in dir1: file1, file2\n            assert set(files_in_dir1) == {\"file1\", \"file2\"}\n        \n        \n        \n        \n    automata.tests.unit.test_directory_manager.test_get_subdirectories\n    \n        def test_get_subdirectories(tmp_path):\n            test_dir = create_test_dir_structure(tmp_path)\n            dir_manager = DirectoryManager(str(test_dir))\n            subdirectories = dir_manager.get_subdirectories(\".\")\n            assert len(subdirectories) == 2  # 2 subdirectories in root: dir1, dir2\n            assert set(subdirectories) == {\"dir1\", \"dir2\"}\n        \n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_directory_manager.test_get_node_for_path\n    \n        def test_get_node_for_path(tmp_path):\n            test_dir = create_test_dir_structure(tmp_path)\n            dir_manager = DirectoryManager(str(test_dir))\n            dir1_node = dir_manager._get_node_for_path(dir_manager.root, \"dir1\")\n            assert dir1_node is not None\n            assert dir1_node.name == \"dir1\"\n            assert len(dir1_node.children) == 2  # 2 files in dir1: file1, file2\n        \n        \n        \n        \n    automata.tests.unit.test_directory_manager.create_test_dir_structure\n    \n        def create_test_dir_structure(tmp_path):\n            \"\"\"\n            Creates a test directory structure under the given path.\n            \"\"\"\n            (tmp_path / \"dir1\").mkdir()\n            (tmp_path / \"dir2\").mkdir()\n            (tmp_path / \"dir1\" / \"file1\").write_text(\"content\")\n            (tmp_path / \"dir1\" / \"file2\").write_text(\"content\")\n            (tmp_path / \"dir2\" / \"file1\").write_text(\"content\")\n            return tmp_path\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample.OuterClass\n    \n        class OuterClass:\n            class InnerClass:\n                \"\"\"Inner doc strings\"\"\"\n        \n                def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap\n    \n        The `LazyModuleTreeMap` class is a lazy dictionary that maps module dotpaths to their corresponding RedBaron FST objects, loading and caching the modules in memory as they are accessed. It provides methods for fetching existing module dotpaths and filepaths, as well as fetching, putting, and updating modules by their dotpaths. However, it assumes a specific directory structure according to the `DotPathMap` class and does not support custom directory structures for modules.\n        \n        ```python\n        from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n        from automata.core.utils import root_fpath\n        \n        path_to_root = root_fpath()\n        module_tree_map = LazyModuleTreeMap(path_to_root)\n        \n        # Fetch an existing module by its dotpath\n        module_dotpath = \"automata.core.agent.automata_agent\"\n        module = module_tree_map.fetch_module(module_dotpath)\n        \n        # Check if a module with the given dotpath exists\n        exists = module_dotpath in module_tree_map\n        ```\n        \n      Class Docstring:\n        A lazy dictionary between module dotpaths and their corresponding RedBaron FST objects.\n        Loads and caches modules in memory as they are accessed\n        \n      Methods:\n        __contains__(self, dotpath) -> None\n        \n        def __init__(self, path: str):\n                \"\"\"\n                Args:\n                    path: The absolute path to the root of the module tree\n                \"\"\"\n                self._dotpath_map = DotPathMap(path)\n                self._loaded_modules: Dict[str, Optional[RedBaron]] = {}\n        \n            \n        cached_default(cls) -> \"LazyModuleTreeMap\"\n        \n        fetch_existing_module_dotpath(self, module_obj: RedBaron) -> Optional[str]\n        \n        fetch_existing_module_fpath_by_dotpath(self, module_dotpath: str) -> Optional[str]\n        \n        fetch_module(self, module_dotpath: str) -> Optional[RedBaron]\n        \n        get_module_dotpath_by_fpath(self, module_fpath: str) -> str\n        \n        items(self) -> Iterable[Tuple[str, Optional[RedBaron]]]\n        \n        put_module(self, module_dotpath: str, module: RedBaron) -> None\n        \n    automata.core.coding.directory.File\n    \n        The `File` class represents a file in a file tree, including its name and parent node, and is useful for managing, navigating or analyzing directory structures. It inherits from the abstract base class `Node` but does not provide built-in functionality for reading/writing contents, modifying attributes, or traversing the file tree. Additional functionality or Python libraries may be needed for these operations. Here's an example of creating an instance of `File`:\n        \n        ```python\n        from automata.core.coding.directory import File\n        \n        file_name = \"example.txt\"\n        parent_node = None\n        \n        new_file = File(file_name, parent_node)\n        ```\n        \n      Class Docstring:\n        Represents a file in the tree\n        \n      Methods:\n        def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n                \"\"\"\n                Args:\n                    name (str): Name of the file\n                    parent (Node): Parent node of this file\n                \"\"\"\n                super().__init__(name, parent)\n        \n        \n        \n  Building context for dependencies -\n  \n    automata.core.coding.directory.Node\n    \n        `Node` is an abstract base class within the `automata.core.coding.directory` package that represents a node in a file tree, with a `name` and a `parent` pointing to its parent in the tree hierarchy. Though not directly instantiated, the class serves as a superclass for `File` and `Directory` classes. To use these classes, create a root directory with subdirectories and files, add children to the directories as needed, and import the necessary classes from the package:\n        \n        ```python\n        from automata.core.coding.directory import File, Directory\n        \n        root = Directory(\"root\")\n        subdir1 = Directory(\"subdir1\", root)\n        subdir2 = Directory(\"subdir2\", root)\n        file1 = File(\"file1.txt\", root)\n        file2 = File(\"file2.txt\", root)\n        subdir1_file1 = File(\"file1.txt\", subdir1)\n        subdir1_file2 = File(\"file2.txt\", subdir1)\n        subdir2_file1 = File(\"file1.txt\", subdir2)\n        \n        root.add_child(subdir1)\n        root.add_child(subdir2)\n        root.add_child(file1)\n        root.add_child(file2)\n        subdir1.add_child(subdir1_file1)\n        subdir1.add_child(subdir1_file2)\n        subdir2.add_child(subdir2_file1)\n        ```\n        \n      Class Docstring:\n        Abstract base class for a node in the file tree\n        \n      Methods:\n        def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n                \"\"\"\n                Args:\n                    name (str): Name of the node\n                    parent (Node): Parent node of this node\n                \"\"\"\n                self.name = name\n                self.parent = parent\n        \n        \n        \n    automata.core.coding.directory.Node.__init__\n    \n      Class Docstring:\n        Args:\n        name (str): Name of the node\n        parent (Node): Parent node of this node\n        \n      Methods:\n        def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n                \"\"\"\n                Args:\n                    name (str): Name of the node\n                    parent (Node): Parent node of this node\n                \"\"\"\n                self.name = name\n                self.parent = parent\n        \n        \n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.coding.directory`/DirectoryManager#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.coding.directory", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "DirectoryManager", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# DirectoryManager\n\n`DirectoryManager` is a utility class that handles operations related to directory structures. It provides methods to create directories, get the list of files in a given directory, and get the list of subdirectories in a given directory.\n\n## Overview\n\n`DirectoryManager` is initialized with a base path of the directory structure, which is then used in various methods to perform operations on directories and their contents. To create a directory manager instance:\n\n```python\nfrom automata.core.coding.directory import DirectoryManager\ndm = DirectoryManager(\"/path/to/base/directory\")\n```\n\n## Related Symbols\n\n- `automata.core.coding.directory.Directory`\n- `automata.core.coding.directory.File`\n- `automata.core.coding.directory.Node`\n\n## Example\n\nThe following examples demonstrate how to use `DirectoryManager` to create a directory and retrieve the list of files and subdirectories in a given directory.\n\n```python\nfrom automata.core.coding.directory import DirectoryManager\n\n# Creating a new directory\nbase_path = \"/path/to/base/directory\"\ndm = DirectoryManager(base_path)\ndm.ensure_directory_exists(\"new_directory\")\n\n# Retrieving the list of files and subdirectories in a given directory\nfiles = dm.get_files_in_dir(\"new_directory\")\nsubdirs = dm.get_subdirectories(\"new_directory\")\nprint(\"Files:\", files)\nprint(\"Subdirectories:\", subdirs)\n```\n\n## Limitations\n\n`DirectoryManager` has some limitations:\n\n- It assumes a specific directory structure based on the base path provided during initialization.\n- It does not provide any error handling for incorrect or inaccessible paths. If the path is incorrect or not accessible, the functions may fail with unclear error messages.\n\n## Follow-up Questions:\n\n- Are there any additional methods that would be useful for a DirectoryManager class?\n- How can error handling be improved to provide clearer error messages when dealing with incorrect or inaccessible paths?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class DirectoryManager:\n    \"\"\"Handles operations related to directory structure.\"\"\"\n\n    def __init__(self, base_path: str):\n        \"\"\"\n        Args:\n            base_path (str): Base path of the directory structure\n        \"\"\"\n        self.root = self._load_directory_structure(base_path)\n\n    def _load_directory_structure(self, root_dir: str) -> \"Directory\":\n        \"\"\"Load directory structure into Directory and File objects.\"\"\"\n        root = Directory(root_dir)\n        self.root = root  # Set root before walking through directory\n\n        # Map of directory paths to their corresponding nodes\n        dir_path_to_node = {root_dir: root}\n\n        for parent_dir, dirs, files in os.walk(root_dir):\n            # Find the parent directory node\n            parent_node = dir_path_to_node[parent_dir]\n\n            # Add all directories\n            for dir in dirs:\n                dir_node = Directory(dir, parent_node)\n                parent_node.add_child(dir_node)\n                dir_path_to_node[os.path.join(parent_dir, dir)] = dir_node\n\n            # Add all files\n            for file in files:\n                parent_node.add_child(File(file, parent_node))\n\n        return root\n\n    def get_files_in_dir(self, path: str) -> List[str]:\n        \"\"\"\n        Get a list of files in the given directory\n\n        Args:\n            path (str): Path of the directory\n\n        Returns:\n            List[str]: List of files in the directory\n        \"\"\"\n        dir_node = self._get_node_for_path(self.root, path)\n        if dir_node and isinstance(dir_node, Directory):\n            return dir_node.get_file_names()\n        else:\n            return []\n\n    def get_subdirectories(self, path: str) -> List[str]:\n        \"\"\"\n        Get a list of subdirectories in the given directory\n\n        Args:\n            path (str): Path of the directory\n\n        Returns:\n            List[str]: List of subdirectories in the directory\n        \"\"\"\n        dir_node = self._get_node_for_path(self.root, path)\n        if dir_node and isinstance(dir_node, Directory):\n            return dir_node.get_subdirectories()\n        else:\n            return []\n\n    def ensure_directory_exists(self, directory_path: str):\n        \"\"\"\n        Creates the directory if it does not exist already\n\n        Args:\n            directory_path (str): Path of the directory to create\n        \"\"\"\n        if not os.path.exists(directory_path):\n            logger.info(f\"Creating directory_path = {directory_path}\")\n            os.makedirs(directory_path)\n            self.root = self._load_directory_structure(directory_path)\n\n    def _get_node_for_path(self, root: \"Directory\", path: str) -> Optional[\"Node\"]:\n        \"\"\"\n        Find the node for a given path\n\n        Args:\n            root (Directory): Root node of the tree\n            path (str): Path to find the node for\n\n        Returns:\n            Optional[Node]: Node for the given path, None if not found\n        \"\"\"\n\n        if path == \".\":\n            return root\n\n        path_parts = path.split(os.sep)\n        # Initial node is root\n        node: Directory = root\n\n        # Iterate through path parts\n        for part in path_parts:\n            if part in node.children:\n                new_node = node.children[part]\n                if not isinstance(new_node, Directory):\n                    # If part is a file, return None\n                    return None\n                node = new_node\n            else:\n                # If part not found in children, return None\n                return None\n\n        return node\n", "summary": "The `DirectoryManager` utility class handles operations related to directory structures, such as creating directories and listing files and subdirectories. It is initialized with a base path and includes related symbols like `automata.core.coding.directory.Directory`, `.File`, and `.Node`. Example usage involves creating a directory and retrieving the list of files and subdirectories in a given directory. However, the class has some limitations, such as assuming a specific directory structure and lacking error handling for incorrect or inaccessible paths, which could result in unclear error messages.", "context": "\n    Generate the documentation for DirectoryManager using the context shown below -\n  Building context for primary symbol - automata.core.coding.directory.DirectoryManager -\n  \n    Import Statements:\n      import logging\n      import os\n      from typing import Dict, List, Optional\n      \n      # DirectoryManager\n      \n      `DirectoryManager` is a utility class that handles operations related to directory structures. It provides methods to create directories, get the list of files in a given directory, and get the list of subdirectories in a given directory.\n      \n      ## Overview\n      \n      `DirectoryManager` is initialized with a base path of the directory structure, which is then used in various methods to perform operations on directories and their contents. To create a directory manager instance:\n      \n      ```python\n      from automata.core.coding.directory import DirectoryManager\n      dm = DirectoryManager(\"/path/to/base/directory\")\n      ```\n      \n      ## Related Symbols\n      \n      - `automata.core.coding.directory.Directory`\n      - `automata.core.coding.directory.File`\n      - `automata.core.coding.directory.Node`\n      \n      ## Example\n      \n      The following examples demonstrate how to use `DirectoryManager` to create a directory and retrieve the list of files and subdirectories in a given directory.\n      \n      ```python\n      from automata.core.coding.directory import DirectoryManager\n      \n      # Creating a new directory\n      base_path = \"/path/to/base/directory\"\n      dm = DirectoryManager(base_path)\n      dm.ensure_directory_exists(\"new_directory\")\n      \n      # Retrieving the list of files and subdirectories in a given directory\n      files = dm.get_files_in_dir(\"new_directory\")\n      subdirs = dm.get_subdirectories(\"new_directory\")\n      print(\"Files:\", files)\n      print(\"Subdirectories:\", subdirs)\n      ```\n      \n      ## Limitations\n      \n      `DirectoryManager` has some limitations:\n      \n      - It assumes a specific directory structure based on the base path provided during initialization.\n      - It does not provide any error handling for incorrect or inaccessible paths. If the path is incorrect or not accessible, the functions may fail with unclear error messages.\n      \n      ## Follow-up Questions:\n      \n      - Are there any additional methods that would be useful for a DirectoryManager class?\n      - How can error handling be improved to provide clearer error messages when dealing with incorrect or inaccessible paths?\n      \n    Class Docstring:\n      Handles operations related to directory structure.\n      \n    Methods:\n      def __init__(self, base_path: str):\n              \"\"\"\n              Args:\n                  base_path (str): Base path of the directory structure\n              \"\"\"\n              self.root = self._load_directory_structure(base_path)\n      \n          \n      def ensure_directory_exists(self, directory_path: str):\n              \"\"\"\n              Creates the directory if it does not exist already\n      \n              Args:\n                  directory_path (str): Path of the directory to create\n              \"\"\"\n              if not os.path.exists(directory_path):\n                  logger.info(f\"Creating directory_path = {directory_path}\")\n                  os.makedirs(directory_path)\n                  self.root = self._load_directory_structure(directory_path)\n      \n          \n      def get_files_in_dir(self, path: str) -> List[str]:\n              \"\"\"\n              Get a list of files in the given directory\n      \n              Args:\n                  path (str): Path of the directory\n      \n              Returns:\n                  List[str]: List of files in the directory\n              \"\"\"\n              dir_node = self._get_node_for_path(self.root, path)\n              if dir_node and isinstance(dir_node, Directory):\n                  return dir_node.get_file_names()\n              else:\n                  return []\n      \n          \n      def get_subdirectories(self, path: str) -> List[str]:\n              \"\"\"\n              Get a list of subdirectories in the given directory\n      \n              Args:\n                  path (str): Path of the directory\n      \n              Returns:\n                  List[str]: List of subdirectories in the directory\n              \"\"\"\n              dir_node = self._get_node_for_path(self.root, path)\n              if dir_node and isinstance(dir_node, Directory):\n                  return dir_node.get_subdirectories()\n              else:\n                  return []\n      \n          \n  Building context for related symbols -\n  \n    automata.tests.unit.test_directory_manager.test_load_directory_structure\n    \n        def test_load_directory_structure(tmp_path):\n            test_dir = create_test_dir_structure(tmp_path)\n            dir_manager = DirectoryManager(str(test_dir))\n            assert dir_manager.root.name == str(test_dir)\n            assert len(dir_manager.root.children) == 2  # 2 directories: dir1, dir2\n        \n        \n        \n        \n    automata.tests.unit.test_directory_manager.test_get_files_in_dir\n    \n        def test_get_files_in_dir(tmp_path):\n            test_dir = create_test_dir_structure(tmp_path)\n            dir_manager = DirectoryManager(str(test_dir))\n            files_in_dir1 = dir_manager.get_files_in_dir(\"dir1\")\n            assert len(files_in_dir1) == 2  # 2 files in dir1: file1, file2\n            assert set(files_in_dir1) == {\"file1\", \"file2\"}\n        \n        \n        \n        \n    automata.tests.unit.test_directory_manager.test_get_subdirectories\n    \n        def test_get_subdirectories(tmp_path):\n            test_dir = create_test_dir_structure(tmp_path)\n            dir_manager = DirectoryManager(str(test_dir))\n            subdirectories = dir_manager.get_subdirectories(\".\")\n            assert len(subdirectories) == 2  # 2 subdirectories in root: dir1, dir2\n            assert set(subdirectories) == {\"dir1\", \"dir2\"}\n        \n        \n    automata.core.coding.directory.Directory\n    \n        The `Directory` class represents a directory containing files or other directories as children, providing methods to manage and interact with directory structures. It extends the abstract base class `Node` with functionality such as adding child nodes, getting file names, and subdirectories, and determining leaf or root directories. However, it does not offer advanced capabilities such as searching, moving, or renaming files and directories. The following example demonstrates creating a root directory, adding a child directory, and obtaining subdirectories:\n        \n        ```python\n        from automata.core.coding.directory import Directory\n        \n        # Create a sample root directory\n        root_dir = Directory(name=\"root\")\n        \n        # Create a sample child directory\n        child_dir = Directory(name=\"child\", parent=root_dir)\n        \n        # Add the child directory to the root directory\n        root_dir.add_child(child_dir)\n        \n        # Get the subdirectories of the root directory\n        subdirectories = root_dir.get_subdirectories()\n        print(subdirectories)  # Output: ['child']\n        ```\n        \n        \n      Class Docstring:\n        Represents a directory. Has children which can be directories or files\n        \n      Methods:\n        def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n                \"\"\"\n                Args:\n                    name (str): Name of the directory\n                    parent (Node): Parent node of this directory\n                \"\"\"\n                super().__init__(name, parent)\n                self.children: Dict[str, Node] = {}\n        \n            \n        add_child(self, child: \"Node\") -> None\n        \n        get_file_names(self) -> List[str]\n        \n        get_subdirectories(self) -> List[str]\n        \n        is_leaf_dir(self) -> bool\n        \n        is_root_dir(self) -> bool\n        \n    automata.tests.unit.test_directory_manager.test_get_node_for_path\n    \n        def test_get_node_for_path(tmp_path):\n            test_dir = create_test_dir_structure(tmp_path)\n            dir_manager = DirectoryManager(str(test_dir))\n            dir1_node = dir_manager._get_node_for_path(dir_manager.root, \"dir1\")\n            assert dir1_node is not None\n            assert dir1_node.name == \"dir1\"\n            assert len(dir1_node.children) == 2  # 2 files in dir1: file1, file2\n        \n        \n        \n        \n    automata.tests.unit.test_directory_manager.create_test_dir_structure\n    \n        def create_test_dir_structure(tmp_path):\n            \"\"\"\n            Creates a test directory structure under the given path.\n            \"\"\"\n            (tmp_path / \"dir1\").mkdir()\n            (tmp_path / \"dir2\").mkdir()\n            (tmp_path / \"dir1\" / \"file1\").write_text(\"content\")\n            (tmp_path / \"dir1\" / \"file2\").write_text(\"content\")\n            (tmp_path / \"dir2\" / \"file1\").write_text(\"content\")\n            return tmp_path\n        \n        \n        \n        \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap\n    \n        The `LazyModuleTreeMap` class is a lazy dictionary that maps module dotpaths to their corresponding RedBaron FST objects, loading and caching the modules in memory as they are accessed. It provides methods for fetching existing module dotpaths and filepaths, as well as fetching, putting, and updating modules by their dotpaths. However, it assumes a specific directory structure according to the `DotPathMap` class and does not support custom directory structures for modules.\n        \n        ```python\n        from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n        from automata.core.utils import root_fpath\n        \n        path_to_root = root_fpath()\n        module_tree_map = LazyModuleTreeMap(path_to_root)\n        \n        # Fetch an existing module by its dotpath\n        module_dotpath = \"automata.core.agent.automata_agent\"\n        module = module_tree_map.fetch_module(module_dotpath)\n        \n        # Check if a module with the given dotpath exists\n        exists = module_dotpath in module_tree_map\n        ```\n        \n      Class Docstring:\n        A lazy dictionary between module dotpaths and their corresponding RedBaron FST objects.\n        Loads and caches modules in memory as they are accessed\n        \n      Methods:\n        __contains__(self, dotpath) -> None\n        \n        def __init__(self, path: str):\n                \"\"\"\n                Args:\n                    path: The absolute path to the root of the module tree\n                \"\"\"\n                self._dotpath_map = DotPathMap(path)\n                self._loaded_modules: Dict[str, Optional[RedBaron]] = {}\n        \n            \n        cached_default(cls) -> \"LazyModuleTreeMap\"\n        \n        fetch_existing_module_dotpath(self, module_obj: RedBaron) -> Optional[str]\n        \n        fetch_existing_module_fpath_by_dotpath(self, module_dotpath: str) -> Optional[str]\n        \n        fetch_module(self, module_dotpath: str) -> Optional[RedBaron]\n        \n        get_module_dotpath_by_fpath(self, module_fpath: str) -> str\n        \n        items(self) -> Iterable[Tuple[str, Optional[RedBaron]]]\n        \n        put_module(self, module_dotpath: str, module: RedBaron) -> None\n        \n    automata.core.context.py_context.retriever.PyContextRetriever.IndentManager\n    \n      Class Docstring:\n        A context manager to manage the indentation level\n        \n      Methods:\n        IndentManager(self) -> None\n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.tests.unit.sample_modules.sample.EmptyClass\n    \n        class EmptyClass:\n            pass\n        \n        \n        \n        \n  Building context for dependencies -\n  \n    automata.core.coding.directory.Directory.get_subdirectories\n    \n      Class Docstring:\n        Get a list of subdirectory names in the directory\n        \n        Args:\n        directory (Directory): Directory to get subdirectory names from\n        \n        Returns:\n        List[str]: List of subdirectory names in the directory\n        \n      Methods:\n        get_subdirectories(self) -> List[str]\n        \n    automata.core.coding.directory.Node\n    \n        `Node` is an abstract base class within the `automata.core.coding.directory` package that represents a node in a file tree, with a `name` and a `parent` pointing to its parent in the tree hierarchy. Though not directly instantiated, the class serves as a superclass for `File` and `Directory` classes. To use these classes, create a root directory with subdirectories and files, add children to the directories as needed, and import the necessary classes from the package:\n        \n        ```python\n        from automata.core.coding.directory import File, Directory\n        \n        root = Directory(\"root\")\n        subdir1 = Directory(\"subdir1\", root)\n        subdir2 = Directory(\"subdir2\", root)\n        file1 = File(\"file1.txt\", root)\n        file2 = File(\"file2.txt\", root)\n        subdir1_file1 = File(\"file1.txt\", subdir1)\n        subdir1_file2 = File(\"file2.txt\", subdir1)\n        subdir2_file1 = File(\"file1.txt\", subdir2)\n        \n        root.add_child(subdir1)\n        root.add_child(subdir2)\n        root.add_child(file1)\n        root.add_child(file2)\n        subdir1.add_child(subdir1_file1)\n        subdir1.add_child(subdir1_file2)\n        subdir2.add_child(subdir2_file1)\n        ```\n        \n      Class Docstring:\n        Abstract base class for a node in the file tree\n        \n      Methods:\n        def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n                \"\"\"\n                Args:\n                    name (str): Name of the node\n                    parent (Node): Parent node of this node\n                \"\"\"\n                self.name = name\n                self.parent = parent\n        \n        \n        \n    automata.core.coding.directory.Directory.add_child\n    \n      Class Docstring:\n        Adds a child node to this directory\n        \n        Args:\n        child (Node): Child node to add\n        \n      Methods:\n        add_child(self, child: \"Node\") -> None\n        \n    automata.core.coding.directory.File\n    \n        The `File` class represents a file in a file tree, including its name and parent node, and is useful for managing, navigating or analyzing directory structures. It inherits from the abstract base class `Node` but does not provide built-in functionality for reading/writing contents, modifying attributes, or traversing the file tree. Additional functionality or Python libraries may be needed for these operations. Here's an example of creating an instance of `File`:\n        \n        ```python\n        from automata.core.coding.directory import File\n        \n        file_name = \"example.txt\"\n        parent_node = None\n        \n        new_file = File(file_name, parent_node)\n        ```\n        \n      Class Docstring:\n        Represents a file in the tree\n        \n      Methods:\n        def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n                \"\"\"\n                Args:\n                    name (str): Name of the file\n                    parent (Node): Parent node of this file\n                \"\"\"\n                super().__init__(name, parent)\n        \n        \n        \n    automata.core.coding.directory.Directory.get_file_names\n    \n      Class Docstring:\n        Get a list of file names in the directory\n        \n        Args:\n        directory (Directory): Directory to get file names from\n        \n        Returns:\n        List[str]: List of file names in the directory\n        \n      Methods:\n        get_file_names(self) -> List[str]\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.coding.directory`/File#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.coding.directory", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "File", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# File\n\n`File` is a class that represents a file in the file tree. It inherits from the abstract base class `Node`.\n\n## Overview\n\nThe `File` class provides a way to represent a file in a file tree, including its name and parent node. This class is useful when working with file trees for managing, navigating, or analyzing file structure in a directory.\n\n## Related Symbols\n\n- `automata.core.symbol.symbol_types.SymbolFile`\n- `automata.core.database.vector.JSONVectorDatabase`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.tests.unit.test_symbol_graph.test_get_all_files`\n- `automata.core.symbol.graph.SymbolGraph`\n- `automata.tests.unit.sample_modules.sample_module_2.ObNMl`\n- `automata.tests.unit.test_database_vector.test_init_vector`\n- `automata.core.symbol.symbol_types.SymbolReference`\n- `automata.tests.unit.test_database_vector.test_save`\n\n## Example\n\nThe following example demonstrates how to create an instance of `File`.\n\n```python\nfrom automata.core.coding.directory import File\n\nfile_name = \"example.txt\"\nparent_node = None\n\nnew_file = File(file_name, parent_node)\n```\n\n## Limitations\n\nThe `File` class is primarily a basic representation of a file within a file tree. It does not provide built-in functionality for reading or writing contents, modifying file attributes, or traversing the file tree. For these operations, additional functionality may need to be developed or other Python libraries may be employed.\n\n## Follow-up Questions:\n\n- What are some ways to improve the class to provide additional functionality for manipulating the files?\n- How can we incorporate file reading and writing capabilities within this class?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class File(Node):\n    \"\"\"Represents a file in the tree\"\"\"\n\n    def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n        \"\"\"\n        Args:\n            name (str): Name of the file\n            parent (Node): Parent node of this file\n        \"\"\"\n        super().__init__(name, parent)\n\n\n", "summary": "The `File` class represents a file within a file tree, including its name and parent node. It is inherited from the abstract base class `Node` and is useful for managing, navigating, or analyzing file structures. However, the class does not provide built-in functionality for reading or writing contents, modifying attributes, or traversing the file tree. To create an instance of the `File` class:\n\n```python\nfrom automata.core.coding.directory import File\n\nfile_name = \"example.txt\"\nparent_node = None\n\nnew_file = File(file_name, parent_node)\n```\n\nAdditional functionality or libraries may be needed for more advanced operations.", "context": "\n    Generate the documentation for File using the context shown below -\n  Building context for primary symbol - automata.core.coding.directory.File -\n  \n    Import Statements:\n      import logging\n      import os\n      from typing import Dict, List, Optional\n      \n      # File\n      \n      `File` is a class that represents a file in the file tree. It inherits from the abstract base class `Node`.\n      \n      ## Overview\n      \n      The `File` class provides a way to represent a file in a file tree, including its name and parent node. This class is useful when working with file trees for managing, navigating, or analyzing file structure in a directory.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.symbol_types.SymbolFile`\n      - `automata.core.database.vector.JSONVectorDatabase`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.tests.unit.test_symbol_graph.test_get_all_files`\n      - `automata.core.symbol.graph.SymbolGraph`\n      - `automata.tests.unit.sample_modules.sample_module_2.ObNMl`\n      - `automata.tests.unit.test_database_vector.test_init_vector`\n      - `automata.core.symbol.symbol_types.SymbolReference`\n      - `automata.tests.unit.test_database_vector.test_save`\n      \n      ## Example\n      \n      The following example demonstrates how to create an instance of `File`.\n      \n      ```python\n      from automata.core.coding.directory import File\n      \n      file_name = \"example.txt\"\n      parent_node = None\n      \n      new_file = File(file_name, parent_node)\n      ```\n      \n      ## Limitations\n      \n      The `File` class is primarily a basic representation of a file within a file tree. It does not provide built-in functionality for reading or writing contents, modifying file attributes, or traversing the file tree. For these operations, additional functionality may need to be developed or other Python libraries may be employed.\n      \n      ## Follow-up Questions:\n      \n      - What are some ways to improve the class to provide additional functionality for manipulating the files?\n      - How can we incorporate file reading and writing capabilities within this class?\n      \n    Class Docstring:\n      Represents a file in the tree\n      \n    Methods:\n      def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n              \"\"\"\n              Args:\n                  name (str): Name of the file\n                  parent (Node): Parent node of this file\n              \"\"\"\n              super().__init__(name, parent)\n      \n      \n      \n  Building context for related symbols -\n  \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.core.symbol.symbol_types.SymbolFile\n    \n        `SymbolFile` is a class used to represent files containing symbols, typically within the `SymbolGraph`. It provides methods for equality checks and hashing operations but does not include methods for modifying the file or accessing the symbol within. You can use the `SymbolFile` class to create instances of files containing symbols and compare them as shown in the following example:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolFile\n        \n        file_1 = SymbolFile(\"path/to/symbol/file\")\n        file_2 = SymbolFile(\"path/to/symbol/file\")\n        \n        # Comparing SymbolFile instances\n        assert file_1 == file_2\n        \n        # Comparing SymbolFile instance with a string representing the path\n        assert file_1 == \"path/to/symbol/file\"\n        ```\n        To access the symbol within a `SymbolFile` instance, you may need to use related symbol classes.\n        \n      Class Docstring:\n        Represents a file that contains a symbol\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.symbol.symbol_types.SymbolFile.__eq__\n    \n      Methods:\n        __eq__(self, other) -> None\n        \n    automata.tests.unit.test_symbol_graph.test_get_all_files\n    \n        def test_get_all_files(symbol_graph):\n            files = symbol_graph.get_all_files()\n            assert isinstance(files, list)\n            for f in files:\n                assert isinstance(f, SymbolFile)\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl\n    \n        class ObNMl:\n            \"\"\"zFsdXovhQSBlqDNpXSvl\"\"\"\n        \n            def __init__(self):\n                pass\n        \n            def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.SymbolReference\n    \n        `SymbolReference` is a class representing a reference to a symbol in a file, used for managing references to symbols within a codebase. It offers utility methods for comparing and hashing symbol references based on their URI, line number, and column number. In conjunction with other symbol-related classes, it helps track and manage references to symbols in files based on their location and usage. However, there is a potential limitation of causing collisions when the same symbol is referenced in different files at the same location (line and column). This is rare, but important to consider when working with multiple symbol references across files.\n        \n        Example usage: \n        ```python\n        from automata.core.symbol.symbol_types import SymbolReference\n        from automata.core.symbol.parser import parse_symbol\n        \n        symbol_uri = \"example_uri\"\n        line_number = 10\n        column_number = 5\n        symbol = parse_symbol(symbol_uri)\n        \n        symbol_ref1 = SymbolReference(symbol, line_number, column_number)\n        symbol_ref2 = SymbolReference(symbol, line_number + 1, column_number)\n        \n        assert symbol_ref1 != symbol_ref2\n        assert hash(symbol_ref1) != hash(symbol_ref2)\n        \n        symbol_ref3 = SymbolReference(symbol, line_number, column_number)\n        assert symbol_ref1 == symbol_ref3\n        ```\n        \n      Class Docstring:\n        Represents a reference to a symbol in a file\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n    automata.tests.unit.test_database_vector.test_init_vector\n    \n        def test_init_vector(temp_output_filename):\n            JSONVectorDatabase(temp_output_filename)\n        \n        \n        \n        \n    automata.core.symbol.graph.SymbolGraph\n    \n        The `SymbolGraph` class represents a symbol graph that captures relationships between symbols found in source code files and is built from an index protobuf file. Utilizing NetworkX's MultiDiGraph, `SymbolGraph` represents relationships as a directed graph and includes methods for querying relationships, obtaining all available symbols and files, and filtering to subgraphs of rankable symbols. A navigator interface, _SymbolGraphNavigator, is required for getting reachable objects in the symbol subgraph.\n        \n        Example usage:\n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        \n        # Replace with your own file path\n        index_path = \"path/to/index.scip\"\n        symbol_graph = SymbolGraph(index_path)\n        all_symbols = symbol_graph.get_all_available_symbols()\n        ```\n        \n        Limitations include only being built from index protobuf files and the `get_potential_symbol_callers` method requiring downstream filtering to remove non-call statements. Future improvements may address these limitations and better handle edge cases in the symbol graph building process.\n        \n      Methods:\n        def __init__(\n                self, index_path: str = DEFAULT_SCIP_PATH, build_caller_relationships: bool = False\n            ):\n                \"\"\"\n                Initializes SymbolGraph with the path of an index protobuf file.\n        \n                Args:\n                    index_path (str): Path to index protobuf file\n                Returns:\n                    SymbolGraph instance\n                \"\"\"\n                index = self._load_index_protobuf(index_path)\n                builder = GraphBuilder(index, build_caller_relationships)\n                self._graph = builder.build_graph()\n                self.navigator = _SymbolGraphNavigator(self._graph)\n        \n            \n        get_all_available_symbols(self) -> List[Symbol]\n        \n        get_all_files(self) -> List[SymbolFile]\n        \n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n        get_rankable_symbol_subgraph(self, flow_rank=\"bidirectional\", path_filter: Optional[str] = None) -> SubGraph\n        \n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n    automata.tests.unit.test_database_vector.test_save\n    \n        def test_save(temp_output_filename, symbols):\n            vector_db = JSONVectorDatabase(temp_output_filename)\n            embedded_symbol_0 = SymbolEmbedding(symbols[0], \"x\", [1, 2, 3])\n            vector_db.add(embedded_symbol_0)\n            embedded_symbol_1 = SymbolEmbedding(symbols[1], \"y\", [1, 2, 3, 4])\n            vector_db.add(embedded_symbol_1)\n            vector_db.save()\n        \n        \n        \n        \n  Building context for dependencies -\n  \n    automata.core.coding.directory.Node.__init__\n    \n      Class Docstring:\n        Args:\n        name (str): Name of the node\n        parent (Node): Parent node of this node\n        \n      Methods:\n        def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n                \"\"\"\n                Args:\n                    name (str): Name of the node\n                    parent (Node): Parent node of this node\n                \"\"\"\n                self.name = name\n                self.parent = parent\n        \n        \n        \n    automata.core.coding.directory.Node\n    \n        `Node` is an abstract base class within the `automata.core.coding.directory` package that represents a node in a file tree, with a `name` and a `parent` pointing to its parent in the tree hierarchy. Though not directly instantiated, the class serves as a superclass for `File` and `Directory` classes. To use these classes, create a root directory with subdirectories and files, add children to the directories as needed, and import the necessary classes from the package:\n        \n        ```python\n        from automata.core.coding.directory import File, Directory\n        \n        root = Directory(\"root\")\n        subdir1 = Directory(\"subdir1\", root)\n        subdir2 = Directory(\"subdir2\", root)\n        file1 = File(\"file1.txt\", root)\n        file2 = File(\"file2.txt\", root)\n        subdir1_file1 = File(\"file1.txt\", subdir1)\n        subdir1_file2 = File(\"file2.txt\", subdir1)\n        subdir2_file1 = File(\"file1.txt\", subdir2)\n        \n        root.add_child(subdir1)\n        root.add_child(subdir2)\n        root.add_child(file1)\n        root.add_child(file2)\n        subdir1.add_child(subdir1_file1)\n        subdir1.add_child(subdir1_file2)\n        subdir2.add_child(subdir2_file1)\n        ```\n        \n      Class Docstring:\n        Abstract base class for a node in the file tree\n        \n      Methods:\n        def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n                \"\"\"\n                Args:\n                    name (str): Name of the node\n                    parent (Node): Parent node of this node\n                \"\"\"\n                self.name = name\n                self.parent = parent\n        \n        \n        \n    automata.core.coding.directory.Directory\n    \n        The `Directory` class represents a directory containing files or other directories as children, providing methods to manage and interact with directory structures. It extends the abstract base class `Node` with functionality such as adding child nodes, getting file names, and subdirectories, and determining leaf or root directories. However, it does not offer advanced capabilities such as searching, moving, or renaming files and directories. The following example demonstrates creating a root directory, adding a child directory, and obtaining subdirectories:\n        \n        ```python\n        from automata.core.coding.directory import Directory\n        \n        # Create a sample root directory\n        root_dir = Directory(name=\"root\")\n        \n        # Create a sample child directory\n        child_dir = Directory(name=\"child\", parent=root_dir)\n        \n        # Add the child directory to the root directory\n        root_dir.add_child(child_dir)\n        \n        # Get the subdirectories of the root directory\n        subdirectories = root_dir.get_subdirectories()\n        print(subdirectories)  # Output: ['child']\n        ```\n        \n        \n      Class Docstring:\n        Represents a directory. Has children which can be directories or files\n        \n      Methods:\n        def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n                \"\"\"\n                Args:\n                    name (str): Name of the directory\n                    parent (Node): Parent node of this directory\n                \"\"\"\n                super().__init__(name, parent)\n                self.children: Dict[str, Node] = {}\n        \n            \n        add_child(self, child: \"Node\") -> None\n        \n        get_file_names(self) -> List[str]\n        \n        get_subdirectories(self) -> List[str]\n        \n        is_leaf_dir(self) -> bool\n        \n        is_root_dir(self) -> bool\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.coding.directory`/Node#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.coding.directory", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "Node", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# Node\n\n`Node` is an abstract base class representing a node in a file tree. It is part of the larger file management infrastructure in the `automata.core.coding.directory` package. The class includes a `name` to represent the name of the node and a `parent` to point to the parent node in the file tree hierarchy.\n\n## Related Symbols\n\n- `automata.core.coding.directory.File`\n- `automata.core.coding.directory.Directory`\n\n## Usage Example\n\nThe `Node` class is not directly instantiated but is a superclass for `File` and `Directory` classes. Here is an example of how to use the `File` and `Directory` classes representing files and directories in the file tree:\n\n```python\nfrom automata.core.coding.directory import File, Directory\n\n# Create a root directory and some subdirectories\nroot = Directory(\"root\")\nsubdir1 = Directory(\"subdir1\", root)\nsubdir2 = Directory(\"subdir2\", root)\n\n# Create some files in root directory\nfile1 = File(\"file1.txt\", root)\nfile2 = File(\"file2.txt\", root)\n\n# Create some files in subdirectories\nsubdir1_file1 = File(\"file1.txt\", subdir1)\nsubdir1_file2 = File(\"file2.txt\", subdir1)\nsubdir2_file1 = File(\"file1.txt\", subdir2)\n\n# Add files and subdirectories to root and subdirectories\nroot.add_child(subdir1)\nroot.add_child(subdir2)\nroot.add_child(file1)\nroot.add_child(file2)\nsubdir1.add_child(subdir1_file1)\nsubdir1.add_child(subdir1_file2)\nsubdir2.add_child(subdir2_file1)\n```\n\n## Follow-up Questions\n\n- In the usage example, the file names are given manually. Is there an automated mechanism to traverse directories and create `File` and `Directory` objects?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class Node:\n    \"\"\"Abstract base class for a node in the file tree\"\"\"\n\n    def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n        \"\"\"\n        Args:\n            name (str): Name of the node\n            parent (Node): Parent node of this node\n        \"\"\"\n        self.name = name\n        self.parent = parent\n\n\n", "summary": "The `Node` class serves as an abstract base class for nodes in a file tree and is a part of the `automata.core.coding.directory` package. It contains a `name` and a `parent` to define the node's hierarchy. The `Node` class is not directly instantiated but used as a superclass for `File` and `Directory` classes. You can create and manage files and directories using these classes, as demonstrated in the provided example. However, the example does not show an automated mechanism for traversing directories and creating `File` and `Directory` objects.", "context": "\n    Generate the documentation for Node using the context shown below -\n  Building context for primary symbol - automata.core.coding.directory.Node -\n  \n    Import Statements:\n      import logging\n      import os\n      from typing import Dict, List, Optional\n      \n      # Node\n      \n      `Node` is an abstract base class representing a node in a file tree. It is part of the larger file management infrastructure in the `automata.core.coding.directory` package. The class includes a `name` to represent the name of the node and a `parent` to point to the parent node in the file tree hierarchy.\n      \n      ## Related Symbols:\n      \n      - `automata.core.coding.directory.File`\n      - `automata.core.coding.directory.Directory`\n      \n      ## Usage Example:\n      \n      The `Node` class is not directly instantiated but is a superclass for `File` and `Directory` classes. Here is an example of how to use the `File` and `Directory` classes representing files and directories in the file tree:\n      \n      ```python\n      from automata.core.coding.directory import File, Directory\n      \n      # Create a root directory and some subdirectories\n      root = Directory(\"root\")\n      subdir1 = Directory(\"subdir1\", root)\n      subdir2 = Directory(\"subdir2\", root)\n      \n      # Create some files in root directory\n      file1 = File(\"file1.txt\", root)\n      file2 = File(\"file2.txt\", root)\n      \n      # Create some files in subdirectories\n      subdir1_file1 = File(\"file1.txt\", subdir1)\n      subdir1_file2 = File(\"file2.txt\", subdir1)\n      subdir2_file1 = File(\"file1.txt\", subdir2)\n      \n      # Add files and subdirectories to root and subdirectories\n      root.add_child(subdir1)\n      root.add_child(subdir2)\n      root.add_child(file1)\n      root.add_child(file2)\n      subdir1.add_child(subdir1_file1)\n      subdir1.add_child(subdir1_file2)\n      subdir2.add_child(subdir2_file1)\n      ```\n      \n      ## Follow-up Questions:\n      \n      - In the usage example, the file names are given manually. Is there an automated mechanism to traverse directories and create `File` and `Directory` objects?\n      \n      \n    Class Docstring:\n      Abstract base class for a node in the file tree\n      \n    Methods:\n      def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n              \"\"\"\n              Args:\n                  name (str): Name of the node\n                  parent (Node): Parent node of this node\n              \"\"\"\n              self.name = name\n              self.parent = parent\n      \n      \n      \n  Building context for related symbols -\n  \n    automata.core.coding.directory.Directory\n    \n        The `Directory` class represents a directory containing files or other directories as children, providing methods to manage and interact with directory structures. It extends the abstract base class `Node` with functionality such as adding child nodes, getting file names, and subdirectories, and determining leaf or root directories. However, it does not offer advanced capabilities such as searching, moving, or renaming files and directories. The following example demonstrates creating a root directory, adding a child directory, and obtaining subdirectories:\n        \n        ```python\n        from automata.core.coding.directory import Directory\n        \n        # Create a sample root directory\n        root_dir = Directory(name=\"root\")\n        \n        # Create a sample child directory\n        child_dir = Directory(name=\"child\", parent=root_dir)\n        \n        # Add the child directory to the root directory\n        root_dir.add_child(child_dir)\n        \n        # Get the subdirectories of the root directory\n        subdirectories = root_dir.get_subdirectories()\n        print(subdirectories)  # Output: ['child']\n        ```\n        \n        \n      Class Docstring:\n        Represents a directory. Has children which can be directories or files\n        \n      Methods:\n        def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n                \"\"\"\n                Args:\n                    name (str): Name of the directory\n                    parent (Node): Parent node of this directory\n                \"\"\"\n                super().__init__(name, parent)\n                self.children: Dict[str, Node] = {}\n        \n            \n        add_child(self, child: \"Node\") -> None\n        \n        get_file_names(self) -> List[str]\n        \n        get_subdirectories(self) -> List[str]\n        \n        is_leaf_dir(self) -> bool\n        \n        is_root_dir(self) -> bool\n        \n    automata.core.coding.directory.File\n    \n        The `File` class represents a file in a file tree, including its name and parent node, and is useful for managing, navigating or analyzing directory structures. It inherits from the abstract base class `Node` but does not provide built-in functionality for reading/writing contents, modifying attributes, or traversing the file tree. Additional functionality or Python libraries may be needed for these operations. Here's an example of creating an instance of `File`:\n        \n        ```python\n        from automata.core.coding.directory import File\n        \n        file_name = \"example.txt\"\n        parent_node = None\n        \n        new_file = File(file_name, parent_node)\n        ```\n        \n      Class Docstring:\n        Represents a file in the tree\n        \n      Methods:\n        def __init__(self, name: str, parent: Optional[\"Node\"] = None):\n                \"\"\"\n                Args:\n                    name (str): Name of the file\n                    parent (Node): Parent node of this file\n                \"\"\"\n                super().__init__(name, parent)\n        \n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl\n    \n        class ObNMl:\n            \"\"\"zFsdXovhQSBlqDNpXSvl\"\"\"\n        \n            def __init__(self):\n                pass\n        \n            def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.coding.py_coding.writer.PyCodeWriter\n    \n        PyCodeWriter is a utility class designed for writing and updating Python code in the Abstract Syntax Tree (AST) format, enabling programmatic manipulation of Python elements such as classes, functions, and imports. The main functionality includes initializing with a PyCodeRetriever instance, creating a new module object from source code, updating an existing module, and writing the updated module to disk. However, PyCodeWriter's primary limitation is its reliance on RedBaron, which has known limitations and bugs, along with relatively low support in recent years. Additionally, error reporting in PyCodeWriter can be improved for a better user experience. \n        \n        ```python\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        from automata.core.coding.py_coding.writer import PyCodeWriter\n        \n        # Initialize the PyCodeWriter with a PyCodeRetriever instance\n        retriever = PyCodeRetriever()\n        writer = PyCodeWriter(retriever)\n        \n        # Create a new module object from source code\n        module_dotpath = \"my_module\"\n        source_code = \"def hello():\\n    print('Hello, World!')\\n\"\n        writer.create_new_module(module_dotpath, source_code)\n        \n        # Update the existing module by adding a new function\n        new_function_code = \"def goodbye():\\n    print('Goodbye, World!')\\n\"\n        writer.update_existing_module(module_dotpath, new_function_code, do_write=True)\n        ```\n        \n      Class Docstring:\n        A utility class for writing Python code along AST nodes\n        \n      Methods:\n        def __init__(self, python_retriever: PyCodeRetriever):\n                \"\"\"\n                Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n                Args:\n                    python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n                \"\"\"\n                self.code_retriever = python_retriever\n        \n            \n        create_new_module(self, module_dotpath: str, source_code: str, do_write: bool = False) -> None\n        \n        delete_from_existing__module(self, module_dotpath: str, object_dotpath: str, do_write: bool = False) -> None\n        \n        replace(match) -> None\n        \n        replace_newline_chars(input_str: str) -> str\n        \n        update_existing_module(self,\n                module_dotpath: str,\n                source_code: str,\n                disambiguator: Optional[str] = \"\",\n                do_write: bool = False,\n            ) -> None\n        \n    automata.tests.unit.sample_modules.sample.EmptyClass\n    \n        class EmptyClass:\n            pass\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.tests.unit.test_directory_manager.test_get_node_for_path\n    \n        def test_get_node_for_path(tmp_path):\n            test_dir = create_test_dir_structure(tmp_path)\n            dir_manager = DirectoryManager(str(test_dir))\n            dir1_node = dir_manager._get_node_for_path(dir_manager.root, \"dir1\")\n            assert dir1_node is not None\n            assert dir1_node.name == \"dir1\"\n            assert len(dir1_node.children) == 2  # 2 files in dir1: file1, file2\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl.method\n    \n        def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample.OuterClass\n    \n        class OuterClass:\n            class InnerClass:\n                \"\"\"Inner doc strings\"\"\"\n        \n                def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.coding.py_coding.module_tree`/DotPathMap#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.coding.py_coding.module_tree", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "DotPathMap", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# DotPathMap\n\n`DotPathMap` is a class that maps module dotpaths to module filepaths. It provides an easy way to access module dotpaths programmatically, which is useful when working with Python codebases. The class offers various utility methods like `contains_dotpath`, `contains_fpath`, `get_module_dotpath_by_fpath`, `get_module_fpath_by_dotpath`, and `put_module`.\n\n## Overview\n\n`DotPathMap` is initialized with an absolute path to the root of the module tree. The class provides methods to check if the map contains a particular module dotpath or filepath, get the corresponding dotpath for a given module filepath and vice versa, and put a module with a given dotpath into the map.\n\n## Related Symbols\n\n- `automata.core.coding.py_coding.module_tree.LazyModuleTreeMap`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.database.vector.JSONVectorDatabase`\n- `automata.core.symbol.graph.SymbolGraph`\n\n## Example\n\nHere's an example of utilizing `DotPathMap`:\n\n```python\nfrom automata.core.coding.py_coding.module_tree import DotPathMap\n\n# Set the path to the root of the Python project\npath_to_project_root = \"/path/to/python/project\"\n\n# Initialize the DotPathMap\ndotpath_map = DotPathMap(path_to_project_root)\n\n# Check if the dotpath_map contains a given dotpath and filepath\ncontains_dotpath = dotpath_map.contains_dotpath(\"module.dotpath.example\")\ncontains_fpath = dotpath_map.contains_fpath(\"/path/to/python/module/example.py\")\n\n# Get the dotpath of a module given its filepath\ndotpath = dotpath_map.get_module_dotpath_by_fpath(\"/path/to/python/module/example.py\")\n\n# Get the filepath of a module given its dotpath\nfpath = dotpath_map.get_module_fpath_by_dotpath(\"module.dotpath.example\")\n\n# Put a module with the given dotpath in the map\ndotpath_map.put_module(\"module.dotpath.example\")\n```\n\n## Limitations\n\nThe primary limitation of `DotPathMap` is that it only supports Python projects with a specific directory structure and does not handle cases where the project has a different structure, such as virtual environments or nested packages.\n\n## Follow-up Questions:\n\n- How can `DotPathMap` be extended to support more complex project structures?\n- Can `DotPathMap` be easily integrated with other build systems, like `setuptools` or `pip`, to handle package installations?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class DotPathMap:\n    \"\"\"A map from module dotpaths to module filepaths\"\"\"\n\n    def __init__(self, path: str):\n        \"\"\"\n        Args:\n            path: The absolute path to the root of the module tree\n        \"\"\"\n        if not os.path.isabs(path):\n            path = os.path.join(root_fpath(), path)\n        self._abs_path = path\n        self._module_dotpath_to_fpath_map = self._build_module_dotpath_to_fpath_map()\n        self._module_fpath_to_dotpath_map = {\n            v: k for k, v in self._module_dotpath_to_fpath_map.items()\n        }\n\n    def _build_module_dotpath_to_fpath_map(self) -> Dict[str, str]:\n        \"\"\"\n        Builds a map from module dotpaths to module filepaths\n\n        Returns:\n            The map from module dotpaths to module filepaths\n        \"\"\"\n        module_dotpath_to_fpath_map = {}\n        for root, _, files in os.walk(self._abs_path):\n            for file in files:\n                if file.endswith(\".py\"):\n                    module_fpath = os.path.join(root, file)\n                    module_dotpath = convert_fpath_to_module_dotpath(self._abs_path, module_fpath)\n                    module_dotpath_to_fpath_map[module_dotpath] = module_fpath\n        return module_dotpath_to_fpath_map\n\n    def get_module_fpath_by_dotpath(self, module_dotpath: str) -> str:\n        \"\"\"\n        Gets the filepath of a module given its dotpath\n\n        Args:\n            module_dotpath: The dotpath of the module\n\n        Returns:\n            The filepath of the module\n        \"\"\"\n        return self._module_dotpath_to_fpath_map[module_dotpath]\n\n    def get_module_dotpath_by_fpath(self, module_fpath: str) -> str:\n        \"\"\"\n        Gets the dotpath of a module given its filepath\n\n        Args:\n            module_fpath: The filepath of the module\n\n        Returns:\n            The dotpath of the module\n        \"\"\"\n        return self._module_fpath_to_dotpath_map[module_fpath]\n\n    def contains_dotpath(self, module_dotpath: str) -> bool:\n        \"\"\"\n        Checks if the map contains a module with the given dotpath\n\n        Args:\n            module_dotpath: The dotpath of the module\n\n        Returns:\n            True if the map contains the module, False otherwise\n        \"\"\"\n        return module_dotpath in self._module_dotpath_to_fpath_map\n\n    def contains_fpath(self, module_fpath: str) -> bool:\n        \"\"\"\n        Checks if the map contains a module with the given filepath\n\n        Args:\n            module_fpath: The filepath of the module\n\n        Returns:\n            True if the map contains the module, False otherwise\n        \"\"\"\n        return module_fpath in self._module_fpath_to_dotpath_map\n\n    def put_module(self, module_dotpath: str):\n        \"\"\"\n        Puts a module with the given dotpath in the map\n\n        Args:\n            module_dotpath: The dotpath of the module\n        \"\"\"\n        if not self.contains_dotpath(module_dotpath):\n            module_os_rel_path = module_dotpath.replace(DOT_SEP, os.path.sep)\n            module_os_abs_path = os.path.join(self._abs_path, module_os_rel_path)\n            os.makedirs(os.path.dirname(module_os_abs_path), exist_ok=True)\n            file_path = f\"{module_os_abs_path}.py\"\n            self._module_dotpath_to_fpath_map[module_dotpath] = file_path\n            self._module_fpath_to_dotpath_map[file_path] = module_dotpath\n\n    def items(self) -> Iterable[Tuple[str, str]]:\n        \"\"\"\n        Returns:\n            A dictionary containing the module dotpath to module filepath mapping\n        \"\"\"\n        return self._module_dotpath_to_fpath_map.items()\n\n\n", "summary": "DotPathMap is a class used for mapping module dotpaths to module filepaths in Python projects. It is initialized with an absolute path to the root of the module tree and offers utility methods to check for the existence of a module dotpath or filepath, retrieve the corresponding dotpath or filepath, and add a module with a given dotpath to the map. One limitation of DotPathMap is that it only supports Python projects with specific directory structures and does not handle cases with virtual environments or nested packages.\n\nExample usage:\n\n```python\nfrom automata.core.coding.py_coding.module_tree import DotPathMap\n\npath_to_project_root = \"/path/to/python/project\"\ndotpath_map = DotPathMap(path_to_project_root)\ncontains_dotpath = dotpath_map.contains_dotpath(\"module.dotpath.example\")\ncontains_fpath = dotpath_map.contains_fpath(\"/path/to/python/module/example.py\")\ndotpath = dotpath_map.get_module_dotpath_by_fpath(\"/path/to/python/module/example.py\")\nfpath = dotpath_map.get_module_fpath_by_dotpath(\"module.dotpath.example\")\ndotpath_map.put_module(\"module.dotpath.example\")\n```\nFollow-up questions include exploring how DotPathMap can be extended to support complex project structures and if it can be integrated with other build systems like setuptools or pip.", "context": "\n    Generate the documentation for DotPathMap using the context shown below -\n  Building context for primary symbol - automata.core.coding.py_coding.module_tree.DotPathMap -\n  \n    Import Statements:\n      import logging\n      import os.path\n      from functools import lru_cache\n      from typing import Dict, Iterable, Optional, Tuple\n      from redbaron import RedBaron\n      from automata.core.coding.py_coding.py_utils import DOT_SEP, convert_fpath_to_module_dotpath\n      from automata.core.utils import root_fpath\n      \n      # DotPathMap\n      \n      `DotPathMap` is a class that maps module dotpaths to module filepaths. It provides an easy way to access module dotpaths programmatically, which is useful when working with Python codebases. The class offers various utility methods like `contains_dotpath`, `contains_fpath`, `get_module_dotpath_by_fpath`, `get_module_fpath_by_dotpath`, and `put_module`.\n      \n      ## Overview\n      \n      `DotPathMap` is initialized with an absolute path to the root of the module tree. The class provides methods to check if the map contains a particular module dotpath or filepath, get the corresponding dotpath for a given module filepath and vice versa, and put a module with a given dotpath into the map. \n      \n      ## Related Symbols\n      \n      - `automata.core.coding.py_coding.module_tree.LazyModuleTreeMap`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.database.vector.JSONVectorDatabase`\n      - `automata.core.symbol.graph.SymbolGraph`\n      \n      ## Example\n      \n      Here's an example of utilizing `DotPathMap`:\n      \n      ```python\n      from automata.core.coding.py_coding.module_tree import DotPathMap\n      \n      # Set the path to the root of the Python project\n      path_to_project_root = \"/path/to/python/project\"\n      \n      # Initialize the DotPathMap\n      dotpath_map = DotPathMap(path_to_project_root)\n      \n      # Check if the dotpath_map contains a given dotpath and filepath\n      contains_dotpath = dotpath_map.contains_dotpath(\"module.dotpath.example\")\n      contains_fpath = dotpath_map.contains_fpath(\"/path/to/python/module/example.py\")\n      \n      # Get the dotpath of a module given its filepath\n      dotpath = dotpath_map.get_module_dotpath_by_fpath(\"/path/to/python/module/example.py\")\n      \n      # Get the filepath of a module given its dotpath\n      fpath = dotpath_map.get_module_fpath_by_dotpath(\"module.dotpath.example\")\n      \n      # Put a module with the given dotpath in the map\n      dotpath_map.put_module(\"module.dotpath.example\")\n      ```\n      \n      ## Limitations\n      \n      The primary limitation of `DotPathMap` is that it only supports Python projects with a specific directory structure and does not handle cases where the project has a different structure, such as virtual environments or nested packages.\n      \n      ## Follow-up Questions:\n      \n      - How can `DotPathMap` be extended to support more complex project structures?\n      - Can `DotPathMap` be easily integrated with other build systems, like `setuptools` or `pip`, to handle package installations?\n      \n    Class Docstring:\n      A map from module dotpaths to module filepaths\n      \n    Methods:\n      def __init__(self, path: str):\n              \"\"\"\n              Args:\n                  path: The absolute path to the root of the module tree\n              \"\"\"\n              if not os.path.isabs(path):\n                  path = os.path.join(root_fpath(), path)\n              self._abs_path = path\n              self._module_dotpath_to_fpath_map = self._build_module_dotpath_to_fpath_map()\n              self._module_fpath_to_dotpath_map = {\n                  v: k for k, v in self._module_dotpath_to_fpath_map.items()\n              }\n      \n          \n      def contains_dotpath(self, module_dotpath: str) -> bool:\n              \"\"\"\n              Checks if the map contains a module with the given dotpath\n      \n              Args:\n                  module_dotpath: The dotpath of the module\n      \n              Returns:\n                  True if the map contains the module, False otherwise\n              \"\"\"\n              return module_dotpath in self._module_dotpath_to_fpath_map\n      \n          \n      def contains_fpath(self, module_fpath: str) -> bool:\n              \"\"\"\n              Checks if the map contains a module with the given filepath\n      \n              Args:\n                  module_fpath: The filepath of the module\n      \n              Returns:\n                  True if the map contains the module, False otherwise\n              \"\"\"\n              return module_fpath in self._module_fpath_to_dotpath_map\n      \n          \n      def get_module_dotpath_by_fpath(self, module_fpath: str) -> str:\n              \"\"\"\n              Gets the dotpath of a module given its filepath\n      \n              Args:\n                  module_fpath: The filepath of the module\n      \n              Returns:\n                  The dotpath of the module\n              \"\"\"\n              return self._module_fpath_to_dotpath_map[module_fpath]\n      \n          \n      def get_module_fpath_by_dotpath(self, module_dotpath: str) -> str:\n              \"\"\"\n              Gets the filepath of a module given its dotpath\n      \n              Args:\n                  module_dotpath: The dotpath of the module\n      \n              Returns:\n                  The filepath of the module\n              \"\"\"\n              return self._module_dotpath_to_fpath_map[module_dotpath]\n      \n          \n      def items(self) -> Iterable[Tuple[str, str]]:\n              \"\"\"\n              Returns:\n                  A dictionary containing the module dotpath to module filepath mapping\n              \"\"\"\n              return self._module_dotpath_to_fpath_map.items()\n      \n      \n      \n      def put_module(self, module_dotpath: str):\n              \"\"\"\n              Puts a module with the given dotpath in the map\n      \n              Args:\n                  module_dotpath: The dotpath of the module\n              \"\"\"\n              if not self.contains_dotpath(module_dotpath):\n                  module_os_rel_path = module_dotpath.replace(DOT_SEP, os.path.sep)\n                  module_os_abs_path = os.path.join(self._abs_path, module_os_rel_path)\n                  os.makedirs(os.path.dirname(module_os_abs_path), exist_ok=True)\n                  file_path = f\"{module_os_abs_path}.py\"\n                  self._module_dotpath_to_fpath_map[module_dotpath] = file_path\n                  self._module_fpath_to_dotpath_map[file_path] = module_dotpath\n      \n          \n  Building context for related symbols -\n  \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap\n    \n        The `LazyModuleTreeMap` class is a lazy dictionary that maps module dotpaths to their corresponding RedBaron FST objects, loading and caching the modules in memory as they are accessed. It provides methods for fetching existing module dotpaths and filepaths, as well as fetching, putting, and updating modules by their dotpaths. However, it assumes a specific directory structure according to the `DotPathMap` class and does not support custom directory structures for modules.\n        \n        ```python\n        from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n        from automata.core.utils import root_fpath\n        \n        path_to_root = root_fpath()\n        module_tree_map = LazyModuleTreeMap(path_to_root)\n        \n        # Fetch an existing module by its dotpath\n        module_dotpath = \"automata.core.agent.automata_agent\"\n        module = module_tree_map.fetch_module(module_dotpath)\n        \n        # Check if a module with the given dotpath exists\n        exists = module_dotpath in module_tree_map\n        ```\n        \n      Class Docstring:\n        A lazy dictionary between module dotpaths and their corresponding RedBaron FST objects.\n        Loads and caches modules in memory as they are accessed\n        \n      Methods:\n        __contains__(self, dotpath) -> None\n        \n        def __init__(self, path: str):\n                \"\"\"\n                Args:\n                    path: The absolute path to the root of the module tree\n                \"\"\"\n                self._dotpath_map = DotPathMap(path)\n                self._loaded_modules: Dict[str, Optional[RedBaron]] = {}\n        \n            \n        cached_default(cls) -> \"LazyModuleTreeMap\"\n        \n        fetch_existing_module_dotpath(self, module_obj: RedBaron) -> Optional[str]\n        \n        fetch_existing_module_fpath_by_dotpath(self, module_dotpath: str) -> Optional[str]\n        \n        fetch_module(self, module_dotpath: str) -> Optional[RedBaron]\n        \n        get_module_dotpath_by_fpath(self, module_fpath: str) -> str\n        \n        items(self) -> Iterable[Tuple[str, Optional[RedBaron]]]\n        \n        put_module(self, module_dotpath: str, module: RedBaron) -> None\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.core.symbol.graph.SymbolGraph\n    \n        The `SymbolGraph` class represents a symbol graph that captures relationships between symbols found in source code files and is built from an index protobuf file. Utilizing NetworkX's MultiDiGraph, `SymbolGraph` represents relationships as a directed graph and includes methods for querying relationships, obtaining all available symbols and files, and filtering to subgraphs of rankable symbols. A navigator interface, _SymbolGraphNavigator, is required for getting reachable objects in the symbol subgraph.\n        \n        Example usage:\n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        \n        # Replace with your own file path\n        index_path = \"path/to/index.scip\"\n        symbol_graph = SymbolGraph(index_path)\n        all_symbols = symbol_graph.get_all_available_symbols()\n        ```\n        \n        Limitations include only being built from index protobuf files and the `get_potential_symbol_callers` method requiring downstream filtering to remove non-call statements. Future improvements may address these limitations and better handle edge cases in the symbol graph building process.\n        \n      Methods:\n        def __init__(\n                self, index_path: str = DEFAULT_SCIP_PATH, build_caller_relationships: bool = False\n            ):\n                \"\"\"\n                Initializes SymbolGraph with the path of an index protobuf file.\n        \n                Args:\n                    index_path (str): Path to index protobuf file\n                Returns:\n                    SymbolGraph instance\n                \"\"\"\n                index = self._load_index_protobuf(index_path)\n                builder = GraphBuilder(index, build_caller_relationships)\n                self._graph = builder.build_graph()\n                self.navigator = _SymbolGraphNavigator(self._graph)\n        \n            \n        get_all_available_symbols(self) -> List[Symbol]\n        \n        get_all_files(self) -> List[SymbolFile]\n        \n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n        get_rankable_symbol_subgraph(self, flow_rank=\"bidirectional\", path_filter: Optional[str] = None) -> SubGraph\n        \n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap.__contains__\n    \n      Class Docstring:\n        Checks if the map contains a module with the given dotpath\n        \n        Args:\n        dotpath: The dotpath of the module\n        \n      Methods:\n        __contains__(self, dotpath) -> None\n        \n    automata.tests.unit.test_py_code_retriever.module_map\n    \n        @pytest.fixture\n        def module_map():\n            # get latest path\n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            # Set the root directory to the folder containing test modules\n            return LazyModuleTreeMap(sample_dir)\n        \n        \n        \n        \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap.put_module\n    \n      Class Docstring:\n        Put a module with the given dotpath in the map\n        \n        Args:\n        module_dotpath: The dotpath of the module\n        module: The module to put in the map\n        \n      Methods:\n        put_module(self, module_dotpath: str, module: RedBaron) -> None\n        \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap.cached_default\n    \n      Class Docstring:\n        Creates a new LazyModuleTreeMap instance with the default root path\n        \n      Methods:\n        cached_default(cls) -> \"LazyModuleTreeMap\"\n        \n    automata.tests.unit.test_directory_manager.test_get_node_for_path\n    \n        def test_get_node_for_path(tmp_path):\n            test_dir = create_test_dir_structure(tmp_path)\n            dir_manager = DirectoryManager(str(test_dir))\n            dir1_node = dir_manager._get_node_for_path(dir_manager.root, \"dir1\")\n            assert dir1_node is not None\n            assert dir1_node.name == \"dir1\"\n            assert len(dir1_node.children) == 2  # 2 files in dir1: file1, file2\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.SymbolFile\n    \n        `SymbolFile` is a class used to represent files containing symbols, typically within the `SymbolGraph`. It provides methods for equality checks and hashing operations but does not include methods for modifying the file or accessing the symbol within. You can use the `SymbolFile` class to create instances of files containing symbols and compare them as shown in the following example:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolFile\n        \n        file_1 = SymbolFile(\"path/to/symbol/file\")\n        file_2 = SymbolFile(\"path/to/symbol/file\")\n        \n        # Comparing SymbolFile instances\n        assert file_1 == file_2\n        \n        # Comparing SymbolFile instance with a string representing the path\n        assert file_1 == \"path/to/symbol/file\"\n        ```\n        To access the symbol within a `SymbolFile` instance, you may need to use related symbol classes.\n        \n      Class Docstring:\n        Represents a file that contains a symbol\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n  Building context for dependencies -\n  \n    automata.core.coding.py_coding.py_utils.convert_fpath_to_module_dotpath\n    \n      Class Docstring:\n        Converts a filepath to a module dotpath\n        \n        Args:\n        root_abs_path: The absolute path of the root directory\n        module_path: The path of the module\n        \n        Returns:\n        The dotpath of the module\n        \n      Methods:\n        convert_fpath_to_module_dotpath(root_abs_path: str, module_path: str) -> str\n        \n    automata.core.utils.root_fpath\n    \n      Class Docstring:\n        Returns the path to the root of the project directory.\n        \n        Returns:\n        str - A fpath object in string form\n        \n      Methods:\n        root_fpath() -> str\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.coding.py_coding.module_tree`/LazyModuleTreeMap#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.coding.py_coding.module_tree", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "LazyModuleTreeMap", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# LazyModuleTreeMap\n\n## Overview\n\n`LazyModuleTreeMap` is a class that represents a lazy dictionary that maps module dotpaths to their corresponding RedBaron FST objects. It loads and caches the modules in memory as they are accessed. The class provides methods for fetching existing module dotpaths and filepaths, as well as for fetching, putting, and updating modules by their dotpaths.\n\n## Related Symbols\n\n- `automata.core.coding.py_coding.retriever.PyCodeRetriever.__init__`\n- `automata.core.symbol.symbol_utils.convert_to_fst_object`\n\n## Usage Example\n\n```python\nfrom automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\nfrom automata.core.utils import root_fpath\n\npath_to_root = root_fpath()\nmodule_tree_map = LazyModuleTreeMap(path_to_root)\n\n# Fetch an existing module by its dotpath\nmodule_dotpath = \"automata.core.agent.automata_agent\"\nmodule = module_tree_map.fetch_module(module_dotpath)\n\n# Check if a module with the given dotpath exists\nexists = module_dotpath in module_tree_map\n```\n\n## Limitations\n\n`LazyModuleTreeMap` assumes a specific directory structure for the modules, according to the `DotPathMap` class. Custom directory structures for modules are not supported.\n\n## Follow-up Questions:\n\n- How can we adapt `LazyModuleTreeMap` to support custom directory structures for the modules?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class LazyModuleTreeMap:\n    \"\"\"\n    A lazy dictionary between module dotpaths and their corresponding RedBaron FST objects.\n    Loads and caches modules in memory as they are accessed\n    \"\"\"\n\n    def __init__(self, path: str):\n        \"\"\"\n        Args:\n            path: The absolute path to the root of the module tree\n        \"\"\"\n        self._dotpath_map = DotPathMap(path)\n        self._loaded_modules: Dict[str, Optional[RedBaron]] = {}\n\n    def __contains__(self, dotpath):\n        \"\"\"\n        Checks if the map contains a module with the given dotpath\n\n        Args:\n            dotpath: The dotpath of the module\n        \"\"\"\n        return self._dotpath_map.contains_dotpath(dotpath)\n\n    def items(self) -> Iterable[Tuple[str, Optional[RedBaron]]]:\n        \"\"\"\n        Returns:\n            A dictionary containing the module dotpath to module RedBaron FST object mapping\n        \"\"\"\n        self._load_all_modules()\n        return self._loaded_modules.items()\n\n    def fetch_module(self, module_dotpath: str) -> Optional[RedBaron]:\n        \"\"\"\n        Gets the module with the given dotpath\n\n        Args:\n            module_dotpath: The dotpath of the module\n\n        Returns:\n            Optional[RedBaron]: The module with the given dotpath if found, None otherwise\n        \"\"\"\n        if not self._dotpath_map.contains_dotpath(module_dotpath):\n            return None\n\n        if module_dotpath not in self._loaded_modules:\n            module_fpath = self._dotpath_map.get_module_fpath_by_dotpath(module_dotpath)\n            self._loaded_modules[module_dotpath] = self._load_module_from_fpath(module_fpath)\n        return self._loaded_modules[module_dotpath]\n\n    def fetch_existing_module_dotpath(self, module_obj: RedBaron) -> Optional[str]:\n        \"\"\"\n        Gets the module dotpath for the specified module object.\n\n        Args:\n            module_obj (Module): The module object.\n\n        Returns:\n            str: The module dotpath for the specified module object.\n        \"\"\"\n        # there is no way a module that has a redbaron object is not loaded\n        for module_dotpath, module in self._loaded_modules.items():\n            if module == module_obj:\n                return module_dotpath\n        return None\n\n    def fetch_existing_module_fpath_by_dotpath(self, module_dotpath: str) -> Optional[str]:\n        \"\"\"\n        Gets the module fpath for the specified module dotpath.\n\n        Args:\n            module_dotpath (str): The module dotpath.\n\n        Returns:\n            str: The module fpath for the specified module dotpath.\n        \"\"\"\n\n        if module_dotpath in self._loaded_modules:\n            return self._dotpath_map.get_module_fpath_by_dotpath(module_dotpath)\n        return None\n\n    def get_module_dotpath_by_fpath(self, module_fpath: str) -> str:\n        \"\"\"\n        Gets the module dotpath for the specified module fpath.\n\n        Args:\n            module_fpath (str): The module fpath.\n        \"\"\"\n        return self._dotpath_map.get_module_dotpath_by_fpath(module_fpath)\n\n    def put_module(self, module_dotpath: str, module: RedBaron):\n        \"\"\"\n        Put a module with the given dotpath in the map\n\n        Args:\n            module_dotpath: The dotpath of the module\n            module: The module to put in the map\n        \"\"\"\n        self._loaded_modules[module_dotpath] = module\n        self._dotpath_map.put_module(module_dotpath)\n\n    def _load_all_modules(self):\n        \"\"\"Loads all modules in the map\"\"\"\n        for module_dotpath, fpath in self._dotpath_map.items():\n            if module_dotpath not in self._loaded_modules:\n                self._loaded_modules[module_dotpath] = self._load_module_from_fpath(fpath)\n\n    @classmethod\n    @lru_cache(maxsize=1)\n    def cached_default(cls) -> \"LazyModuleTreeMap\":\n        \"\"\"Creates a new LazyModuleTreeMap instance with the default root path\"\"\"\n        return cls(root_fpath())\n\n    @staticmethod\n    def _load_module_from_fpath(path: str) -> Optional[RedBaron]:\n        \"\"\"\n        Loads and returns an FST object for the given file path.\n\n        Args:\n            path (str): The file path of the Python source code.\n\n        Returns:\n            Module: RedBaron FST object.\n        \"\"\"\n        try:\n            module = RedBaron(open(path).read())\n            return module\n        except Exception as e:\n            logger.error(f\"Failed to load module '{path}' due to: {e}\")\n            return None\n", "summary": "`LazyModuleTreeMap` is a class representing a lazy dictionary that maps module dotpaths to their corresponding RedBaron FST objects, loading and caching modules in memory as they are accessed. It provides methods for fetching, putting, and updating modules by their dotpaths, as well as checking if a module with a given dotpath exists. However, it assumes a specific directory structure for modules according to the `DotPathMap` class and does not support custom directory structures.\n\nExample usage:\n```python\nfrom automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\nfrom automata.core.utils import root_fpath\n\npath_to_root = root_fpath()\nmodule_tree_map = LazyModuleTreeMap(path_to_root)\nmodule_dotpath = \"automata.core.agent.automata_agent\"\nmodule = module_tree_map.fetch_module(module_dotpath)\nexists = module_dotpath in module_tree_map\n```", "context": "\n    Generate the documentation for LazyModuleTreeMap using the context shown below -\n  Building context for primary symbol - automata.core.coding.py_coding.module_tree.LazyModuleTreeMap -\n  \n    Import Statements:\n      import logging\n      import os.path\n      from functools import lru_cache\n      from typing import Dict, Iterable, Optional, Tuple\n      from redbaron import RedBaron\n      from automata.core.coding.py_coding.py_utils import DOT_SEP, convert_fpath_to_module_dotpath\n      from automata.core.utils import root_fpath\n      \n      # LazyModuleTreeMap\n      \n      ## Overview\n      \n      The `LazyModuleTreeMap` class represents a lazy dictionary that maps module dotpaths to their corresponding RedBaron FST objects. It loads and caches the modules in memory as they are accessed. The class also provides methods for fetching existing module dotpaths and filepaths, as well as for fetching, putting and updating the modules by their dotpaths.\n      \n      ## Related Symbols\n      \n      - `automata.core.coding.py_coding.retriever.PyCodeRetriever.__init__`\n      - `automata.tests.unit.test_py_code_retriever.module_map`\n      - `automata.tests.unit.test_py_code_retriever.getter`\n      - `automata.core.symbol.symbol_utils.convert_to_fst_object`\n      \n      ## Example\n      \n      The following example demonstrates how to create and use a `LazyModuleTreeMap`:\n      \n      ```python\n      from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n      from automata.core.utils import root_fpath\n      \n      path_to_root = root_fpath()\n      module_tree_map = LazyModuleTreeMap(path_to_root)\n      \n      # Fetch an existing module by its dotpath\n      module_dotpath = \"automata.core.agent.automata_agent\"\n      module = module_tree_map.fetch_module(module_dotpath)\n      \n      # Check if a module with the given dotpath exists\n      exists = module_dotpath in module_tree_map\n      ```\n      \n      ## Limitations\n      \n      `LazyModuleTreeMap` assumes a specific directory structure for the modules, according to the `DotPathMap` class. Custom directory structures for modules are not supported.\n      \n      ## Follow-up Questions:\n      \n      - How can we adapt `LazyModuleTreeMap` to support custom directory structures for the modules?\n      \n    Class Docstring:\n      A lazy dictionary between module dotpaths and their corresponding RedBaron FST objects.\n      Loads and caches modules in memory as they are accessed\n      \n    Methods:\n      def __contains__(self, dotpath):\n              \"\"\"\n              Checks if the map contains a module with the given dotpath\n      \n              Args:\n                  dotpath: The dotpath of the module\n              \"\"\"\n              return self._dotpath_map.contains_dotpath(dotpath)\n      \n          \n      def __init__(self, path: str):\n              \"\"\"\n              Args:\n                  path: The absolute path to the root of the module tree\n              \"\"\"\n              self._dotpath_map = DotPathMap(path)\n              self._loaded_modules: Dict[str, Optional[RedBaron]] = {}\n      \n          \n      @classmethod\n          @lru_cache(maxsize=1)\n          def cached_default(cls) -> \"LazyModuleTreeMap\":\n              \"\"\"Creates a new LazyModuleTreeMap instance with the default root path\"\"\"\n              return cls(root_fpath())\n      \n          \n      def fetch_existing_module_dotpath(self, module_obj: RedBaron) -> Optional[str]:\n              \"\"\"\n              Gets the module dotpath for the specified module object.\n      \n              Args:\n                  module_obj (Module): The module object.\n      \n              Returns:\n                  str: The module dotpath for the specified module object.\n              \"\"\"\n              # there is no way a module that has a redbaron object is not loaded\n              for module_dotpath, module in self._loaded_modules.items():\n                  if module == module_obj:\n                      return module_dotpath\n              return None\n      \n          \n      def fetch_existing_module_fpath_by_dotpath(self, module_dotpath: str) -> Optional[str]:\n              \"\"\"\n              Gets the module fpath for the specified module dotpath.\n      \n              Args:\n                  module_dotpath (str): The module dotpath.\n      \n              Returns:\n                  str: The module fpath for the specified module dotpath.\n              \"\"\"\n      \n              if module_dotpath in self._loaded_modules:\n                  return self._dotpath_map.get_module_fpath_by_dotpath(module_dotpath)\n              return None\n      \n          \n      def fetch_module(self, module_dotpath: str) -> Optional[RedBaron]:\n              \"\"\"\n              Gets the module with the given dotpath\n      \n              Args:\n                  module_dotpath: The dotpath of the module\n      \n              Returns:\n                  Optional[RedBaron]: The module with the given dotpath if found, None otherwise\n              \"\"\"\n              if not self._dotpath_map.contains_dotpath(module_dotpath):\n                  return None\n      \n              if module_dotpath not in self._loaded_modules:\n                  module_fpath = self._dotpath_map.get_module_fpath_by_dotpath(module_dotpath)\n                  self._loaded_modules[module_dotpath] = self._load_module_from_fpath(module_fpath)\n              return self._loaded_modules[module_dotpath]\n      \n          \n      def get_module_dotpath_by_fpath(self, module_fpath: str) -> str:\n              \"\"\"\n              Gets the module dotpath for the specified module fpath.\n      \n              Args:\n                  module_fpath (str): The module fpath.\n              \"\"\"\n              return self._dotpath_map.get_module_dotpath_by_fpath(module_fpath)\n      \n          \n      def items(self) -> Iterable[Tuple[str, Optional[RedBaron]]]:\n              \"\"\"\n              Returns:\n                  A dictionary containing the module dotpath to module RedBaron FST object mapping\n              \"\"\"\n              self._load_all_modules()\n              return self._loaded_modules.items()\n      \n          \n      def put_module(self, module_dotpath: str, module: RedBaron):\n              \"\"\"\n              Put a module with the given dotpath in the map\n      \n              Args:\n                  module_dotpath: The dotpath of the module\n                  module: The module to put in the map\n              \"\"\"\n              self._loaded_modules[module_dotpath] = module\n              self._dotpath_map.put_module(module_dotpath)\n      \n          \n  Building context for related symbols -\n  \n    automata.core.coding.py_coding.retriever.PyCodeRetriever.__init__\n    \n      Methods:\n        def __init__(self, module_tree_map: LazyModuleTreeMap = LazyModuleTreeMap.cached_default()):\n                self.module_tree_map = module_tree_map\n        \n            \n    automata.tests.unit.test_py_code_retriever.module_map\n    \n        @pytest.fixture\n        def module_map():\n            # get latest path\n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            # Set the root directory to the folder containing test modules\n            return LazyModuleTreeMap(sample_dir)\n        \n        \n        \n        \n    automata.tests.unit.test_py_code_retriever.getter\n    \n        @pytest.fixture\n        def getter(module_map):\n            return PyCodeRetriever(module_map)\n        \n        \n        \n        \n    automata.core.coding.py_coding.retriever.PyCodeRetriever\n    \n        `PyCodeRetriever` is a class designed to fetch Python code from a specified module, enabling the retrieval of source code, docstrings, and source code without docstrings for a given module, class, or function/method. Through methods like `get_docstring`, `get_source_code`, and `get_source_code_without_docstrings`, it offers a way to programmatically analyze, extract, and comprehend Python projects. However, this class assumes a specific directory structure for the modules and relies on the RedBaron library for parsing, which may have limitations when parsing complex or unconventional code patterns.\n        \n        An example usage of `PyCodeRetriever` for retrieving the source code of a function from a specified module is as follows:\n        \n        ```python\n        from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        \n        module_tree_map = LazyModuleTreeMap.cached_default()\n        code_retriever = PyCodeRetriever(module_tree_map)\n        \n        module_dotpath = \"mymodule.example\"\n        object_path = \"ExampleClass.example_function\"\n        \n        source_code = code_retriever.get_source_code(module_dotpath, object_path)\n        print(source_code)\n        ```\n        \n        \n      Class Docstring:\n        Code retriever for fetching python code\n        \n      Methods:\n        def __init__(self, module_tree_map: LazyModuleTreeMap = LazyModuleTreeMap.cached_default()):\n                self.module_tree_map = module_tree_map\n        \n            \n        get_docstring(self, module_dotpath: str, object_path: Optional[str]) -> str\n        \n        get_docstring_from_node(node: Optional[FSTNode]) -> str\n        \n        get_source_code(self, module_dotpath: str, object_path: Optional[str] = None) -> str\n        \n        get_source_code_without_docstrings(self, module_dotpath: str, object_path: Optional[str]\n            ) -> str\n        \n    automata.core.coding.py_coding.module_tree.DotPathMap\n    \n        DotPathMap is a class designed to map module dotpaths to module filepaths within Python codebases, allowing for easy programmatic access. The class is initialized with the absolute path to the root of the module tree and offers utility methods, such as checking if a dotpath or filepath are in the map, getting the corresponding dotpath for a given module filepath and vice versa, and adding a module with a specific dotpath to the map. However, DotPathMap has a limitation in that it solely supports Python projects with a specific directory structure and doesn't handle cases with different structures, such as virtual environments or nested packages.\n        \n      Class Docstring:\n        A map from module dotpaths to module filepaths\n        \n      Methods:\n        def __init__(self, path: str):\n                \"\"\"\n                Args:\n                    path: The absolute path to the root of the module tree\n                \"\"\"\n                if not os.path.isabs(path):\n                    path = os.path.join(root_fpath(), path)\n                self._abs_path = path\n                self._module_dotpath_to_fpath_map = self._build_module_dotpath_to_fpath_map()\n                self._module_fpath_to_dotpath_map = {\n                    v: k for k, v in self._module_dotpath_to_fpath_map.items()\n                }\n        \n            \n        contains_dotpath(self, module_dotpath: str) -> bool\n        \n        contains_fpath(self, module_fpath: str) -> bool\n        \n        get_module_dotpath_by_fpath(self, module_fpath: str) -> str\n        \n        get_module_fpath_by_dotpath(self, module_dotpath: str) -> str\n        \n        items(self) -> Iterable[Tuple[str, str]]\n        \n        put_module(self, module_dotpath: str) -> None\n        \n    automata.core.symbol.symbol_utils.convert_to_fst_object\n    \n      Class Docstring:\n        Converts a specified symbol into a red baron FST object\n        \n        Args:\n        symbol (str): The symbol which corresponds to a module, class, or method.\n        module_map (Optional[LazyModuleTreeMap]): The module tree mapping to use. If None, the default\n        \n        Returns:\n        Union[ClassNode, DefNode]: The RedBaron FST object for the class or method, or None if not found\n        \n        Raises:\n        ValueError: If the symbol is not found\n        \n        Note:\n        The optional argument is to allow us to run this function in mulitprocessing in the future,\n        because module map is not picklable (because redbaron objects are not picklable)\n        So the indexer would have to be created and destroyed in each process.\n        \n      Methods:\n        convert_to_fst_object(symbol: Symbol, module_map: Optional[LazyModuleTreeMap] = None) -> RedBaron\n        \n    automata.tests.unit.test_py_writer.python_writer\n    \n        @pytest.fixture\n        def python_writer():\n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            return PyCodeWriter(retriever)\n        \n        \n        \n        \n    automata.core.coding.py_coding.writer.PyCodeWriter\n    \n        PyCodeWriter is a utility class designed for writing and updating Python code in the Abstract Syntax Tree (AST) format, enabling programmatic manipulation of Python elements such as classes, functions, and imports. The main functionality includes initializing with a PyCodeRetriever instance, creating a new module object from source code, updating an existing module, and writing the updated module to disk. However, PyCodeWriter's primary limitation is its reliance on RedBaron, which has known limitations and bugs, along with relatively low support in recent years. Additionally, error reporting in PyCodeWriter can be improved for a better user experience. \n        \n        ```python\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        from automata.core.coding.py_coding.writer import PyCodeWriter\n        \n        # Initialize the PyCodeWriter with a PyCodeRetriever instance\n        retriever = PyCodeRetriever()\n        writer = PyCodeWriter(retriever)\n        \n        # Create a new module object from source code\n        module_dotpath = \"my_module\"\n        source_code = \"def hello():\\n    print('Hello, World!')\\n\"\n        writer.create_new_module(module_dotpath, source_code)\n        \n        # Update the existing module by adding a new function\n        new_function_code = \"def goodbye():\\n    print('Goodbye, World!')\\n\"\n        writer.update_existing_module(module_dotpath, new_function_code, do_write=True)\n        ```\n        \n      Class Docstring:\n        A utility class for writing Python code along AST nodes\n        \n      Methods:\n        def __init__(self, python_retriever: PyCodeRetriever):\n                \"\"\"\n                Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n                Args:\n                    python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n                \"\"\"\n                self.code_retriever = python_retriever\n        \n            \n        create_new_module(self, module_dotpath: str, source_code: str, do_write: bool = False) -> None\n        \n        delete_from_existing__module(self, module_dotpath: str, object_dotpath: str, do_write: bool = False) -> None\n        \n        replace(match) -> None\n        \n        replace_newline_chars(input_str: str) -> str\n        \n        update_existing_module(self,\n                module_dotpath: str,\n                source_code: str,\n                disambiguator: Optional[str] = \"\",\n                do_write: bool = False,\n            ) -> None\n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n  Building context for dependencies -\n  \n    automata.core.coding.py_coding.module_tree.DotPathMap.put_module\n    \n      Class Docstring:\n        Puts a module with the given dotpath in the map\n        \n        Args:\n        module_dotpath: The dotpath of the module\n        \n      Methods:\n        put_module(self, module_dotpath: str) -> None\n        \n    automata.core.coding.py_coding.module_tree.DotPathMap.get_module_dotpath_by_fpath\n    \n      Class Docstring:\n        Gets the dotpath of a module given its filepath\n        \n        Args:\n        module_fpath: The filepath of the module\n        \n        Returns:\n        The dotpath of the module\n        \n      Methods:\n        get_module_dotpath_by_fpath(self, module_fpath: str) -> str\n        \n    automata.core.coding.py_coding.module_tree.DotPathMap.items\n    \n      Class Docstring:\n        Returns:\n        A dictionary containing the module dotpath to module filepath mapping\n        \n      Methods:\n        items(self) -> Iterable[Tuple[str, str]]\n        \n    automata.core.utils.root_fpath\n    \n      Class Docstring:\n        Returns the path to the root of the project directory.\n        \n        Returns:\n        str - A fpath object in string form\n        \n      Methods:\n        root_fpath() -> str\n        \n    automata.core.coding.py_coding.module_tree.DotPathMap.contains_dotpath\n    \n      Class Docstring:\n        Checks if the map contains a module with the given dotpath\n        \n        Args:\n        module_dotpath: The dotpath of the module\n        \n        Returns:\n        True if the map contains the module, False otherwise\n        \n      Methods:\n        contains_dotpath(self, module_dotpath: str) -> bool\n        \n    automata.core.coding.py_coding.module_tree.DotPathMap.get_module_fpath_by_dotpath\n    \n      Class Docstring:\n        Gets the filepath of a module given its dotpath\n        \n        Args:\n        module_dotpath: The dotpath of the module\n        \n        Returns:\n        The filepath of the module\n        \n      Methods:\n        get_module_fpath_by_dotpath(self, module_dotpath: str) -> str\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.coding.py_coding.retriever`/PyCodeRetriever#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.coding.py_coding.retriever", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "PyCodeRetriever", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# PyCodeRetriever\n\n`PyCodeRetriever` is a class for fetching Python code from a given module. It can be used to retrieve the source code, docstrings, and source code without docstrings for a specified module, class, or function/method. With methods like `get_docstring`, `get_source_code`, and `get_source_code_without_docstrings`, it provides a way to programmatically analyze, extract, and understand Python projects.\n\n## Related Symbols\n\n- `automata.core.context.py_context.retriever.PyContextRetriever`\n- `automata.core.coding.py_coding.writer.PyCodeWriter`\n- `automata.tests.unit.test_py_code_retriever.getter`\n- `automata.core.coding.py_coding.navigation.find_syntax_tree_node`\n- `automata.tests.unit.test_py_writer.python_writer`\n\n## Example\n\nBelow is an example demonstrating the use of `PyCodeRetriever` to retrieve the source code of a function from a specified module.\n\n```python\nfrom automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\nfrom automata.core.coding.py_coding.retriever import PyCodeRetriever\n\nmodule_tree_map = LazyModuleTreeMap.cached_default()\ncode_retriever = PyCodeRetriever(module_tree_map)\n\nmodule_dotpath = \"mymodule.example\"\nobject_path = \"ExampleClass.example_function\"\n\nsource_code = code_retriever.get_source_code(module_dotpath, object_path)\nprint(source_code)\n```\n\n## Limitations\n\n`PyCodeRetriever` assumes the project's modules are organized in a specific directory structure, following Python's package and module organization. It may not work correctly if the project structure deviates from this pattern. Additionally, `PyCodeRetriever` relies on the RedBaron library for parsing the code, which may have limitations in parsing some complex or unconventional code patterns.\n\n## Follow-up Questions:\n\n- Can the class be extended to support other programming languages and code structures?\n- Are there alternative libraries or approaches that could be used for parsing Python code, instead of RedBaron?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class PyCodeRetriever:\n    \"\"\"Code retriever for fetching python code\"\"\"\n\n    def __init__(self, module_tree_map: LazyModuleTreeMap = LazyModuleTreeMap.cached_default()):\n        self.module_tree_map = module_tree_map\n\n    def get_source_code(self, module_dotpath: str, object_path: Optional[str] = None) -> str:\n        \"\"\"\n        Gets code for a specified module, class, or function/method\n\n        Args:\n            module_dotpath (str): The path of the module in dot-separated format (e.g. 'package.module')\n            object_path (Optional[str]): The path of the class, function, or method in dot-separated format\n                (e.g. 'ClassName.method_name'). If None, the entire module code will be returned\n\n        Returns:\n            str: The code for the specified module, class, or function/method, or \"No Result Found.\"\n                if not found\n        \"\"\"\n\n        module = self.module_tree_map.fetch_module(module_dotpath)\n        if module:\n            result = find_syntax_tree_node(module, object_path)\n            if result:\n                return result.dumps()\n\n        return NO_RESULT_FOUND_STR\n\n    def get_docstring(self, module_dotpath: str, object_path: Optional[str]) -> str:\n        \"\"\"\n        Gets the docstring for a specified module, class, or function/method\n\n        Args:\n            module_dotpath (str): The path of the module in dot-separated format (e.g. 'package.module')\n            object_path (Optional[str]): The path of the class, function, or method in dot-separated format\n                (e.g. 'ClassName.method_name'). If None, the module-level docstring will be returned\n\n        Returns:\n            str: The docstring for the specified module, class, or function/method, or \"No Result Found.\"\n                if not found\n        \"\"\"\n\n        module = self.module_tree_map.fetch_module(module_dotpath)\n        if module:\n            return PyCodeRetriever.get_docstring_from_node(\n                find_syntax_tree_node(module, object_path)\n            )\n        return NO_RESULT_FOUND_STR\n\n    def get_source_code_without_docstrings(\n        self, module_dotpath: str, object_path: Optional[str]\n    ) -> str:\n        \"\"\"\n        Gets code for a specified module, class, or function/method\n\n        Args:\n            module_dotpath (str): The path of the module in dot-separated format (e.g. 'package.module')\n            object_path (Optional[str]): The path of the class, function, or method in dot-separated format\n                (e.g. 'ClassName.method_name'). If None, the entire module code will be returned\n\n        Returns:\n            str: The code for the specified module, class, or function/method, or \"No Result Found.\"\n                if not found\n        \"\"\"\n\n        def _remove_docstrings(node: FSTNode):\n            \"\"\"\n            Remove docstrings from the specified node, recursively\n\n            Args:\n                node: The FST node\n                    to remove docstrings from\n            \"\"\"\n\n            if isinstance(node, (DefNode, ClassNode, RedBaron)):\n                filtered_node = node.filtered()\n                if filtered_node and isinstance(filtered_node[0], StringNode):\n                    index = filtered_node[0].index_on_parent\n                    node.pop(index)\n                child_nodes = node.find_all(lambda identifier: identifier in (\"def\", \"class\"))\n                for child_node in child_nodes:\n                    if child_node is not node:\n                        _remove_docstrings(child_node)\n\n        module = self.module_tree_map.fetch_module(module_dotpath)\n\n        if module:\n            module_copy = RedBaron(module.dumps())\n            result = find_syntax_tree_node(module_copy, object_path)\n\n            if result:\n                _remove_docstrings(result)\n                return result.dumps()\n        return NO_RESULT_FOUND_STR\n\n    @staticmethod\n    def get_docstring_from_node(node: Optional[FSTNode]) -> str:\n        \"\"\"\n        Gets the docstring from the specified node\n\n        Args:\n            node: The FST node to get the docstring from\n        \"\"\"\n        if not node:\n            return NO_RESULT_FOUND_STR\n\n        if isinstance(node, (ClassNode, DefNode, RedBaron)):\n            filtered_nodes = node.filtered()  # get rid of extra whitespace\n            if isinstance(filtered_nodes[0], StringNode):\n                return filtered_nodes[0].value.replace('\"\"\"', \"\").replace(\"'''\", \"\")\n        return \"\"\n\n    @staticmethod\n    def _create_line_number_tuples(node: FSTNode, start_line: int, start_col: int):\n        \"\"\"\n        Creates a list of tuples of line numbers and lines from the specified node\n\n        Args:\n            node: The FST node to create the line number tuples from\n            start_line: The starting line number\n            start_col: The starting column number\n        \"\"\"\n        result = []\n        for i, line in enumerate(node.dumps().strip().splitlines()):\n            if i == 0 and not line.startswith(\" \" * (start_col - 1)):\n                line = \" \" * (start_col - 1) + line\n            result.append((start_line + i, line))\n        return result\n", "summary": "PyCodeRetriever is a class that fetches Python code from a specified module, allowing users to retrieve source code, docstrings, and source code without docstrings for a given module, class, or function/method. However, it assumes the project follows Python's package and module organization and relies on the RedBaron library for parsing code, which may have limitations. An example of using PyCodeRetriever to retrieve the source code of a function from a specified module is as follows:\n\n```python\nfrom automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\nfrom automata.core.coding.py_coding.retriever import PyCodeRetriever\n\nmodule_tree_map = LazyModuleTreeMap.cached_default()\ncode_retriever = PyCodeRetriever(module_tree_map)\n\nmodule_dotpath = \"mymodule.example\"\nobject_path = \"ExampleClass.example_function\"\n\nsource_code = code_retriever.get_source_code(module_dotpath, object_path)\nprint(source_code)\n```", "context": "\n    Generate the documentation for PyCodeRetriever using the context shown below -\n  Building context for primary symbol - automata.core.coding.py_coding.retriever.PyCodeRetriever -\n  \n    Import Statements:\n      import logging\n      from __future__ import annotations\n      from typing import Optional, Union\n      from redbaron import ClassNode, DefNode, Node, RedBaron, StringNode\n      from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n      from automata.core.coding.py_coding.navigation import find_syntax_tree_node\n      from automata.core.coding.py_coding.py_utils import NO_RESULT_FOUND_STR\n      \n      # PyCodeRetriever\n      \n      `PyCodeRetriever` is a class for fetching Python code from a given module. It can be used to retrieve the source code, docstrings, and source code without docstrings for a specified module, class, or function/method. With methods like `get_docstring`, `get_source_code`, and `get_source_code_without_docstrings`, it provides a way to programmatically analyze, extract, and understand Python projects.\n      \n      ## Related Symbols\n      \n      - `automata.core.context.py_context.retriever.PyContextRetriever`\n      - `automata.core.coding.py_coding.writer.PyCodeWriter`\n      - `automata.tests.unit.test_py_code_retriever.getter`\n      - `automata.core.coding.py_coding.navigation.find_syntax_tree_node`\n      - `automata.tests.unit.test_py_writer.python_writer`\n      \n      ## Example\n      \n      Below is an example demonstrating the use of `PyCodeRetriever` to retrieve the source code of a function from a specified module.\n      \n      ```python\n      from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n      from automata.core.coding.py_coding.retriever import PyCodeRetriever\n      \n      module_tree_map = LazyModuleTreeMap.cached_default()\n      code_retriever = PyCodeRetriever(module_tree_map)\n      \n      module_dotpath = \"mymodule.example\"\n      object_path = \"ExampleClass.example_function\"\n      \n      source_code = code_retriever.get_source_code(module_dotpath, object_path)\n      print(source_code)\n      ```\n      \n      ## Limitations\n      \n      `PyCodeRetriever` assumes the project's modules are organized in a specific directory structure, following Python's package and module organization. It may not work correctly if the project structure deviates from this pattern. Additionally, `PyCodeRetriever` relies on the RedBaron library for parsing the code, which may have limitations in parsing some complex or unconventional code patterns.\n      \n      ## Follow-up Questions:\n      \n      - Can the class be extended to support other programming languages and code structures?\n      - Are there alternative libraries or approaches that could be used for parsing Python code, instead of RedBaron?\n      \n    Class Docstring:\n      Code retriever for fetching python code\n      \n    Methods:\n      def __init__(self, module_tree_map: LazyModuleTreeMap = LazyModuleTreeMap.cached_default()):\n              self.module_tree_map = module_tree_map\n      \n          \n      def get_docstring(self, module_dotpath: str, object_path: Optional[str]) -> str:\n              \"\"\"\n              Gets the docstring for a specified module, class, or function/method\n      \n              Args:\n                  module_dotpath (str): The path of the module in dot-separated format (e.g. 'package.module')\n                  object_path (Optional[str]): The path of the class, function, or method in dot-separated format\n                      (e.g. 'ClassName.method_name'). If None, the module-level docstring will be returned\n      \n              Returns:\n                  str: The docstring for the specified module, class, or function/method, or \"No Result Found.\"\n                      if not found\n              \"\"\"\n      \n              module = self.module_tree_map.fetch_module(module_dotpath)\n              if module:\n                  return PyCodeRetriever.get_docstring_from_node(\n                      find_syntax_tree_node(module, object_path)\n                  )\n              return NO_RESULT_FOUND_STR\n      \n          \n      @staticmethod\n          def get_docstring_from_node(node: Optional[FSTNode]) -> str:\n              \"\"\"\n              Gets the docstring from the specified node\n      \n              Args:\n                  node: The FST node to get the docstring from\n              \"\"\"\n              if not node:\n                  return NO_RESULT_FOUND_STR\n      \n              if isinstance(node, (ClassNode, DefNode, RedBaron)):\n                  filtered_nodes = node.filtered()  # get rid of extra whitespace\n                  if isinstance(filtered_nodes[0], StringNode):\n                      return filtered_nodes[0].value.replace('\"\"\"', \"\").replace(\"'''\", \"\")\n              return \"\"\n      \n          \n      def get_source_code(self, module_dotpath: str, object_path: Optional[str] = None) -> str:\n              \"\"\"\n              Gets code for a specified module, class, or function/method\n      \n              Args:\n                  module_dotpath (str): The path of the module in dot-separated format (e.g. 'package.module')\n                  object_path (Optional[str]): The path of the class, function, or method in dot-separated format\n                      (e.g. 'ClassName.method_name'). If None, the entire module code will be returned\n      \n              Returns:\n                  str: The code for the specified module, class, or function/method, or \"No Result Found.\"\n                      if not found\n              \"\"\"\n      \n              module = self.module_tree_map.fetch_module(module_dotpath)\n              if module:\n                  result = find_syntax_tree_node(module, object_path)\n                  if result:\n                      return result.dumps()\n      \n              return NO_RESULT_FOUND_STR\n      \n          \n      def get_source_code_without_docstrings(\n              self, module_dotpath: str, object_path: Optional[str]\n          ) -> str:\n              \"\"\"\n              Gets code for a specified module, class, or function/method\n      \n              Args:\n                  module_dotpath (str): The path of the module in dot-separated format (e.g. 'package.module')\n                  object_path (Optional[str]): The path of the class, function, or method in dot-separated format\n                      (e.g. 'ClassName.method_name'). If None, the entire module code will be returned\n      \n              Returns:\n                  str: The code for the specified module, class, or function/method, or \"No Result Found.\"\n                      if not found\n              \"\"\"\n      \n              def _remove_docstrings(node: FSTNode):\n                  \"\"\"\n                  Remove docstrings from the specified node, recursively\n      \n                  Args:\n                      node: The FST node\n                          to remove docstrings from\n                  \"\"\"\n      \n                  if isinstance(node, (DefNode, ClassNode, RedBaron)):\n                      filtered_node = node.filtered()\n                      if filtered_node and isinstance(filtered_node[0], StringNode):\n                          index = filtered_node[0].index_on_parent\n                          node.pop(index)\n                      child_nodes = node.find_all(lambda identifier: identifier in (\"def\", \"class\"))\n                      for child_node in child_nodes:\n                          if child_node is not node:\n                              _remove_docstrings(child_node)\n      \n              module = self.module_tree_map.fetch_module(module_dotpath)\n      \n              if module:\n                  module_copy = RedBaron(module.dumps())\n                  result = find_syntax_tree_node(module_copy, object_path)\n      \n                  if result:\n                      _remove_docstrings(result)\n                      return result.dumps()\n              return NO_RESULT_FOUND_STR\n      \n          \n  Building context for related symbols -\n  \n    automata.tests.unit.test_py_code_retriever.getter\n    \n        @pytest.fixture\n        def getter(module_map):\n            return PyCodeRetriever(module_map)\n        \n        \n        \n        \n    automata.core.context.py_context.retriever.PyContextRetriever\n    \n        PyContextRetriever is a class that retrieves the context of a symbol in a Python project, helping generate documentation and understanding symbol relationships. It processes abstract syntax tree (AST) nodes and operates on a SymbolGraph with a PyContextRetrieverConfig object. To use it, create a SymbolGraph instance, instantiate the PyContextRetriever with the graph, process a symbol using the `process_symbol` method, and retrieve the context buffer. Note that PyContextRetriever relies on accurate SymbolGraph and PyContextRetrieverConfig inputs; errors in these may cause issues when processing symbols. \n        \n        Usage Example:\n        \n        ```python\n        from automata.core.context.py_context.retriever import PyContextRetriever\n        from automata.core.symbol.graph import SymbolGraph\n        \n        graph = SymbolGraph()\n        py_context_retriever = PyContextRetriever(graph)\n        symbol = some_symbol\n        \n        # Process the context of the symbol\n        py_context_retriever.process_symbol(symbol)\n        \n        # Retrieve the context buffer\n        context_buffer = py_context_retriever.get_context_buffer()\n        ```\n        \n      Class Docstring:\n        The PyContextRetriever is used to retrieve the context of a symbol in a Python project\n        \n      Methods:\n        IndentManager(self) -> None\n        \n        def __init__(\n                self,\n                graph: SymbolGraph,\n                config: PyContextRetrieverConfig = PyContextRetrieverConfig(),\n                doc_embedding_db: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                Args:\n                    graph (SymbolGraph): The symbol graph to use\n                    config (PyContextRetrieverConfig): The configuration to use\n                \"\"\"\n                self.graph = graph\n                self.config = config\n                self.indent_level = 0\n                self.doc_embedding_db = doc_embedding_db\n                self.encoding = tiktoken.encoding_for_model(self.config.model_name)\n        \n                self.reset()\n        \n            \n        get_context_buffer(self) -> str\n        \n        indent() -> str\n        \n        process_ast(self, symbol: Symbol) -> None\n        \n        process_docstring(self, ast_object: RedBaron) -> None\n        \n        process_documentation(self, symbol: Symbol, is_main_symbol: bool) -> None\n        \n        process_headline(self, symbol: Symbol) -> None\n        \n        process_imports(self, symbol: Symbol) -> None\n        \n        process_message(self, message: str) -> None\n        \n        process_method(self, method: RedBaron, is_main_symbol: bool) -> None\n        \n        process_symbol(self,\n                symbol: Symbol,\n                related_symbols: List[Symbol] = [],\n            ) -> None\n        \n        reset(self) -> None\n        \n    automata.core.coding.py_coding.writer.PyCodeWriter\n    \n        PyCodeWriter is a utility class designed for writing and updating Python code in the Abstract Syntax Tree (AST) format, enabling programmatic manipulation of Python elements such as classes, functions, and imports. The main functionality includes initializing with a PyCodeRetriever instance, creating a new module object from source code, updating an existing module, and writing the updated module to disk. However, PyCodeWriter's primary limitation is its reliance on RedBaron, which has known limitations and bugs, along with relatively low support in recent years. Additionally, error reporting in PyCodeWriter can be improved for a better user experience. \n        \n        ```python\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        from automata.core.coding.py_coding.writer import PyCodeWriter\n        \n        # Initialize the PyCodeWriter with a PyCodeRetriever instance\n        retriever = PyCodeRetriever()\n        writer = PyCodeWriter(retriever)\n        \n        # Create a new module object from source code\n        module_dotpath = \"my_module\"\n        source_code = \"def hello():\\n    print('Hello, World!')\\n\"\n        writer.create_new_module(module_dotpath, source_code)\n        \n        # Update the existing module by adding a new function\n        new_function_code = \"def goodbye():\\n    print('Goodbye, World!')\\n\"\n        writer.update_existing_module(module_dotpath, new_function_code, do_write=True)\n        ```\n        \n      Class Docstring:\n        A utility class for writing Python code along AST nodes\n        \n      Methods:\n        def __init__(self, python_retriever: PyCodeRetriever):\n                \"\"\"\n                Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n                Args:\n                    python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n                \"\"\"\n                self.code_retriever = python_retriever\n        \n            \n        create_new_module(self, module_dotpath: str, source_code: str, do_write: bool = False) -> None\n        \n        delete_from_existing__module(self, module_dotpath: str, object_dotpath: str, do_write: bool = False) -> None\n        \n        replace(match) -> None\n        \n        replace_newline_chars(input_str: str) -> str\n        \n        update_existing_module(self,\n                module_dotpath: str,\n                source_code: str,\n                disambiguator: Optional[str] = \"\",\n                do_write: bool = False,\n            ) -> None\n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.core.coding.py_coding.writer.PyCodeWriter.__init__\n    \n      Class Docstring:\n        Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n        Args:\n        python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n        \n      Methods:\n        def __init__(self, python_retriever: PyCodeRetriever):\n                \"\"\"\n                Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n                Args:\n                    python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n                \"\"\"\n                self.code_retriever = python_retriever\n        \n            \n    automata.tests.unit.test_py_writer.python_writer\n    \n        @pytest.fixture\n        def python_writer():\n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            return PyCodeWriter(retriever)\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.test_write_and_retrieve_mock_code\n    \n        def test_write_and_retrieve_mock_code(python_writer):\n            mock_generator = MockCodeGenerator(\n                has_class=True,\n                has_method=True,\n                has_function=True,\n                has_import=True,\n                has_module_docstring=True,\n                has_class_docstring=True,\n                has_method_docstring=True,\n                has_function_docstring=True,\n            )\n            source_code = mock_generator.generate_code()\n            python_writer._create_module_from_source_code(\"sample_module_2\", source_code)\n        \n            python_writer._write_module_to_disk(\"sample_module_2\")\n        \n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            module_docstring = retriever.get_docstring(\"sample_module_2\", None)\n            assert module_docstring == mock_generator.module_docstring\n        \n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.context.py_context.retriever.PyContextRetrieverConfig\n    \n        class PyContextRetrieverConfig:\n            \"\"\"The configuration for the PyContextRetriever\"\"\"\n        \n            def __init__(\n                self,\n                spacer: str = \"  \",\n                max_dependencies_to_process: int = 10,\n                max_related_symbols_to_process: int = 10,\n                model_name: str = \"gpt-4\",\n                max_context: int = 6_500,\n            ):\n                \"\"\"\n                Args:\n                    spacer (str): The string to use for indentation\n                    max_dependency_print_depth (int): The maximum depth to print dependencies\n                    max_recursion_depth (int): The maximum depth to recurse into dependencies\n                    max_related_symbols_to_process (int): The number of nearest symbols to print\n                \"\"\"\n                self.spacer = spacer\n                self.max_dependencies_to_process = max_dependencies_to_process\n                self.max_related_symbols_to_process = max_related_symbols_to_process\n                self.model_name = model_name\n                self.max_context = max_context\n        \n        \n        \n    automata.tests.unit.test_py_code_retriever.test_get_code_no_docstring_no_code\n    \n        def test_get_code_no_docstring_no_code(getter):\n            module_name = \"sample\"\n            object_path = \"EmptyClass\"\n            result = getter.get_source_code_without_docstrings(module_name, object_path)\n            expected_match = \"class EmptyClass:\\n    pass\\n\\n\\n\"\n            assert result == expected_match\n        \n        \n        \n        \n  Building context for dependencies -\n  \n    automata.core.coding.py_coding.navigation.find_syntax_tree_node\n    \n      Class Docstring:\n        Find a module, or find a function, method, or class inside a module.\n        \n        Args:\n        code_obj (RedBaron): The  red baron FST object.\n        object_path (Optional[str]): The dot-separated object path (e.g., 'ClassName.method_name'). If None,\n        the module is returned.\n        \n        Returns:\n        Optional[Union[Def, Class, Module]]: The found def, or class node, or None if not found.\n        \n      Methods:\n        find_syntax_tree_node(code_obj: Optional[Union[RedBaron, ClassNode]], object_path: Optional[str]\n        ) -> Optional[Union[Node, RedBaron]]\n        \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap.cached_default\n    \n      Class Docstring:\n        Creates a new LazyModuleTreeMap instance with the default root path\n        \n      Methods:\n        cached_default(cls) -> \"LazyModuleTreeMap\"\n        \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap\n    \n        The `LazyModuleTreeMap` class is a lazy dictionary that maps module dotpaths to their corresponding RedBaron FST objects, loading and caching the modules in memory as they are accessed. It provides methods for fetching existing module dotpaths and filepaths, as well as fetching, putting, and updating modules by their dotpaths. However, it assumes a specific directory structure according to the `DotPathMap` class and does not support custom directory structures for modules.\n        \n        ```python\n        from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n        from automata.core.utils import root_fpath\n        \n        path_to_root = root_fpath()\n        module_tree_map = LazyModuleTreeMap(path_to_root)\n        \n        # Fetch an existing module by its dotpath\n        module_dotpath = \"automata.core.agent.automata_agent\"\n        module = module_tree_map.fetch_module(module_dotpath)\n        \n        # Check if a module with the given dotpath exists\n        exists = module_dotpath in module_tree_map\n        ```\n        \n      Class Docstring:\n        A lazy dictionary between module dotpaths and their corresponding RedBaron FST objects.\n        Loads and caches modules in memory as they are accessed\n        \n      Methods:\n        __contains__(self, dotpath) -> None\n        \n        def __init__(self, path: str):\n                \"\"\"\n                Args:\n                    path: The absolute path to the root of the module tree\n                \"\"\"\n                self._dotpath_map = DotPathMap(path)\n                self._loaded_modules: Dict[str, Optional[RedBaron]] = {}\n        \n            \n        cached_default(cls) -> \"LazyModuleTreeMap\"\n        \n        fetch_existing_module_dotpath(self, module_obj: RedBaron) -> Optional[str]\n        \n        fetch_existing_module_fpath_by_dotpath(self, module_dotpath: str) -> Optional[str]\n        \n        fetch_module(self, module_dotpath: str) -> Optional[RedBaron]\n        \n        get_module_dotpath_by_fpath(self, module_fpath: str) -> str\n        \n        items(self) -> Iterable[Tuple[str, Optional[RedBaron]]]\n        \n        put_module(self, module_dotpath: str, module: RedBaron) -> None\n        \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap.fetch_module\n    \n      Class Docstring:\n        Gets the module with the given dotpath\n        \n        Args:\n        module_dotpath: The dotpath of the module\n        \n        Returns:\n        Optional[RedBaron]: The module with the given dotpath if found, None otherwise\n        \n      Methods:\n        fetch_module(self, module_dotpath: str) -> Optional[RedBaron]\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.coding.py_coding.writer`/PyCodeWriter#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.coding.py_coding.writer", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "PyCodeWriter", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# PyCodeWriter\n\n`PyCodeWriter` is a utility class for writing and updating Python code in the Abstract Syntax Tree (AST) format. It provides an interface for creating a new Python module, updating an existing one by adding or removing a class or function, and writing the updated module to disk.\n\nThe primary use case for `PyCodeWriter` is to enable programmatic manipulation of Python code, including adding, updating, or deleting elements like classes, functions, and imports.\n\n## Overview\n\nThe main functionality provided by `PyCodeWriter` includes:\n\n- Initializing with a `PyCodeRetriever` instance, which is used for fetching Python code.\n- Creating a new module object from source code.\n- Updating an existing module with new or modified code.\n- Writing the updated module to disk.\n\n## Related Symbols\n\n- `automata.tests.unit.test_py_writer.MockCodeGenerator`\n- `automata.core.coding.py_coding.retriever.PyCodeRetriever`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.tests.unit.test_py_writer.python_writer`\n- `automata.core.coding.py_coding.writer.PyDocWriter`\n- `automata.core.context.py_context.retriever.PyContextRetriever`\n- `automata.tests.unit.test_py_code_retriever.getter`\n\n## Example\n\nThe following is an example demonstrating how to create a new module, update it by adding a new function, and write the updated module to disk.\n\n```python\nfrom automata.core.coding.py_coding.retriever import PyCodeRetriever\nfrom automata.core.coding.py_coding.writer import PyCodeWriter\n\n# Initialize the PyCodeWriter with a PyCodeRetriever instance\nretriever = PyCodeRetriever()\nwriter = PyCodeWriter(retriever)\n\n# Create a new module object from source code\nmodule_dotpath = \"my_module\"\nsource_code = \"def hello():\\n    print('Hello, World!')\\n\"\nwriter.create_new_module(module_dotpath, source_code)\n\n# Update the existing module by adding a new function\nnew_function_code = \"def goodbye():\\n    print('Goodbye, World!')\\n\"\nwriter.update_existing_module(module_dotpath, new_function_code, do_write=True)\n```\n\n## Limitations\n\nThe primary limitation of `PyCodeWriter` is the reliance on RedBaron for the manipulation of the Abstract Syntax Tree. RedBaron has some known limitations and bugs that may affect parsing and generating code correctly in some cases. Additionally, the support for the RedBaron library has been relatively low in recent years, which may result in potential issues remaining unfixed.\n\nAnother limitation of `PyCodeWriter` is its current error reporting, which could be improved to provide more meaningful error messages and guidance for resolving issues.\n\n## Follow-up Questions:\n\n- What alternative libraries or frameworks could be used to overcome the limitations of RedBaron?\n- How can error reporting be improved in `PyCodeWriter` for better user experience?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class PyCodeWriter:\n    \"\"\"A utility class for writing Python code along AST nodes\"\"\"\n\n    class ModuleNotFound(Exception):\n        \"\"\"Raised when a module is not found in the module dictionary\"\"\"\n\n        pass\n\n    class ClassOrFunctionNotFound(Exception):\n        \"\"\"Raised when a class or function is not found in the module\"\"\"\n\n        pass\n\n    class InvalidArguments(Exception):\n        \"\"\"Raised when invalid arguments are passed to a method\"\"\"\n\n        pass\n\n    def __init__(self, python_retriever: PyCodeRetriever):\n        \"\"\"\n        Initialize the PyCodeWriter with a PyCodeRetriever instance\n\n        Args:\n            python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n        \"\"\"\n        self.code_retriever = python_retriever\n\n    def create_new_module(self, module_dotpath: str, source_code: str, do_write: bool = False):\n        \"\"\"\n        Create a new module object from source code\n\n        Args:\n            source_code (str): The source code of the module\n            module_dotpath (str): The path of the module\n\n        Returns:\n            RedBaron: The created module object\n        \"\"\"\n        self._create_module_from_source_code(module_dotpath, source_code)\n        if do_write:\n            self._write_module_to_disk(module_dotpath)\n\n    def update_existing_module(\n        self,\n        module_dotpath: str,\n        source_code: str,\n        disambiguator: Optional[str] = \"\",\n        do_write: bool = False,\n    ):\n        \"\"\"\n        Update code or insert new code into an existing module\n\n        Args:\n            source_code (str): The source code of the part of the module that needs to be\n            updated or insert module_dotpath (str): The path of the module\n            disambiguator (Optional[str]): The name of the class or function scope where\n                the update should be applied, will default to module\n            do_write (bool): Write the module to disk after updating\n\n        Returns:\n            RedBaron: The updated module object\n\n        Raises:\n            ModuleNotFound: If the module is not found in the module dictionary\n        \"\"\"\n        module_obj = self.code_retriever.module_tree_map.fetch_module(module_dotpath)\n        if not module_obj:\n            raise PyCodeWriter.ModuleNotFound(\n                f\"Module not found in module dictionary: {module_dotpath}\"\n            )\n        PyCodeWriter._update_existing_module(\n            source_code,\n            module_dotpath,\n            module_obj,\n            disambiguator=disambiguator,\n        )\n        if do_write:\n            self._write_module_to_disk(module_dotpath)\n\n    def delete_from_existing__module(\n        self, module_dotpath: str, object_dotpath: str, do_write: bool = False\n    ):\n        \"\"\"\n        Reduce an existing module by removing a class or function\n\n        Args:\n            module_dotpath (str): The path of the module\n            object_dotpath (str): The name of the class or function to remove, including\n                the name of the scope it is in, like ClassName.function_name\n            do_write (bool): Write the module to disk after updating\n\n        Returns:\n            RedBaron: The module object\n\n        Raises:\n            ModuleNotFound: If the module is not found in the module dictionary\n        \"\"\"\n        module_obj = self.code_retriever.module_tree_map.fetch_module(module_dotpath)\n        if not module_obj:\n            raise PyCodeWriter.ModuleNotFound(\n                f\"Module not found in module dictionary: {module_dotpath}\"\n            )\n        node = find_syntax_tree_node(module_obj, object_dotpath)\n        if node:\n            PyCodeWriter._delete_node(node)\n            if do_write:\n                self._write_module_to_disk(module_dotpath)\n\n    def _write_module_to_disk(self, module_dotpath: str):\n        \"\"\"\n        Write the modified module to a file at the specified output path\n\n        Args:\n            module_dotpath (str)\n\n        Raises:\n            ModuleNotFound: If the module is not found in the module dictionary\n        \"\"\"\n        if module_dotpath not in self.code_retriever.module_tree_map:\n            raise PyCodeWriter.ModuleNotFound(\n                f\"Module not found in module dictionary: {module_dotpath}\"\n            )\n        source_code = self.code_retriever.get_source_code(module_dotpath)\n        module_fpath = self.code_retriever.module_tree_map.fetch_existing_module_fpath_by_dotpath(\n            module_dotpath\n        )\n\n        if not module_fpath:\n            raise PyCodeWriter.ModuleNotFound(\n                f\"Module fpath found in module map for dotpath: {module_dotpath}\"\n            )\n        module_fpath = cast(str, module_fpath)\n        with open(module_fpath, \"w\") as output_file:\n            output_file.write(source_code)\n        subprocess.run([\"black\", module_fpath])\n        subprocess.run([\"isort\", module_fpath])\n\n    def _create_module_from_source_code(self, module_dotpath: str, source_code: str) -> RedBaron:\n        \"\"\"\n        Create a Python module from the given source code string\n\n        Args:\n            module_dotpath (str): The path where the new module will be created\n\n        Returns:\n            RedBaron: The created module object\n        \"\"\"\n        parsed = RedBaron(source_code)\n        self.code_retriever.module_tree_map.put_module(module_dotpath, parsed)\n        return parsed\n\n    @staticmethod\n    def _update_existing_module(\n        source_code: str,\n        module_dotpath: str,\n        existing_module_obj: RedBaron,\n        disambiguator: Optional[str],\n    ):\n        \"\"\"\n        Update a module object according to the received code\n\n        Args:\n            source_code (str): The code containing the updates\n            module_dotpath (str): The relative path to the module\n            existing_module_obj Module: The module object to be updated\n            disambiguator (str): The name of the class or function scope to\n                be updated, useful for nested definitions\n\n        Raises:\n            ClassOrFunctionNotFound: If the disambiguator is not found\n        \"\"\"\n\n        new_fst = RedBaron(source_code)\n        new_import_nodes = find_import_syntax_tree_nodes(new_fst)\n        PyCodeWriter._update_imports(existing_module_obj, new_import_nodes)\n\n        new_class_or_function_nodes = find_all_function_and_class_syntax_tree_nodes(new_fst)\n        if disambiguator:  # splice the class\n            disambiguator_node = find_syntax_tree_node(existing_module_obj, disambiguator)\n            if isinstance(disambiguator_node, (ClassNode, DefNode)):\n                PyCodeWriter._update_node_with_children(\n                    new_class_or_function_nodes,\n                    disambiguator_node,\n                )\n            else:\n                raise PyCodeWriter.ClassOrFunctionNotFound(\n                    f\"Node {disambiguator} not found in module {module_dotpath}\"\n                )\n        PyCodeWriter._update_node_with_children(new_class_or_function_nodes, existing_module_obj)\n\n    @staticmethod\n    def _update_node_with_children(\n        class_or_function_nodes: NodeList,\n        node_to_update: Union[ClassNode, RedBaron],\n    ):\n        \"\"\"\n        Update a class object according to the received code\n\n        Args:\n            class_or_function_nodes (NodeList): The nodes to update\n            node_to_update (Union[ClassNode, RedBaron]): The node to update\n        \"\"\"\n        for new_node in class_or_function_nodes:\n            child_node_name = new_node.name\n            existing_node = find_syntax_tree_node(node_to_update, child_node_name)\n            if existing_node:\n                existing_node.replace(new_node)\n            else:\n                node_to_update.append(new_node)\n\n    @staticmethod\n    def _delete_node(node: Node):\n        \"\"\"\n        Delete a node from the FST\n\n        Args:\n            node (Node): The node to delete\n        \"\"\"\n        parent = node.parent\n        parent_index = node.index_on_parent\n        parent.pop(parent_index)\n\n    @staticmethod\n    def _clean_input_code(source_code: str) -> str:\n        \"\"\"\n        Take the input source code and remove formatting issues that will cause the FST to fail.\n\n        Args:\n            source_code (str): The source code to clean.\n\n        Returns:\n            str: The cleaned source code.\n        \"\"\"\n\n        def replace_newline_chars(input_str: str) -> str:\n            dummy_replacement_a = \"ZZ_^^_ZZ\"\n            dummy_replacement_b = \"QQ_^^_QQ\"\n\n            def replace(match):\n                text = match.group(0)\n                if text[0] == '\"' and text[-1] == '\"':\n                    return text\n                return text.replace(\"\\\\n\", \"\\n\")\n\n            pattern = \"(?x)\\n                '.*?'\\n                |\\n                \\\".*?\\\"\\n                |\\n                [^'\\\"]+\\n            \"\n            output_str = (\n                \"\".join(\n                    (\n                        replace(match)\n                        for match in re.finditer(\n                            pattern,\n                            input_str.replace('\"\"\"', dummy_replacement_a).replace(\n                                \"'''\", dummy_replacement_b\n                            ),\n                        )\n                    )\n                )\n                .replace(dummy_replacement_a, '\"\"\"')\n                .replace(dummy_replacement_b, \"'''\")\n            )\n            return output_str\n\n        source_code = replace_newline_chars(source_code)\n        source_code = re.sub('\\\\\\\\\\\\\"', '\"', source_code)\n        source_code = source_code.strip()\n        return source_code\n\n    @staticmethod\n    def _update_imports(module_obj: RedBaron, new_import_statements: NodeList):\n        \"\"\"\n        Manage the imports in the module\n\n        Args:\n            module_obj (RedBaron): The module object\n            new_import_statements (NodeList): The new import statements\n\n        \"\"\"\n        first_import = module_obj.find(lambda identifier: identifier in (\"import\", \"from_import\"))\n\n        for new_import_statement in new_import_statements:\n            existing_import_statement = find_import_syntax_tree_node_by_name(\n                module_obj, new_import_statement.name\n            )\n            if not existing_import_statement:\n                if first_import:\n                    first_import.insert_before(new_import_statement)  # we will run isort later\n                else:\n                    module_obj.insert(0, new_import_statement)\n\n\n", "summary": "PyCodeWriter is a utility class that enables programmatic manipulation of Python code in Abstract Syntax Tree (AST) format, including adding, updating, or deleting elements like classes, functions, and imports. It can create a new module, update an existing one by adding or removing a class or function, and write the updated module to disk. Its main functionality revolves around initializing with a `PyCodeRetriever` instance, creating a new module object from source code, and updating existing modules.\n\nHowever, PyCodeWriter has some limitations, such as its reliance on RedBaron for AST manipulation, which has known bugs and limited support. Additionally, its error reporting can be improved to provide more meaningful messages and guidance. Example usage of PyCodeWriter can be found in its documentation, including how to create a new module, update it by adding a new function, and write the updated module to disk.", "context": "\n    Generate the documentation for PyCodeWriter using the context shown below -\n  Building context for primary symbol - automata.core.coding.py_coding.writer.PyCodeWriter -\n  \n    Import Statements:\n      import logging\n      import os\n      import re\n      import subprocess\n      import numpy as np\n      import pypandoc\n      from typing import Dict, List, Optional, Union, cast\n      from redbaron import ClassNode, DefNode, Node, NodeList, RedBaron\n      from automata.core.coding.directory import DirectoryManager\n      from automata.core.coding.py_coding.navigation import (\n          find_all_function_and_class_syntax_tree_nodes,\n          find_import_syntax_tree_node_by_name,\n          find_import_syntax_tree_nodes,\n          find_syntax_tree_node,\n      )\n      from automata.core.coding.py_coding.retriever import PyCodeRetriever\n      from automata.core.symbol.symbol_types import Symbol, SymbolDocEmbedding\n      \n      # PyCodeWriter\n      \n      `PyCodeWriter` is a utility class for writing and updating Python code in the Abstract Syntax Tree (AST) format. It provides an interface for creating a new Python module, updating an existing one by adding or removing a class or function, and writing the updated module to disk.\n      \n      The primary use case for `PyCodeWriter` is to enable programmatic manipulation of Python code, including adding, updating, or deleting elements like classes, functions, and imports.\n      \n      ## Overview\n      \n      The main functionality provided by `PyCodeWriter` includes:\n      \n      - Initializing with a `PyCodeRetriever` instance, which is used for fetching Python code.\n      - Creating a new module object from source code.\n      - Updating an existing module with new or modified code.\n      - Writing the updated module to disk.\n      \n      ## Related Symbols\n      \n      - `automata.tests.unit.test_py_writer.MockCodeGenerator`\n      - `automata.core.coding.py_coding.retriever.PyCodeRetriever`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.tests.unit.test_py_writer.python_writer`\n      - `automata.core.coding.py_coding.writer.PyDocWriter`\n      - `automata.core.context.py_context.retriever.PyContextRetriever`\n      - `automata.tests.unit.test_py_code_retriever.getter`\n      \n      ## Example\n      \n      The following is an example demonstrating how to create a new module, update it by adding a new function, and write the updated module to disk.\n      \n      ```python\n      from automata.core.coding.py_coding.retriever import PyCodeRetriever\n      from automata.core.coding.py_coding.writer import PyCodeWriter\n      \n      # Initialize the PyCodeWriter with a PyCodeRetriever instance\n      retriever = PyCodeRetriever()\n      writer = PyCodeWriter(retriever)\n      \n      # Create a new module object from source code\n      module_dotpath = \"my_module\"\n      source_code = \"def hello():\\n    print('Hello, World!')\\n\"\n      writer.create_new_module(module_dotpath, source_code)\n      \n      # Update the existing module by adding a new function\n      new_function_code = \"def goodbye():\\n    print('Goodbye, World!')\\n\"\n      writer.update_existing_module(module_dotpath, new_function_code, do_write=True)\n      ```\n      \n      ## Limitations\n      \n      The primary limitation of `PyCodeWriter` is the reliance on RedBaron for the manipulation of the Abstract Syntax Tree. RedBaron has some known limitations and bugs that may affect parsing and generating code correctly in some cases. Additionally, the support for the RedBaron library has been relatively low in recent years, which may result in potential issues remaining unfixed.\n      \n      Another limitation of `PyCodeWriter` is its current error reporting, which could be improved to provide more meaningful error messages and guidance for resolving issues.\n      \n      ## Follow-up Questions:\n      \n      - What alternative libraries or frameworks could be used to overcome the limitations of RedBaron?\n      - How can error reporting be improved in `PyCodeWriter` for better user experience?\n      \n    Class Docstring:\n      A utility class for writing Python code along AST nodes\n      \n    Methods:\n      def __init__(self, python_retriever: PyCodeRetriever):\n              \"\"\"\n              Initialize the PyCodeWriter with a PyCodeRetriever instance\n      \n              Args:\n                  python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n              \"\"\"\n              self.code_retriever = python_retriever\n      \n          \n      def create_new_module(self, module_dotpath: str, source_code: str, do_write: bool = False):\n              \"\"\"\n              Create a new module object from source code\n      \n              Args:\n                  source_code (str): The source code of the module\n                  module_dotpath (str): The path of the module\n      \n              Returns:\n                  RedBaron: The created module object\n              \"\"\"\n              self._create_module_from_source_code(module_dotpath, source_code)\n              if do_write:\n                  self._write_module_to_disk(module_dotpath)\n      \n          \n      def delete_from_existing__module(\n              self, module_dotpath: str, object_dotpath: str, do_write: bool = False\n          ):\n              \"\"\"\n              Reduce an existing module by removing a class or function\n      \n              Args:\n                  module_dotpath (str): The path of the module\n                  object_dotpath (str): The name of the class or function to remove, including\n                      the name of the scope it is in, like ClassName.function_name\n                  do_write (bool): Write the module to disk after updating\n      \n              Returns:\n                  RedBaron: The module object\n      \n              Raises:\n                  ModuleNotFound: If the module is not found in the module dictionary\n              \"\"\"\n              module_obj = self.code_retriever.module_tree_map.fetch_module(module_dotpath)\n              if not module_obj:\n                  raise PyCodeWriter.ModuleNotFound(\n                      f\"Module not found in module dictionary: {module_dotpath}\"\n                  )\n              node = find_syntax_tree_node(module_obj, object_dotpath)\n              if node:\n                  PyCodeWriter._delete_node(node)\n                  if do_write:\n                      self._write_module_to_disk(module_dotpath)\n      \n          \n      def replace(match):\n                      text = match.group(0)\n                      if text[0] == '\"' and text[-1] == '\"':\n                          return text\n                      return text.replace(\"\\\\n\", \"\\n\")\n      \n                  \n      def replace_newline_chars(input_str: str) -> str:\n                  dummy_replacement_a = \"ZZ_^^_ZZ\"\n                  dummy_replacement_b = \"QQ_^^_QQ\"\n      \n                  def replace(match):\n                      text = match.group(0)\n                      if text[0] == '\"' and text[-1] == '\"':\n                          return text\n                      return text.replace(\"\\\\n\", \"\\n\")\n      \n                  pattern = \"(?x)\\n                '.*?'\\n                |\\n                \\\".*?\\\"\\n                |\\n                [^'\\\"]+\\n            \"\n                  output_str = (\n                      \"\".join(\n                          (\n                              replace(match)\n                              for match in re.finditer(\n                                  pattern,\n                                  input_str.replace('\"\"\"', dummy_replacement_a).replace(\n                                      \"'''\", dummy_replacement_b\n                                  ),\n                              )\n                          )\n                      )\n                      .replace(dummy_replacement_a, '\"\"\"')\n                      .replace(dummy_replacement_b, \"'''\")\n                  )\n                  return output_str\n      \n              \n      def update_existing_module(\n              self,\n              module_dotpath: str,\n              source_code: str,\n              disambiguator: Optional[str] = \"\",\n              do_write: bool = False,\n          ):\n              \"\"\"\n              Update code or insert new code into an existing module\n      \n              Args:\n                  source_code (str): The source code of the part of the module that needs to be\n                  updated or insert module_dotpath (str): The path of the module\n                  disambiguator (Optional[str]): The name of the class or function scope where\n                      the update should be applied, will default to module\n                  do_write (bool): Write the module to disk after updating\n      \n              Returns:\n                  RedBaron: The updated module object\n      \n              Raises:\n                  ModuleNotFound: If the module is not found in the module dictionary\n              \"\"\"\n              module_obj = self.code_retriever.module_tree_map.fetch_module(module_dotpath)\n              if not module_obj:\n                  raise PyCodeWriter.ModuleNotFound(\n                      f\"Module not found in module dictionary: {module_dotpath}\"\n                  )\n              PyCodeWriter._update_existing_module(\n                  source_code,\n                  module_dotpath,\n                  module_obj,\n                  disambiguator=disambiguator,\n              )\n              if do_write:\n                  self._write_module_to_disk(module_dotpath)\n      \n          \n  Building context for related symbols -\n  \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator.generate_code\n    \n        def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            \n        \n    automata.core.coding.py_coding.retriever.PyCodeRetriever\n    \n        `PyCodeRetriever` is a class designed to fetch Python code from a specified module, enabling the retrieval of source code, docstrings, and source code without docstrings for a given module, class, or function/method. Through methods like `get_docstring`, `get_source_code`, and `get_source_code_without_docstrings`, it offers a way to programmatically analyze, extract, and comprehend Python projects. However, this class assumes a specific directory structure for the modules and relies on the RedBaron library for parsing, which may have limitations when parsing complex or unconventional code patterns.\n        \n        An example usage of `PyCodeRetriever` for retrieving the source code of a function from a specified module is as follows:\n        \n        ```python\n        from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        \n        module_tree_map = LazyModuleTreeMap.cached_default()\n        code_retriever = PyCodeRetriever(module_tree_map)\n        \n        module_dotpath = \"mymodule.example\"\n        object_path = \"ExampleClass.example_function\"\n        \n        source_code = code_retriever.get_source_code(module_dotpath, object_path)\n        print(source_code)\n        ```\n        \n        \n      Class Docstring:\n        Code retriever for fetching python code\n        \n      Methods:\n        def __init__(self, module_tree_map: LazyModuleTreeMap = LazyModuleTreeMap.cached_default()):\n                self.module_tree_map = module_tree_map\n        \n            \n        get_docstring(self, module_dotpath: str, object_path: Optional[str]) -> str\n        \n        get_docstring_from_node(node: Optional[FSTNode]) -> str\n        \n        get_source_code(self, module_dotpath: str, object_path: Optional[str] = None) -> str\n        \n        get_source_code_without_docstrings(self, module_dotpath: str, object_path: Optional[str]\n            ) -> str\n        \n    automata.tests.unit.test_py_writer.python_writer\n    \n        @pytest.fixture\n        def python_writer():\n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            return PyCodeWriter(retriever)\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_py_writer.test_create_update_write_module\n    \n        def test_create_update_write_module(python_writer):\n            mock_generator = MockCodeGenerator(\n                has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n            )\n            source_code = mock_generator.generate_code()\n            python_writer.create_new_module(\"sample_module_write\", source_code, do_write=True)\n            root_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            fpath = os.path.join(root_dir, \"sample_module_write.py\")\n            assert os.path.exists(fpath)\n            with open(fpath, \"r\") as f:\n                contents = f.read()\n                assert_code_lines_equal(source_code, contents)\n        \n            mock_generator_2 = MockCodeGenerator(\n                has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n            )\n            source_code_2 = mock_generator_2.generate_code()\n        \n            assert source_code != source_code_2\n            python_writer.update_existing_module(\n                source_code=source_code_2, module_dotpath=\"sample_module_write\", do_write=True\n            )\n        \n            with open(fpath, \"r\") as f:\n                contents = f.read()\n                assert_code_lines_equal(\"\\n\".join([source_code, source_code_2]), contents)\n        \n            os.remove(fpath)\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.test_write_and_retrieve_mock_code\n    \n        def test_write_and_retrieve_mock_code(python_writer):\n            mock_generator = MockCodeGenerator(\n                has_class=True,\n                has_method=True,\n                has_function=True,\n                has_import=True,\n                has_module_docstring=True,\n                has_class_docstring=True,\n                has_method_docstring=True,\n                has_function_docstring=True,\n            )\n            source_code = mock_generator.generate_code()\n            python_writer._create_module_from_source_code(\"sample_module_2\", source_code)\n        \n            python_writer._write_module_to_disk(\"sample_module_2\")\n        \n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            module_docstring = retriever.get_docstring(\"sample_module_2\", None)\n            assert module_docstring == mock_generator.module_docstring\n        \n        \n    automata.core.context.py_context.retriever.PyContextRetriever\n    \n        PyContextRetriever is a class that retrieves the context of a symbol in a Python project, helping generate documentation and understanding symbol relationships. It processes abstract syntax tree (AST) nodes and operates on a SymbolGraph with a PyContextRetrieverConfig object. To use it, create a SymbolGraph instance, instantiate the PyContextRetriever with the graph, process a symbol using the `process_symbol` method, and retrieve the context buffer. Note that PyContextRetriever relies on accurate SymbolGraph and PyContextRetrieverConfig inputs; errors in these may cause issues when processing symbols. \n        \n        Usage Example:\n        \n        ```python\n        from automata.core.context.py_context.retriever import PyContextRetriever\n        from automata.core.symbol.graph import SymbolGraph\n        \n        graph = SymbolGraph()\n        py_context_retriever = PyContextRetriever(graph)\n        symbol = some_symbol\n        \n        # Process the context of the symbol\n        py_context_retriever.process_symbol(symbol)\n        \n        # Retrieve the context buffer\n        context_buffer = py_context_retriever.get_context_buffer()\n        ```\n        \n      Class Docstring:\n        The PyContextRetriever is used to retrieve the context of a symbol in a Python project\n        \n      Methods:\n        IndentManager(self) -> None\n        \n        def __init__(\n                self,\n                graph: SymbolGraph,\n                config: PyContextRetrieverConfig = PyContextRetrieverConfig(),\n                doc_embedding_db: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                Args:\n                    graph (SymbolGraph): The symbol graph to use\n                    config (PyContextRetrieverConfig): The configuration to use\n                \"\"\"\n                self.graph = graph\n                self.config = config\n                self.indent_level = 0\n                self.doc_embedding_db = doc_embedding_db\n                self.encoding = tiktoken.encoding_for_model(self.config.model_name)\n        \n                self.reset()\n        \n            \n        get_context_buffer(self) -> str\n        \n        indent() -> str\n        \n        process_ast(self, symbol: Symbol) -> None\n        \n        process_docstring(self, ast_object: RedBaron) -> None\n        \n        process_documentation(self, symbol: Symbol, is_main_symbol: bool) -> None\n        \n        process_headline(self, symbol: Symbol) -> None\n        \n        process_imports(self, symbol: Symbol) -> None\n        \n        process_message(self, message: str) -> None\n        \n        process_method(self, method: RedBaron, is_main_symbol: bool) -> None\n        \n        process_symbol(self,\n                symbol: Symbol,\n                related_symbols: List[Symbol] = [],\n            ) -> None\n        \n        reset(self) -> None\n        \n    automata.core.coding.py_coding.writer.PyDocWriter\n    \n        PyDocWriter is a Python class designed to create documentation for modules, classes, and methods in a Python project using the Restructured Text (reST) format. It generates reST files for each key in the documentation dictionary, organizes them in the output directory, and allows customization of the output directory. However, PyDocWriter has certain limitations, such as assuming camel case naming convention for input symbols and lacking a fully functional summary generation function (`generate_summary`). An example usage of PyDocWriter can be seen below:\n        \n        ```python\n        from automata.core.coding.py_coding.writer import PyDocWriter\n        \n        base_path = \"path/to/project\"\n        docs_dir = \"path/to/output/docs\"\n        docs = {...}  # The documentation dictionary\n        symbols = [...]  # The symbols of the documentation dictionary\n        \n        doc_writer = PyDocWriter(base_path)\n        doc_writer.write_documentation(docs, symbols, docs_dir)\n        ```\n        \n      Class Docstring:\n        A class to write documentation for Python modules\n        \n      Methods:\n        def __init__(self, base_path: str):\n                \"\"\"\n                Args:\n                    base_path (str): The base path of the project\n                \"\"\"\n                self.base_path = base_path\n                self.directory_manager = DirectoryManager(base_path)\n        \n            \n        camel_to_snake(name: str) -> str\n        \n        check_camel_case(text: str) -> bool\n        \n        generate_index_files(self, docs_dir: str) -> None\n        \n        generate_module_summary(self, module_dir: str) -> None\n        \n        generate_rst_files(self, docs: Dict[Symbol, SymbolDocEmbedding], symbols: List[Symbol], docs_dir: str) -> None\n        \n        generate_summary(content: str) -> str\n        \n        get_payload(directory: str) -> str\n        \n        write_documentation(self, docs: Dict[Symbol, SymbolDocEmbedding], symbols: List[Symbol], docs_dir: str) -> None\n        \n    automata.tests.unit.test_py_code_retriever.getter\n    \n        @pytest.fixture\n        def getter(module_map):\n            return PyCodeRetriever(module_map)\n        \n        \n        \n        \n  Building context for dependencies -\n  \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap.put_module\n    \n      Class Docstring:\n        Put a module with the given dotpath in the map\n        \n        Args:\n        module_dotpath: The dotpath of the module\n        module: The module to put in the map\n        \n      Methods:\n        put_module(self, module_dotpath: str, module: RedBaron) -> None\n        \n    automata.core.coding.py_coding.navigation.find_all_function_and_class_syntax_tree_nodes\n    \n      Class Docstring:\n        Find all imports in a module.\n        \n        Args:\n        module (RedBaron): The module to search.\n        \n        Returns:\n        NodeList: A list of ClassNode and DefNode objects.\n        \n      Methods:\n        find_all_function_and_class_syntax_tree_nodes(module: RedBaron) -> NodeList\n        \n    automata.core.coding.py_coding.navigation.find_syntax_tree_node\n    \n      Class Docstring:\n        Find a module, or find a function, method, or class inside a module.\n        \n        Args:\n        code_obj (RedBaron): The  red baron FST object.\n        object_path (Optional[str]): The dot-separated object path (e.g., 'ClassName.method_name'). If None,\n        the module is returned.\n        \n        Returns:\n        Optional[Union[Def, Class, Module]]: The found def, or class node, or None if not found.\n        \n      Methods:\n        find_syntax_tree_node(code_obj: Optional[Union[RedBaron, ClassNode]], object_path: Optional[str]\n        ) -> Optional[Union[Node, RedBaron]]\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.coding.py_coding.writer`/PyCodeWriter#ClassOrFunctionNotFound#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.coding.py_coding.writer", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "PyCodeWriter", "suffix": 2, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "ClassOrFunctionNotFound", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# PyCodeWriter\n\n`PyCodeWriter` is a utility class for writing Python code along Abstract Syntax Tree (AST) nodes. It builds on the `PyCodeRetriever` object and provides various methods for creating, updating, and deleting modules. The `PyCodeWriter` class can be extended to write documentation for Python modules and execute code generation tasks.\n\n## Overview\n\nThe main functionality of `PyCodeWriter` is centered around creating, updating, and deleting Python modules using AST nodes. It provides methods to perform these actions, such as `create_new_module`, `delete_from_existing_module`, and `update_existing_module`. The class is initialized with a `PyCodeRetriever` instance that retrieves Python code from modules and objects.\n\n## Related Symbols\n\n- `PyCodeRetriever`\n- `automata.tests.unit.test_py_writer.MockCodeGenerator`\n\n## Example\n\nThe following example demonstrates how to create an instance of `PyCodeWriter` with a `PyCodeRetriever` instance:\n\n```python\nfrom automata.core.coding.py_coding.retriever import PyCodeRetriever\nfrom automata.core.coding.py_coding.writer import PyCodeWriter\nfrom automata.core.coding.directory import DirectoryManager\n\npython_retriever = PyCodeRetriever(DirectoryManager().module_tree_map)\ncode_writer = PyCodeWriter(python_retriever)\n```\n\n## Limitations\n\n`PyCodeWriter` assumes that the provided module paths have the given structure and can only work on modules with that structure. This makes it less flexible for working with different modules' structures.\n\n## Follow-up Questions\n\n- Are there any plans to extend support for custom module structures in the future?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class ClassOrFunctionNotFound(Exception):\n        \"\"\"Raised when a class or function is not found in the module\"\"\"\n\n        pass\n\n    ", "summary": "PyCodeWriter is a utility class designed for writing Python code using Abstract Syntax Tree (AST) nodes. It builds upon the PyCodeRetriever object to create, update, and delete Python modules. PyCodeWriter can easily be extended for tasks such as writing documentation or generating code. To use PyCodeWriter, you'll need to initialize it with a PyCodeRetriever instance.\n\n```python\nfrom automata.core.coding.py_coding.retriever import PyCodeRetriever\nfrom automata.core.coding.py_coding.writer import PyCodeWriter\nfrom automata.core.coding.directory import DirectoryManager\n\npython_retriever = PyCodeRetriever(DirectoryManager().module_tree_map)\ncode_writer = PyCodeWriter(python_retriever)\n```\n\nNote that PyCodeWriter assumes a specific module structure, which can limit its flexibility for working with different module designs.", "context": "\n    Generate the documentation for PyCodeWriter using the context shown below -\n  Building context for primary symbol - automata.core.coding.py_coding.writer.PyCodeWriter.ClassOrFunctionNotFound -\n  \n    Import Statements:\n      import logging\n      import os\n      import re\n      import subprocess\n      import numpy as np\n      import pypandoc\n      from typing import Dict, List, Optional, Union, cast\n      from redbaron import ClassNode, DefNode, Node, NodeList, RedBaron\n      from automata.core.coding.directory import DirectoryManager\n      from automata.core.coding.py_coding.navigation import (\n          find_all_function_and_class_syntax_tree_nodes,\n          find_import_syntax_tree_node_by_name,\n          find_import_syntax_tree_nodes,\n          find_syntax_tree_node,\n      )\n      from automata.core.coding.py_coding.retriever import PyCodeRetriever\n      from automata.core.symbol.symbol_types import Symbol, SymbolDocEmbedding\n      \n      # PyCodeWriter\n      \n      `PyCodeWriter` is a utility class for writing Python code along AST nodes. It builds on the `PyCodeRetriever` object and provides various methods for creating, updating, and deleting modules. The `PyCodeWriter` class can be extended to write documentation for Python modules and execute code generation tasks.\n      \n      ## Overview\n      \n      The main functionality of `PyCodeWriter` is centered around creating, updating, and deleting Python modules using AST nodes. It provides methods to perform these actions, such as `create_new_module`, `delete_from_existing_module`, and `update_existing_module`. The class is initialized with a `PyCodeRetriever` instance that retrieves Python code from modules and objects.\n      \n      ## Related Symbols\n      \n      - `PyCodeRetriever` \n      - `automata.tests.unit.test_py_writer.MockCodeGenerator`\n      \n      ## Example\n      \n      The following example demonstrates how to create an instance of `PyCodeWriter` with a `PyCodeRetriever` instance:\n      \n      ```python\n      from automata.core.coding.py_coding.retriever import PyCodeRetriever\n      from automata.core.coding.py_coding.writer import PyCodeWriter\n      from automata.core.coding.directory import DirectoryManager\n      \n      python_retriever = PyCodeRetriever(DirectoryManager().module_tree_map)\n      code_writer = PyCodeWriter(python_retriever)\n      ```\n      \n      ## Limitations\n      \n      `PyCodeWriter` assumes that the provided module paths have the given structure and can only work on modules with that structure. This makes it less flexible for working with different modules' structures.\n      \n      ## Follow-up Questions\n      \n      - Are there any plans to extend support for custom module structures in the future?\n      \n    Class Docstring:\n      Raised when a class or function is not found in the module\n      \n  Building context for related symbols -\n  \n    automata.core.coding.py_coding.writer.PyCodeWriter\n    \n        PyCodeWriter is a utility class designed for writing and updating Python code in the Abstract Syntax Tree (AST) format, enabling programmatic manipulation of Python elements such as classes, functions, and imports. The main functionality includes initializing with a PyCodeRetriever instance, creating a new module object from source code, updating an existing module, and writing the updated module to disk. However, PyCodeWriter's primary limitation is its reliance on RedBaron, which has known limitations and bugs, along with relatively low support in recent years. Additionally, error reporting in PyCodeWriter can be improved for a better user experience. \n        \n        ```python\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        from automata.core.coding.py_coding.writer import PyCodeWriter\n        \n        # Initialize the PyCodeWriter with a PyCodeRetriever instance\n        retriever = PyCodeRetriever()\n        writer = PyCodeWriter(retriever)\n        \n        # Create a new module object from source code\n        module_dotpath = \"my_module\"\n        source_code = \"def hello():\\n    print('Hello, World!')\\n\"\n        writer.create_new_module(module_dotpath, source_code)\n        \n        # Update the existing module by adding a new function\n        new_function_code = \"def goodbye():\\n    print('Goodbye, World!')\\n\"\n        writer.update_existing_module(module_dotpath, new_function_code, do_write=True)\n        ```\n        \n      Class Docstring:\n        A utility class for writing Python code along AST nodes\n        \n      Methods:\n        def __init__(self, python_retriever: PyCodeRetriever):\n                \"\"\"\n                Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n                Args:\n                    python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n                \"\"\"\n                self.code_retriever = python_retriever\n        \n            \n        create_new_module(self, module_dotpath: str, source_code: str, do_write: bool = False) -> None\n        \n        delete_from_existing__module(self, module_dotpath: str, object_dotpath: str, do_write: bool = False) -> None\n        \n        replace(match) -> None\n        \n        replace_newline_chars(input_str: str) -> str\n        \n        update_existing_module(self,\n                module_dotpath: str,\n                source_code: str,\n                disambiguator: Optional[str] = \"\",\n                do_write: bool = False,\n            ) -> None\n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator.generate_code\n    \n        def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            \n        \n    automata.core.coding.py_coding.retriever.PyCodeRetriever\n    \n        `PyCodeRetriever` is a class designed to fetch Python code from a specified module, enabling the retrieval of source code, docstrings, and source code without docstrings for a given module, class, or function/method. Through methods like `get_docstring`, `get_source_code`, and `get_source_code_without_docstrings`, it offers a way to programmatically analyze, extract, and comprehend Python projects. However, this class assumes a specific directory structure for the modules and relies on the RedBaron library for parsing, which may have limitations when parsing complex or unconventional code patterns.\n        \n        An example usage of `PyCodeRetriever` for retrieving the source code of a function from a specified module is as follows:\n        \n        ```python\n        from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        \n        module_tree_map = LazyModuleTreeMap.cached_default()\n        code_retriever = PyCodeRetriever(module_tree_map)\n        \n        module_dotpath = \"mymodule.example\"\n        object_path = \"ExampleClass.example_function\"\n        \n        source_code = code_retriever.get_source_code(module_dotpath, object_path)\n        print(source_code)\n        ```\n        \n        \n      Class Docstring:\n        Code retriever for fetching python code\n        \n      Methods:\n        def __init__(self, module_tree_map: LazyModuleTreeMap = LazyModuleTreeMap.cached_default()):\n                self.module_tree_map = module_tree_map\n        \n            \n        get_docstring(self, module_dotpath: str, object_path: Optional[str]) -> str\n        \n        get_docstring_from_node(node: Optional[FSTNode]) -> str\n        \n        get_source_code(self, module_dotpath: str, object_path: Optional[str] = None) -> str\n        \n        get_source_code_without_docstrings(self, module_dotpath: str, object_path: Optional[str]\n            ) -> str\n        \n    automata.tests.unit.test_py_writer.python_writer\n    \n        @pytest.fixture\n        def python_writer():\n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            return PyCodeWriter(retriever)\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_py_writer.test_create_update_write_module\n    \n        def test_create_update_write_module(python_writer):\n            mock_generator = MockCodeGenerator(\n                has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n            )\n            source_code = mock_generator.generate_code()\n            python_writer.create_new_module(\"sample_module_write\", source_code, do_write=True)\n            root_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            fpath = os.path.join(root_dir, \"sample_module_write.py\")\n            assert os.path.exists(fpath)\n            with open(fpath, \"r\") as f:\n                contents = f.read()\n                assert_code_lines_equal(source_code, contents)\n        \n            mock_generator_2 = MockCodeGenerator(\n                has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n            )\n            source_code_2 = mock_generator_2.generate_code()\n        \n            assert source_code != source_code_2\n            python_writer.update_existing_module(\n                source_code=source_code_2, module_dotpath=\"sample_module_write\", do_write=True\n            )\n        \n            with open(fpath, \"r\") as f:\n                contents = f.read()\n                assert_code_lines_equal(\"\\n\".join([source_code, source_code_2]), contents)\n        \n            os.remove(fpath)\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.test_write_and_retrieve_mock_code\n    \n        def test_write_and_retrieve_mock_code(python_writer):\n            mock_generator = MockCodeGenerator(\n                has_class=True,\n                has_method=True,\n                has_function=True,\n                has_import=True,\n                has_module_docstring=True,\n                has_class_docstring=True,\n                has_method_docstring=True,\n                has_function_docstring=True,\n            )\n            source_code = mock_generator.generate_code()\n            python_writer._create_module_from_source_code(\"sample_module_2\", source_code)\n        \n            python_writer._write_module_to_disk(\"sample_module_2\")\n        \n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            module_docstring = retriever.get_docstring(\"sample_module_2\", None)\n            assert module_docstring == mock_generator.module_docstring\n        \n        \n    automata.core.context.py_context.retriever.PyContextRetriever\n    \n        PyContextRetriever is a class that retrieves the context of a symbol in a Python project, helping generate documentation and understanding symbol relationships. It processes abstract syntax tree (AST) nodes and operates on a SymbolGraph with a PyContextRetrieverConfig object. To use it, create a SymbolGraph instance, instantiate the PyContextRetriever with the graph, process a symbol using the `process_symbol` method, and retrieve the context buffer. Note that PyContextRetriever relies on accurate SymbolGraph and PyContextRetrieverConfig inputs; errors in these may cause issues when processing symbols. \n        \n        Usage Example:\n        \n        ```python\n        from automata.core.context.py_context.retriever import PyContextRetriever\n        from automata.core.symbol.graph import SymbolGraph\n        \n        graph = SymbolGraph()\n        py_context_retriever = PyContextRetriever(graph)\n        symbol = some_symbol\n        \n        # Process the context of the symbol\n        py_context_retriever.process_symbol(symbol)\n        \n        # Retrieve the context buffer\n        context_buffer = py_context_retriever.get_context_buffer()\n        ```\n        \n      Class Docstring:\n        The PyContextRetriever is used to retrieve the context of a symbol in a Python project\n        \n      Methods:\n        IndentManager(self) -> None\n        \n        def __init__(\n                self,\n                graph: SymbolGraph,\n                config: PyContextRetrieverConfig = PyContextRetrieverConfig(),\n                doc_embedding_db: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                Args:\n                    graph (SymbolGraph): The symbol graph to use\n                    config (PyContextRetrieverConfig): The configuration to use\n                \"\"\"\n                self.graph = graph\n                self.config = config\n                self.indent_level = 0\n                self.doc_embedding_db = doc_embedding_db\n                self.encoding = tiktoken.encoding_for_model(self.config.model_name)\n        \n                self.reset()\n        \n            \n        get_context_buffer(self) -> str\n        \n        indent() -> str\n        \n        process_ast(self, symbol: Symbol) -> None\n        \n        process_docstring(self, ast_object: RedBaron) -> None\n        \n        process_documentation(self, symbol: Symbol, is_main_symbol: bool) -> None\n        \n        process_headline(self, symbol: Symbol) -> None\n        \n        process_imports(self, symbol: Symbol) -> None\n        \n        process_message(self, message: str) -> None\n        \n        process_method(self, method: RedBaron, is_main_symbol: bool) -> None\n        \n        process_symbol(self,\n                symbol: Symbol,\n                related_symbols: List[Symbol] = [],\n            ) -> None\n        \n        reset(self) -> None\n        \n    automata.core.coding.py_coding.writer.PyDocWriter\n    \n        PyDocWriter is a Python class designed to create documentation for modules, classes, and methods in a Python project using the Restructured Text (reST) format. It generates reST files for each key in the documentation dictionary, organizes them in the output directory, and allows customization of the output directory. However, PyDocWriter has certain limitations, such as assuming camel case naming convention for input symbols and lacking a fully functional summary generation function (`generate_summary`). An example usage of PyDocWriter can be seen below:\n        \n        ```python\n        from automata.core.coding.py_coding.writer import PyDocWriter\n        \n        base_path = \"path/to/project\"\n        docs_dir = \"path/to/output/docs\"\n        docs = {...}  # The documentation dictionary\n        symbols = [...]  # The symbols of the documentation dictionary\n        \n        doc_writer = PyDocWriter(base_path)\n        doc_writer.write_documentation(docs, symbols, docs_dir)\n        ```\n        \n      Class Docstring:\n        A class to write documentation for Python modules\n        \n      Methods:\n        def __init__(self, base_path: str):\n                \"\"\"\n                Args:\n                    base_path (str): The base path of the project\n                \"\"\"\n                self.base_path = base_path\n                self.directory_manager = DirectoryManager(base_path)\n        \n            \n        camel_to_snake(name: str) -> str\n        \n        check_camel_case(text: str) -> bool\n        \n        generate_index_files(self, docs_dir: str) -> None\n        \n        generate_module_summary(self, module_dir: str) -> None\n        \n        generate_rst_files(self, docs: Dict[Symbol, SymbolDocEmbedding], symbols: List[Symbol], docs_dir: str) -> None\n        \n        generate_summary(content: str) -> str\n        \n        get_payload(directory: str) -> str\n        \n        write_documentation(self, docs: Dict[Symbol, SymbolDocEmbedding], symbols: List[Symbol], docs_dir: str) -> None\n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.coding.py_coding.writer`/PyCodeWriter#InvalidArguments#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.coding.py_coding.writer", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "PyCodeWriter", "suffix": 2, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "InvalidArguments", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# PyCodeWriter\n\nPyCodeWriter is a utility class responsible for writing Python code along with the Abstract Syntax Tree (AST) nodes. It interacts with a PyCodeRetriever instance to write and update Python source code files. The class offers methods to create new Python modules, update existing modules with new code, and delete specific code from an existing module.\n\n## Related Symbols\n\n- `automata.core.coding.directory.DirectoryManager`\n- `automata.core.coding.py_coding.retriever.PyCodeRetriever`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.symbol_types.SymbolDocEmbedding`\n\n## Import Statements\n\n```python\nimport logging\nimport os\nimport re\nimport subprocess\nimport numpy as np\nimport pypandoc\nfrom typing import Dict, List, Optional, Union, cast\nfrom redbaron import ClassNode, DefNode, Node, NodeList, RedBaron\nfrom automata.core.coding.directory import DirectoryManager\nfrom automata.core.coding.py_coding.navigation import (\n    find_all_function_and_class_syntax_tree_nodes,\n    find_import_syntax_tree_node_by_name,\n    find_import_syntax_tree_nodes,\n    find_syntax_tree_node,\n)\nfrom automata.core.coding.py_coding.retriever import PyCodeRetriever\nfrom automata.core.symbol.symbol_types import Symbol, SymbolDocEmbedding\n```\n\n## Example\n\nThe following example demonstrates how to use `PyCodeWriter` to create, update, and write to a Python module.\n\n```python\nfrom automata.tests.unit.test_py_writer import python_writer, MockCodeGenerator\n\n# Create a mock code generator\nmock_generator = MockCodeGenerator(\n    has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n)\nsource_code = mock_generator.generate_code()\n\n# Instantiate a PythonWriter with a PyCodeRetriever\npy_writer = python_writer()\n\n# Create a new Python module with the generated source code\npy_writer.create_new_module(\"sample_module\", source_code, do_write=True)\n\n# Update the existing Python module with new source code\nnew_generator = MockCodeGenerator(\n    has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n)\nnew_source_code = new_generator.generate_code()\npy_writer.update_existing_module(\n    source_code=new_source_code, module_dotpath=\"sample_module\", do_write=True\n)\n```\n\n## Limitations\n\nPyCodeWriter relies on the directory structure provided by `DirectoryManager`. It cannot create or update Python source code files that are outside of the directory specified in the `base_path` used to initialize `DirectoryManager`. Additionally, PyCodeWriter handles only Python source code files and cannot be used for other programming languages or file types.\n\n## Follow-up Questions:\n\n- What is the role of `PyCodeWriter` in writing documentation for Python modules?\n- How does `PyCodeWriter` handle different code styles or formatting?\n\n## InvalidArguments\n\nRaised when invalid arguments are passed to a method.", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class InvalidArguments(Exception):\n        \"\"\"Raised when invalid arguments are passed to a method\"\"\"\n\n        pass\n\n    ", "summary": "PyCodeWriter is a utility class designed to write Python code along with corresponding Abstract Syntax Tree (AST) nodes. It interacts with a PyCodeRetriever instance to create, update, and delete code in Python source files. The class provides methods to generate new Python modules, modify existing ones with additional code, and remove specific code sections from a module. PyCodeWriter relies on the directory structure provided by DirectoryManager and is limited to handling Python source code files within the specified directory.\n\nTo demonstrate its usage, a PythonWriter is instantiated with a PyCodeRetriever and the mock source code is used to create a new Python module called \"sample_module\". The module is then updated with new source code generated by another MockCodeGenerator. Note that PyCodeWriter is designed for handling Python source code files only and cannot be used with other programming languages or file types.", "context": "\n    Generate the documentation for PyCodeWriter using the context shown below -\n  Building context for primary symbol - automata.core.coding.py_coding.writer.PyCodeWriter.InvalidArguments -\n  \n    Import Statements:\n      import logging\n      import os\n      import re\n      import subprocess\n      import numpy as np\n      import pypandoc\n      from typing import Dict, List, Optional, Union, cast\n      from redbaron import ClassNode, DefNode, Node, NodeList, RedBaron\n      from automata.core.coding.directory import DirectoryManager\n      from automata.core.coding.py_coding.navigation import (\n          find_all_function_and_class_syntax_tree_nodes,\n          find_import_syntax_tree_node_by_name,\n          find_import_syntax_tree_nodes,\n          find_syntax_tree_node,\n      )\n      from automata.core.coding.py_coding.retriever import PyCodeRetriever\n      from automata.core.symbol.symbol_types import Symbol, SymbolDocEmbedding\n      \n      # PyCodeWriter\n      \n      `PyCodeWriter` is a utility class responsible for writing Python code along with the Abstract Syntax Tree (AST) nodes. It interacts with a `PyCodeRetriever` instance to write and update Python source code files. The class offers methods to create new Python modules, update existing modules with new code, and delete specific code from an existing module.\n      \n      ## Related Symbols\n      \n      - `automata.core.coding.directory.DirectoryManager`\n      - `automata.core.coding.py_coding.retriever.PyCodeRetriever`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.symbol_types.SymbolDocEmbedding`\n      \n      ## Import Statements\n      \n      ```python\n      import logging\n      import os\n      import re\n      import subprocess\n      import numpy as np\n      import pypandoc\n      from typing import Dict, List, Optional, Union, cast\n      from redbaron import ClassNode, DefNode, Node, NodeList, RedBaron\n      from automata.core.coding.directory import DirectoryManager\n      from automata.core.coding.py_coding.navigation import (\n          find_all_function_and_class_syntax_tree_nodes,\n          find_import_syntax_tree_node_by_name,\n          find_import_syntax_tree_nodes,\n          find_syntax_tree_node,\n      )\n      from automata.core.coding.py_coding.retriever import PyCodeRetriever\n      from automata.core.symbol.symbol_types import Symbol, SymbolDocEmbedding\n      ```\n      \n      ## Example\n      \n      The following example demonstrates how to use `PyCodeWriter` to create, update, and write to a Python module.\n      \n      ```python\n      from automata.tests.unit.test_py_writer import python_writer, MockCodeGenerator\n      \n      # Create a mock code generator\n      mock_generator = MockCodeGenerator(\n          has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n      )\n      source_code = mock_generator.generate_code()\n      \n      # Instantiate a PythonWriter with a PyCodeRetriever\n      py_writer = python_writer()\n      \n      # Create a new Python module with the generated source code\n      py_writer.create_new_module(\"sample_module\", source_code, do_write=True)\n      \n      # Update the existing Python module with new source code\n      new_generator = MockCodeGenerator(\n          has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n      )\n      new_source_code = new_generator.generate_code()\n      py_writer.update_existing_module(\n          source_code=new_source_code, module_dotpath=\"sample_module\", do_write=True\n      )\n      ```\n      \n      ## Limitations\n      \n      `PyCodeWriter` relies on the directory structure provided by `DirectoryManager`. It cannot create or update Python source code files that are outside of the directory specified in the `base_path` used to initialize `DirectoryManager`. Additionally, `PyCodeWriter` handles only Python source code files and cannot be used for other programming languages or file types.\n      \n      ## Follow-up Questions:\n      \n      - What is the role of `PyCodeWriter` in writing documentation for Python modules?\n      - How does `PyCodeWriter` handle different code styles or formatting?\n      \n    Class Docstring:\n      Raised when invalid arguments are passed to a method\n      \n  Building context for related symbols -\n  \n    automata.core.coding.py_coding.writer.PyCodeWriter\n    \n        PyCodeWriter is a utility class designed for writing and updating Python code in the Abstract Syntax Tree (AST) format, enabling programmatic manipulation of Python elements such as classes, functions, and imports. The main functionality includes initializing with a PyCodeRetriever instance, creating a new module object from source code, updating an existing module, and writing the updated module to disk. However, PyCodeWriter's primary limitation is its reliance on RedBaron, which has known limitations and bugs, along with relatively low support in recent years. Additionally, error reporting in PyCodeWriter can be improved for a better user experience. \n        \n        ```python\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        from automata.core.coding.py_coding.writer import PyCodeWriter\n        \n        # Initialize the PyCodeWriter with a PyCodeRetriever instance\n        retriever = PyCodeRetriever()\n        writer = PyCodeWriter(retriever)\n        \n        # Create a new module object from source code\n        module_dotpath = \"my_module\"\n        source_code = \"def hello():\\n    print('Hello, World!')\\n\"\n        writer.create_new_module(module_dotpath, source_code)\n        \n        # Update the existing module by adding a new function\n        new_function_code = \"def goodbye():\\n    print('Goodbye, World!')\\n\"\n        writer.update_existing_module(module_dotpath, new_function_code, do_write=True)\n        ```\n        \n      Class Docstring:\n        A utility class for writing Python code along AST nodes\n        \n      Methods:\n        def __init__(self, python_retriever: PyCodeRetriever):\n                \"\"\"\n                Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n                Args:\n                    python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n                \"\"\"\n                self.code_retriever = python_retriever\n        \n            \n        create_new_module(self, module_dotpath: str, source_code: str, do_write: bool = False) -> None\n        \n        delete_from_existing__module(self, module_dotpath: str, object_dotpath: str, do_write: bool = False) -> None\n        \n        replace(match) -> None\n        \n        replace_newline_chars(input_str: str) -> str\n        \n        update_existing_module(self,\n                module_dotpath: str,\n                source_code: str,\n                disambiguator: Optional[str] = \"\",\n                do_write: bool = False,\n            ) -> None\n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator.generate_code\n    \n        def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            \n        \n    automata.core.coding.py_coding.retriever.PyCodeRetriever\n    \n        `PyCodeRetriever` is a class designed to fetch Python code from a specified module, enabling the retrieval of source code, docstrings, and source code without docstrings for a given module, class, or function/method. Through methods like `get_docstring`, `get_source_code`, and `get_source_code_without_docstrings`, it offers a way to programmatically analyze, extract, and comprehend Python projects. However, this class assumes a specific directory structure for the modules and relies on the RedBaron library for parsing, which may have limitations when parsing complex or unconventional code patterns.\n        \n        An example usage of `PyCodeRetriever` for retrieving the source code of a function from a specified module is as follows:\n        \n        ```python\n        from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        \n        module_tree_map = LazyModuleTreeMap.cached_default()\n        code_retriever = PyCodeRetriever(module_tree_map)\n        \n        module_dotpath = \"mymodule.example\"\n        object_path = \"ExampleClass.example_function\"\n        \n        source_code = code_retriever.get_source_code(module_dotpath, object_path)\n        print(source_code)\n        ```\n        \n        \n      Class Docstring:\n        Code retriever for fetching python code\n        \n      Methods:\n        def __init__(self, module_tree_map: LazyModuleTreeMap = LazyModuleTreeMap.cached_default()):\n                self.module_tree_map = module_tree_map\n        \n            \n        get_docstring(self, module_dotpath: str, object_path: Optional[str]) -> str\n        \n        get_docstring_from_node(node: Optional[FSTNode]) -> str\n        \n        get_source_code(self, module_dotpath: str, object_path: Optional[str] = None) -> str\n        \n        get_source_code_without_docstrings(self, module_dotpath: str, object_path: Optional[str]\n            ) -> str\n        \n    automata.tests.unit.test_py_writer.python_writer\n    \n        @pytest.fixture\n        def python_writer():\n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            return PyCodeWriter(retriever)\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_py_writer.test_create_update_write_module\n    \n        def test_create_update_write_module(python_writer):\n            mock_generator = MockCodeGenerator(\n                has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n            )\n            source_code = mock_generator.generate_code()\n            python_writer.create_new_module(\"sample_module_write\", source_code, do_write=True)\n            root_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            fpath = os.path.join(root_dir, \"sample_module_write.py\")\n            assert os.path.exists(fpath)\n            with open(fpath, \"r\") as f:\n                contents = f.read()\n                assert_code_lines_equal(source_code, contents)\n        \n            mock_generator_2 = MockCodeGenerator(\n                has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n            )\n            source_code_2 = mock_generator_2.generate_code()\n        \n            assert source_code != source_code_2\n            python_writer.update_existing_module(\n                source_code=source_code_2, module_dotpath=\"sample_module_write\", do_write=True\n            )\n        \n            with open(fpath, \"r\") as f:\n                contents = f.read()\n                assert_code_lines_equal(\"\\n\".join([source_code, source_code_2]), contents)\n        \n            os.remove(fpath)\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.test_write_and_retrieve_mock_code\n    \n        def test_write_and_retrieve_mock_code(python_writer):\n            mock_generator = MockCodeGenerator(\n                has_class=True,\n                has_method=True,\n                has_function=True,\n                has_import=True,\n                has_module_docstring=True,\n                has_class_docstring=True,\n                has_method_docstring=True,\n                has_function_docstring=True,\n            )\n            source_code = mock_generator.generate_code()\n            python_writer._create_module_from_source_code(\"sample_module_2\", source_code)\n        \n            python_writer._write_module_to_disk(\"sample_module_2\")\n        \n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            module_docstring = retriever.get_docstring(\"sample_module_2\", None)\n            assert module_docstring == mock_generator.module_docstring\n        \n        \n    automata.core.context.py_context.retriever.PyContextRetriever\n    \n        PyContextRetriever is a class that retrieves the context of a symbol in a Python project, helping generate documentation and understanding symbol relationships. It processes abstract syntax tree (AST) nodes and operates on a SymbolGraph with a PyContextRetrieverConfig object. To use it, create a SymbolGraph instance, instantiate the PyContextRetriever with the graph, process a symbol using the `process_symbol` method, and retrieve the context buffer. Note that PyContextRetriever relies on accurate SymbolGraph and PyContextRetrieverConfig inputs; errors in these may cause issues when processing symbols. \n        \n        Usage Example:\n        \n        ```python\n        from automata.core.context.py_context.retriever import PyContextRetriever\n        from automata.core.symbol.graph import SymbolGraph\n        \n        graph = SymbolGraph()\n        py_context_retriever = PyContextRetriever(graph)\n        symbol = some_symbol\n        \n        # Process the context of the symbol\n        py_context_retriever.process_symbol(symbol)\n        \n        # Retrieve the context buffer\n        context_buffer = py_context_retriever.get_context_buffer()\n        ```\n        \n      Class Docstring:\n        The PyContextRetriever is used to retrieve the context of a symbol in a Python project\n        \n      Methods:\n        IndentManager(self) -> None\n        \n        def __init__(\n                self,\n                graph: SymbolGraph,\n                config: PyContextRetrieverConfig = PyContextRetrieverConfig(),\n                doc_embedding_db: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                Args:\n                    graph (SymbolGraph): The symbol graph to use\n                    config (PyContextRetrieverConfig): The configuration to use\n                \"\"\"\n                self.graph = graph\n                self.config = config\n                self.indent_level = 0\n                self.doc_embedding_db = doc_embedding_db\n                self.encoding = tiktoken.encoding_for_model(self.config.model_name)\n        \n                self.reset()\n        \n            \n        get_context_buffer(self) -> str\n        \n        indent() -> str\n        \n        process_ast(self, symbol: Symbol) -> None\n        \n        process_docstring(self, ast_object: RedBaron) -> None\n        \n        process_documentation(self, symbol: Symbol, is_main_symbol: bool) -> None\n        \n        process_headline(self, symbol: Symbol) -> None\n        \n        process_imports(self, symbol: Symbol) -> None\n        \n        process_message(self, message: str) -> None\n        \n        process_method(self, method: RedBaron, is_main_symbol: bool) -> None\n        \n        process_symbol(self,\n                symbol: Symbol,\n                related_symbols: List[Symbol] = [],\n            ) -> None\n        \n        reset(self) -> None\n        \n    automata.core.coding.py_coding.writer.PyDocWriter\n    \n        PyDocWriter is a Python class designed to create documentation for modules, classes, and methods in a Python project using the Restructured Text (reST) format. It generates reST files for each key in the documentation dictionary, organizes them in the output directory, and allows customization of the output directory. However, PyDocWriter has certain limitations, such as assuming camel case naming convention for input symbols and lacking a fully functional summary generation function (`generate_summary`). An example usage of PyDocWriter can be seen below:\n        \n        ```python\n        from automata.core.coding.py_coding.writer import PyDocWriter\n        \n        base_path = \"path/to/project\"\n        docs_dir = \"path/to/output/docs\"\n        docs = {...}  # The documentation dictionary\n        symbols = [...]  # The symbols of the documentation dictionary\n        \n        doc_writer = PyDocWriter(base_path)\n        doc_writer.write_documentation(docs, symbols, docs_dir)\n        ```\n        \n      Class Docstring:\n        A class to write documentation for Python modules\n        \n      Methods:\n        def __init__(self, base_path: str):\n                \"\"\"\n                Args:\n                    base_path (str): The base path of the project\n                \"\"\"\n                self.base_path = base_path\n                self.directory_manager = DirectoryManager(base_path)\n        \n            \n        camel_to_snake(name: str) -> str\n        \n        check_camel_case(text: str) -> bool\n        \n        generate_index_files(self, docs_dir: str) -> None\n        \n        generate_module_summary(self, module_dir: str) -> None\n        \n        generate_rst_files(self, docs: Dict[Symbol, SymbolDocEmbedding], symbols: List[Symbol], docs_dir: str) -> None\n        \n        generate_summary(content: str) -> str\n        \n        get_payload(directory: str) -> str\n        \n        write_documentation(self, docs: Dict[Symbol, SymbolDocEmbedding], symbols: List[Symbol], docs_dir: str) -> None\n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.coding.py_coding.writer`/PyCodeWriter#ModuleNotFound#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.coding.py_coding.writer", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "PyCodeWriter", "suffix": 2, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "ModuleNotFound", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# PyCodeWriter\n\n`PyCodeWriter` is a utility class for writing Python code along Abstract Syntax Tree (AST) nodes. It provides methods for creating, updating, deleting, and manipulating source code in existing Python modules, as well as generating documentation. Working alongside the `PyCodeRetriever`, the `PyCodeWriter` allows for seamless manipulation and extraction of Python code.\n\n## Overview\n\nThe main functionality of `PyCodeWriter` is to work with source code within Python modules. It uses a `PyCodeRetriever` instance to handle code retrieval and manipulation. With this class, you can create new modules, update and delete from existing modules, and manage docstrings and import statements. Given the highly abstract nature of AST nodes, it is useful for code introspection and source-to-source transformations.\n\n## Related Symbols\n\n- `automata.core.coding.py_coding.retriever.PyCodeRetriever`\n- `automata.core.coding.directory.DirectoryManager`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.symbol_types.SymbolDocEmbedding`\n\n## Example\n\nThe following example demonstrates how to create an instance of `PyCodeWriter` and use it to create a new module.\n\n```python\nfrom automata.core.coding.py_coding.retriever import PyCodeRetriever\nfrom automata.core.coding.py_coding.writer import PyCodeWriter\n\npython_retriever = PyCodeRetriever()  # create a PyCodeRetriever instance\ncode_writer = PyCodeWriter(python_retriever)  # initialize PyCodeWriter with the PyCodeRetriever instance\n\nsource_code = \"\"\"def foo():\n    return 'Hello, world!'\n\"\"\"\ncode_writer.create_new_module(\"sample_module\", source_code, do_write=True)\n```\n\n## Limitations\n\nThe primary limitation of the `PyCodeWriter` is that it assumes source code is structured in a certain way and adheres to certain coding patterns. It may not handle edge cases or unconventional coding structures well, resulting in either unexpected behavior or loss of functionality. An example of such a limitation is the handling of character encodings.\n\n## Follow-up Questions:\n\n- How does `PyCodeWriter` handle edge cases in the provided source code?\n- Are there any known issues or limitations with the manipulation of source code that may impact its functionality?\n- How does `PyCodeWriter` ensure compatibility with different Python versions and language features?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class ModuleNotFound(Exception):\n        \"\"\"Raised when a module is not found in the module dictionary\"\"\"\n\n        pass\n\n    ", "summary": "PyCodeWriter is a utility class designed for writing and manipulating Python code using Abstract Syntax Tree (AST) nodes. In conjunction with PyCodeRetriever, it allows for easy creation, updating, and deletion of source code in Python modules, as well as managing docstrings and import statements. However, PyCodeWriter assumes a certain structure and coding patterns in source code which may limit its handling of edge cases or unconventional coding structures. An example of using PyCodeWriter to create a new module is shown below:\n\n```python\nfrom automata.core.coding.py_coding.retriever import PyCodeRetriever\nfrom automata.core.coding.py_coding.writer import PyCodeWriter\n\npython_retriever = PyCodeRetriever()  # create a PyCodeRetriever instance\ncode_writer = PyCodeWriter(python_retriever)  # initialize PyCodeWriter with the PyCodeRetriever instance\n\nsource_code = \"\"\"def foo():\n    return 'Hello, world!'\n\"\"\"\ncode_writer.create_new_module(\"sample_module\", source_code, do_write=True)\n```", "context": "\n    Generate the documentation for PyCodeWriter using the context shown below -\n  Building context for primary symbol - automata.core.coding.py_coding.writer.PyCodeWriter.ModuleNotFound -\n  \n    Import Statements:\n      import logging\n      import os\n      import re\n      import subprocess\n      import numpy as np\n      import pypandoc\n      from typing import Dict, List, Optional, Union, cast\n      from redbaron import ClassNode, DefNode, Node, NodeList, RedBaron\n      from automata.core.coding.directory import DirectoryManager\n      from automata.core.coding.py_coding.navigation import (\n          find_all_function_and_class_syntax_tree_nodes,\n          find_import_syntax_tree_node_by_name,\n          find_import_syntax_tree_nodes,\n          find_syntax_tree_node,\n      )\n      from automata.core.coding.py_coding.retriever import PyCodeRetriever\n      from automata.core.symbol.symbol_types import Symbol, SymbolDocEmbedding\n      \n      # PyCodeWriter\n      \n      `PyCodeWriter` is a utility class for writing Python code along Abstract Syntax Tree (AST) nodes. It provides methods for creating, updating, deleting, and manipulating source code in existing Python modules, as well as generating documentation. Working alongside the `PyCodeRetriever`, the `PyCodeWriter` allows for seamless manipulation and extraction of Python code.\n      \n      ## Overview\n      \n      The main functionality of `PyCodeWriter` is to work with source code within Python modules. It uses a `PyCodeRetriever` instance to handle code retrieval and manipulation. With this class, you can create new modules, update and delete from existing modules, and manage docstrings and import statements. Given the highly abstract nature of AST nodes, it is useful for code introspection and source-to-source transformations.\n      \n      ## Related Symbols\n      \n      - `automata.core.coding.py_coding.retriever.PyCodeRetriever`\n      - `automata.core.coding.directory.DirectoryManager`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.symbol_types.SymbolDocEmbedding`\n      \n      ## Example\n      \n      The following example demonstrates how to create an instance of `PyCodeWriter` and use it to create a new module.\n      \n      ```python\n      from automata.core.coding.py_coding.retriever import PyCodeRetriever\n      from automata.core.coding.py_coding.writer import PyCodeWriter\n      \n      python_retriever = PyCodeRetriever()  # create a PyCodeRetriever instance\n      code_writer = PyCodeWriter(python_retriever)  # initialize PyCodeWriter with the PyCodeRetriever instance\n      \n      source_code = \"\"\"def foo():\n          return 'Hello, world!'\n      \"\"\"\n      code_writer.create_new_module(\"sample_module\", source_code, do_write=True)\n      ```\n      \n      ## Limitations\n      \n      The primary limitation of the `PyCodeWriter` is that it assumes source code is structured in a certain way and adheres to certain coding patterns. It may not handle edge cases or unconventional coding structures well, resulting in either unexpected behavior or loss of functionality. An example of such a limitation is the handling of character encodings.\n      \n      ## Follow-up Questions:\n      \n      - How does `PyCodeWriter` handle edge cases in the provided source code?\n      - Are there any known issues or limitations with the manipulation of source code that may impact its functionality?\n      - How does `PyCodeWriter` ensure compatibility with different Python versions and language features?\n      \n    Class Docstring:\n      Raised when a module is not found in the module dictionary\n      \n  Building context for related symbols -\n  \n    automata.core.coding.py_coding.writer.PyCodeWriter\n    \n        PyCodeWriter is a utility class designed for writing and updating Python code in the Abstract Syntax Tree (AST) format, enabling programmatic manipulation of Python elements such as classes, functions, and imports. The main functionality includes initializing with a PyCodeRetriever instance, creating a new module object from source code, updating an existing module, and writing the updated module to disk. However, PyCodeWriter's primary limitation is its reliance on RedBaron, which has known limitations and bugs, along with relatively low support in recent years. Additionally, error reporting in PyCodeWriter can be improved for a better user experience. \n        \n        ```python\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        from automata.core.coding.py_coding.writer import PyCodeWriter\n        \n        # Initialize the PyCodeWriter with a PyCodeRetriever instance\n        retriever = PyCodeRetriever()\n        writer = PyCodeWriter(retriever)\n        \n        # Create a new module object from source code\n        module_dotpath = \"my_module\"\n        source_code = \"def hello():\\n    print('Hello, World!')\\n\"\n        writer.create_new_module(module_dotpath, source_code)\n        \n        # Update the existing module by adding a new function\n        new_function_code = \"def goodbye():\\n    print('Goodbye, World!')\\n\"\n        writer.update_existing_module(module_dotpath, new_function_code, do_write=True)\n        ```\n        \n      Class Docstring:\n        A utility class for writing Python code along AST nodes\n        \n      Methods:\n        def __init__(self, python_retriever: PyCodeRetriever):\n                \"\"\"\n                Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n                Args:\n                    python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n                \"\"\"\n                self.code_retriever = python_retriever\n        \n            \n        create_new_module(self, module_dotpath: str, source_code: str, do_write: bool = False) -> None\n        \n        delete_from_existing__module(self, module_dotpath: str, object_dotpath: str, do_write: bool = False) -> None\n        \n        replace(match) -> None\n        \n        replace_newline_chars(input_str: str) -> str\n        \n        update_existing_module(self,\n                module_dotpath: str,\n                source_code: str,\n                disambiguator: Optional[str] = \"\",\n                do_write: bool = False,\n            ) -> None\n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator.generate_code\n    \n        def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            \n        \n    automata.core.coding.py_coding.retriever.PyCodeRetriever\n    \n        `PyCodeRetriever` is a class designed to fetch Python code from a specified module, enabling the retrieval of source code, docstrings, and source code without docstrings for a given module, class, or function/method. Through methods like `get_docstring`, `get_source_code`, and `get_source_code_without_docstrings`, it offers a way to programmatically analyze, extract, and comprehend Python projects. However, this class assumes a specific directory structure for the modules and relies on the RedBaron library for parsing, which may have limitations when parsing complex or unconventional code patterns.\n        \n        An example usage of `PyCodeRetriever` for retrieving the source code of a function from a specified module is as follows:\n        \n        ```python\n        from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        \n        module_tree_map = LazyModuleTreeMap.cached_default()\n        code_retriever = PyCodeRetriever(module_tree_map)\n        \n        module_dotpath = \"mymodule.example\"\n        object_path = \"ExampleClass.example_function\"\n        \n        source_code = code_retriever.get_source_code(module_dotpath, object_path)\n        print(source_code)\n        ```\n        \n        \n      Class Docstring:\n        Code retriever for fetching python code\n        \n      Methods:\n        def __init__(self, module_tree_map: LazyModuleTreeMap = LazyModuleTreeMap.cached_default()):\n                self.module_tree_map = module_tree_map\n        \n            \n        get_docstring(self, module_dotpath: str, object_path: Optional[str]) -> str\n        \n        get_docstring_from_node(node: Optional[FSTNode]) -> str\n        \n        get_source_code(self, module_dotpath: str, object_path: Optional[str] = None) -> str\n        \n        get_source_code_without_docstrings(self, module_dotpath: str, object_path: Optional[str]\n            ) -> str\n        \n    automata.tests.unit.test_py_writer.python_writer\n    \n        @pytest.fixture\n        def python_writer():\n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            return PyCodeWriter(retriever)\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_py_writer.test_create_update_write_module\n    \n        def test_create_update_write_module(python_writer):\n            mock_generator = MockCodeGenerator(\n                has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n            )\n            source_code = mock_generator.generate_code()\n            python_writer.create_new_module(\"sample_module_write\", source_code, do_write=True)\n            root_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            fpath = os.path.join(root_dir, \"sample_module_write.py\")\n            assert os.path.exists(fpath)\n            with open(fpath, \"r\") as f:\n                contents = f.read()\n                assert_code_lines_equal(source_code, contents)\n        \n            mock_generator_2 = MockCodeGenerator(\n                has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n            )\n            source_code_2 = mock_generator_2.generate_code()\n        \n            assert source_code != source_code_2\n            python_writer.update_existing_module(\n                source_code=source_code_2, module_dotpath=\"sample_module_write\", do_write=True\n            )\n        \n            with open(fpath, \"r\") as f:\n                contents = f.read()\n                assert_code_lines_equal(\"\\n\".join([source_code, source_code_2]), contents)\n        \n            os.remove(fpath)\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.test_write_and_retrieve_mock_code\n    \n        def test_write_and_retrieve_mock_code(python_writer):\n            mock_generator = MockCodeGenerator(\n                has_class=True,\n                has_method=True,\n                has_function=True,\n                has_import=True,\n                has_module_docstring=True,\n                has_class_docstring=True,\n                has_method_docstring=True,\n                has_function_docstring=True,\n            )\n            source_code = mock_generator.generate_code()\n            python_writer._create_module_from_source_code(\"sample_module_2\", source_code)\n        \n            python_writer._write_module_to_disk(\"sample_module_2\")\n        \n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            module_docstring = retriever.get_docstring(\"sample_module_2\", None)\n            assert module_docstring == mock_generator.module_docstring\n        \n        \n    automata.core.context.py_context.retriever.PyContextRetriever\n    \n        PyContextRetriever is a class that retrieves the context of a symbol in a Python project, helping generate documentation and understanding symbol relationships. It processes abstract syntax tree (AST) nodes and operates on a SymbolGraph with a PyContextRetrieverConfig object. To use it, create a SymbolGraph instance, instantiate the PyContextRetriever with the graph, process a symbol using the `process_symbol` method, and retrieve the context buffer. Note that PyContextRetriever relies on accurate SymbolGraph and PyContextRetrieverConfig inputs; errors in these may cause issues when processing symbols. \n        \n        Usage Example:\n        \n        ```python\n        from automata.core.context.py_context.retriever import PyContextRetriever\n        from automata.core.symbol.graph import SymbolGraph\n        \n        graph = SymbolGraph()\n        py_context_retriever = PyContextRetriever(graph)\n        symbol = some_symbol\n        \n        # Process the context of the symbol\n        py_context_retriever.process_symbol(symbol)\n        \n        # Retrieve the context buffer\n        context_buffer = py_context_retriever.get_context_buffer()\n        ```\n        \n      Class Docstring:\n        The PyContextRetriever is used to retrieve the context of a symbol in a Python project\n        \n      Methods:\n        IndentManager(self) -> None\n        \n        def __init__(\n                self,\n                graph: SymbolGraph,\n                config: PyContextRetrieverConfig = PyContextRetrieverConfig(),\n                doc_embedding_db: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                Args:\n                    graph (SymbolGraph): The symbol graph to use\n                    config (PyContextRetrieverConfig): The configuration to use\n                \"\"\"\n                self.graph = graph\n                self.config = config\n                self.indent_level = 0\n                self.doc_embedding_db = doc_embedding_db\n                self.encoding = tiktoken.encoding_for_model(self.config.model_name)\n        \n                self.reset()\n        \n            \n        get_context_buffer(self) -> str\n        \n        indent() -> str\n        \n        process_ast(self, symbol: Symbol) -> None\n        \n        process_docstring(self, ast_object: RedBaron) -> None\n        \n        process_documentation(self, symbol: Symbol, is_main_symbol: bool) -> None\n        \n        process_headline(self, symbol: Symbol) -> None\n        \n        process_imports(self, symbol: Symbol) -> None\n        \n        process_message(self, message: str) -> None\n        \n        process_method(self, method: RedBaron, is_main_symbol: bool) -> None\n        \n        process_symbol(self,\n                symbol: Symbol,\n                related_symbols: List[Symbol] = [],\n            ) -> None\n        \n        reset(self) -> None\n        \n    automata.core.coding.py_coding.writer.PyDocWriter\n    \n        PyDocWriter is a Python class designed to create documentation for modules, classes, and methods in a Python project using the Restructured Text (reST) format. It generates reST files for each key in the documentation dictionary, organizes them in the output directory, and allows customization of the output directory. However, PyDocWriter has certain limitations, such as assuming camel case naming convention for input symbols and lacking a fully functional summary generation function (`generate_summary`). An example usage of PyDocWriter can be seen below:\n        \n        ```python\n        from automata.core.coding.py_coding.writer import PyDocWriter\n        \n        base_path = \"path/to/project\"\n        docs_dir = \"path/to/output/docs\"\n        docs = {...}  # The documentation dictionary\n        symbols = [...]  # The symbols of the documentation dictionary\n        \n        doc_writer = PyDocWriter(base_path)\n        doc_writer.write_documentation(docs, symbols, docs_dir)\n        ```\n        \n      Class Docstring:\n        A class to write documentation for Python modules\n        \n      Methods:\n        def __init__(self, base_path: str):\n                \"\"\"\n                Args:\n                    base_path (str): The base path of the project\n                \"\"\"\n                self.base_path = base_path\n                self.directory_manager = DirectoryManager(base_path)\n        \n            \n        camel_to_snake(name: str) -> str\n        \n        check_camel_case(text: str) -> bool\n        \n        generate_index_files(self, docs_dir: str) -> None\n        \n        generate_module_summary(self, module_dir: str) -> None\n        \n        generate_rst_files(self, docs: Dict[Symbol, SymbolDocEmbedding], symbols: List[Symbol], docs_dir: str) -> None\n        \n        generate_summary(content: str) -> str\n        \n        get_payload(directory: str) -> str\n        \n        write_documentation(self, docs: Dict[Symbol, SymbolDocEmbedding], symbols: List[Symbol], docs_dir: str) -> None\n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.coding.py_coding.writer`/PyDocWriter#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.coding.py_coding.writer", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "PyDocWriter", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# PyDocWriter\n\n`PyDocWriter` is a class to write documentation for Python modules. It helps in generating the documentation files for specified modules or symbols in the Restructured Text (reST) format.\n\n## Overview\n\n`PyDocWriter` provides methods to generate documentation for the modules, classes, and methods within a Python project. It generates reST files for each key in the documentation dictionary and creates directory indices for reST files. You can customize the output directory for the generated documentation.\n\n## Related Symbols\n\n- `automata.core.coding.directory.DirectoryManager`\n- `automata.core.coding.py_coding.retriever.PyCodeRetriever`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.symbol_types.SymbolDocEmbedding`\n\n## Example\n\nThe following example demonstrates how to create an instance of `PyDocWriter` and write documentation for the specified symbols.\n\n```python\nfrom automata.core.coding.py_coding.writer import PyDocWriter\n\nbase_path = \"path/to/project\"\ndocs_dir = \"path/to/output/docs\"\ndocs = {...}  # The documentation dictionary\nsymbols = [...]  # The symbols of the documentation dictionary\n\ndoc_writer = PyDocWriter(base_path)\ndoc_writer.write_documentation(docs, symbols, docs_dir)\n```\n\n## Limitations\n\nThe `PyDocWriter` assumes that the input symbols follow the camel case naming convention and will not generate documentation for symbols that do not meet this requirement. Additionally, the summary generation function (`generate_summary`) is currently a placeholder and does not generate a meaningful summary from the content.\n\n## Follow-up Questions:\n\n- How can we improve the `generate_summary` function to generate meaningful summaries from the content?\n- Are there any additional features planned for the `PyDocWriter` class?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class PyDocWriter:\n    \"\"\"A class to write documentation for Python modules\"\"\"\n\n    def __init__(self, base_path: str):\n        \"\"\"\n        Args:\n            base_path (str): The base path of the project\n        \"\"\"\n        self.base_path = base_path\n        self.directory_manager = DirectoryManager(base_path)\n\n    def generate_module_summary(self, module_dir: str):\n        \"\"\"\n        Function to generate a module-level summary. Here, we just assume that\n        all the .rst files in a directory correspond to the same module.\n        We read these files, use their content to generate a summary using\n        a language model and write this summary to the module's index.rst file.\n\n        Args:\n            module_dir (str): The directory of the module\n        \"\"\"\n        summary = \"\"\n        for file in self.directory_manager.get_files_in_dir(module_dir):\n            if file.endswith(\".rst\") and file != \"index.rst\":\n                with open(os.path.join(module_dir, file), \"r\") as f:\n                    content = f.read()\n                    summary += content + \"\\n\\n\"\n\n        summary = self.generate_summary(summary)\n\n        with open(os.path.join(module_dir, \"index.rst\"), \"a\") as f:\n            f.write(\"\\n\\n\" + summary)\n\n    def generate_rst_files(\n        self, docs: Dict[Symbol, SymbolDocEmbedding], symbols: List[Symbol], docs_dir: str\n    ):\n        \"\"\"\n        Generate individual .rst files for each key (a key represents a module)\n            and updates the file structure.\n\n        Args:\n            docs (Dict[Any, Any]): The documentation dictionary\n            symbols (List[Any]): The symbols of the documentation dictionary\n            docs_dir (str): The output directory for the docs\n        \"\"\"\n        for symbol in np.array(symbols):\n            symbol_name = symbol.descriptors[-1].name\n\n            if symbol_name[0] == \"_\" or not PyDocWriter.check_camel_case(symbol_name):\n                continue\n\n            snaked_symbol_name = PyDocWriter.camel_to_snake(symbol_name)\n            module_dir = \"/\".join(symbol.dotpath.split(\".\")[1:-2])\n\n            new_module_dir = os.path.join(docs_dir, module_dir)\n            self.directory_manager.ensure_directory_exists(new_module_dir)\n\n            with open(os.path.join(new_module_dir, f\"{snaked_symbol_name}.rst\"), \"w\") as f:\n                try:\n                    doc_md_string = docs[symbol].embedding_source\n                    rst_string = pypandoc.convert_text(doc_md_string, \"rst\", format=\"md\")\n                    f.write(rst_string)\n                except Exception as e:\n                    print(f\"Error converting {symbol_name} to rst: {e}\")\n\n    def generate_index_files(self, docs_dir: str):\n        \"\"\"\n        Generate index files for each directory that\n            contains .rst files or subdirectories.\n\n        Args:\n            docs_dir (str): The output directory for the docs\n        \"\"\"\n        doc_directory_manager = DirectoryManager(docs_dir)\n        for root, dirs, _ in os.walk(docs_dir, topdown=False):\n            root_relative_to_base = os.path.relpath(root, start=docs_dir)\n            files = doc_directory_manager.get_files_in_dir(root_relative_to_base)\n            dirs = doc_directory_manager.get_subdirectories(root_relative_to_base)\n\n            rst_files = [f for f in files if f.endswith(\".rst\")]\n            root_dir_node = doc_directory_manager._get_node_for_path(\n                doc_directory_manager.root, root_relative_to_base\n            )\n\n            if rst_files or dirs:\n                with open(os.path.join(root, \"index.rst\"), \"w\") as index_file:\n                    index_file.write(PyDocWriter.get_payload(root))\n\n                    index_file.write(\".. toctree::\\n\")\n                    index_file.write(\n                        \"   :maxdepth: 2\\n\\n\"\n                        if not root_dir_node or root_dir_node.is_root_dir()  # type: ignore\n                        else \"   :maxdepth: 1\\n\\n\"\n                    )\n\n                    for sub_dir_ in sorted(dirs):\n                        index_file.write(f\"   {sub_dir_}/index\\n\")\n                    for file in sorted(rst_files):\n                        if file != \"index.rst\":\n                            index_file.write(f\"   {file[:-4]}\\n\")  # Remove .rst extension\n\n                self.generate_module_summary(root)\n\n    def write_documentation(\n        self, docs: Dict[Symbol, SymbolDocEmbedding], symbols: List[Symbol], docs_dir: str\n    ):\n        \"\"\"\n        Generate the full documentation given the symbols and a directory.\n\n        Args:\n            docs (Dict[Any, Any]): The documentation dictionary\n            symbols (List[Any]): The symbols of the documentation dictionary\n            docs_dir (str): The relative directory\n        \"\"\"\n        self.generate_rst_files(docs, symbols, docs_dir)\n        self.generate_index_files(docs_dir)\n\n    @staticmethod\n    def get_payload(directory: str) -> str:\n        \"\"\"Returns a formatted string for the main body of the index.rst file.\"\"\"\n        payload = f\"\"\"{os.path.basename(directory)}\n{\"=\" * len(os.path.basename(directory))}\n\n**Automata** is a Python library for autonomous agents.\n\nCheck out the :doc:`usage` section for further information, including\nhow to :ref:`installation` the project.\n\n.. note::\n\n\"\"\"\n        return payload\n\n    @staticmethod\n    def generate_summary(content: str) -> str:\n        \"\"\"This method should implement the logic to generate summary from the content.\"\"\"\n        # TODO: Implement summary generation function.\n        return \"Summary of content\"\n\n    @staticmethod\n    def camel_to_snake(name: str) -> str:\n        \"\"\"\n        Converts a camel case string to snake case\n\n        Args:\n            name (str): The string to convert\n\n        Returns:\n            str: The converted string\n        \"\"\"\n\n        name = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", name)\n        name = re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", name)\n        return name.lower()\n\n    @staticmethod\n    def check_camel_case(text: str) -> bool:\n        \"\"\"\n        Checks if a string is camel case\n\n        Args:\n            text (str): The string to check\n\n        Returns:\n            bool: True if the string is camel case, False otherwise\n        \"\"\"\n        return text != text.lower() and text != text.upper() and \"_\" not in text\n", "summary": "PyDocWriter is a class designed to write documentation for Python modules in the Restructured Text (reST) format, providing methods to generate documentation for modules, classes, and methods within a given project. The generated reST files are organized with directory indices, and users can customize the output directory. However, PyDocWriter assumes that input symbols follow the camel case naming convention and its summary generation function (`generate_summary`) is still a placeholder.\n\nThe following example demonstrates the usage of PyDocWriter:\n```python\nfrom automata.core.coding.py_coding.writer import PyDocWriter\n\nbase_path = \"path/to/project\"\ndocs_dir = \"path/to/output/docs\"\ndocs = {...}  # The documentation dictionary\nsymbols = [...]  # The symbols of the documentation dictionary\n\ndoc_writer = PyDocWriter(base_path)\ndoc_writer.write_documentation(docs, symbols, docs_dir)\n```\nFuture improvements may include generating meaningful summaries from the content and possible additional features for the `PyDocWriter` class.", "context": "\n    Generate the documentation for PyDocWriter using the context shown below -\n  Building context for primary symbol - automata.core.coding.py_coding.writer.PyDocWriter -\n  \n    Import Statements:\n      import logging\n      import os\n      import re\n      import subprocess\n      import numpy as np\n      import pypandoc\n      from typing import Dict, List, Optional, Union, cast\n      from redbaron import ClassNode, DefNode, Node, NodeList, RedBaron\n      from automata.core.coding.directory import DirectoryManager\n      from automata.core.coding.py_coding.navigation import (\n          find_all_function_and_class_syntax_tree_nodes,\n          find_import_syntax_tree_node_by_name,\n          find_import_syntax_tree_nodes,\n          find_syntax_tree_node,\n      )\n      from automata.core.coding.py_coding.retriever import PyCodeRetriever\n      from automata.core.symbol.symbol_types import Symbol, SymbolDocEmbedding\n      \n      # PyDocWriter\n      \n      `PyDocWriter` is a class to write documentation for Python modules. It helps in generating the documentation files for specified modules or symbols in the Restructured Text (reST) format.\n      \n      ## Overview\n      \n      `PyDocWriter` provides methods to generate documentation for the modules, classes, and methods within a Python project. It generates reST files for each key in the documentation dictionary and creates directory indices for reST files. You can customize the output directory for the generated documentation.\n      \n      ## Related Symbols\n      \n      - `automata.core.coding.directory.DirectoryManager`\n      - `automata.core.coding.py_coding.retriever.PyCodeRetriever`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.symbol_types.SymbolDocEmbedding`\n      \n      ## Example\n      \n      The following example demonstrates how to create an instance of `PyDocWriter` and write documentation for the specified symbols.\n      \n      ```python\n      from automata.core.coding.py_coding.writer import PyDocWriter\n      \n      base_path = \"path/to/project\"\n      docs_dir = \"path/to/output/docs\"\n      docs = {...}  # The documentation dictionary\n      symbols = [...]  # The symbols of the documentation dictionary\n      \n      doc_writer = PyDocWriter(base_path)\n      doc_writer.write_documentation(docs, symbols, docs_dir)\n      ```\n      \n      ## Limitations\n      \n      The `PyDocWriter` assumes that the input symbols follow the camel case naming convention and will not generate documentation for symbols that do not meet this requirement. Additionally, the summary generation function (`generate_summary`) is currently a placeholder and does not generate a meaningful summary from the content.\n      \n      ## Follow-up Questions:\n      \n      - How can we improve the `generate_summary` function to generate meaningful summaries from the content?\n      - Are there any additional features planned for the `PyDocWriter` class?\n      \n    Class Docstring:\n      A class to write documentation for Python modules\n      \n    Methods:\n      def __init__(self, base_path: str):\n              \"\"\"\n              Args:\n                  base_path (str): The base path of the project\n              \"\"\"\n              self.base_path = base_path\n              self.directory_manager = DirectoryManager(base_path)\n      \n          \n      @staticmethod\n          def camel_to_snake(name: str) -> str:\n              \"\"\"\n              Converts a camel case string to snake case\n      \n              Args:\n                  name (str): The string to convert\n      \n              Returns:\n                  str: The converted string\n              \"\"\"\n      \n              name = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", name)\n              name = re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", name)\n              return name.lower()\n      \n          \n      @staticmethod\n          def check_camel_case(text: str) -> bool:\n              \"\"\"\n              Checks if a string is camel case\n      \n              Args:\n                  text (str): The string to check\n      \n              Returns:\n                  bool: True if the string is camel case, False otherwise\n              \"\"\"\n              return text != text.lower() and text != text.upper() and \"_\" not in text\n      \n      def generate_index_files(self, docs_dir: str):\n              \"\"\"\n              Generate index files for each directory that\n                  contains .rst files or subdirectories.\n      \n              Args:\n                  docs_dir (str): The output directory for the docs\n              \"\"\"\n              doc_directory_manager = DirectoryManager(docs_dir)\n              for root, dirs, _ in os.walk(docs_dir, topdown=False):\n                  root_relative_to_base = os.path.relpath(root, start=docs_dir)\n                  files = doc_directory_manager.get_files_in_dir(root_relative_to_base)\n                  dirs = doc_directory_manager.get_subdirectories(root_relative_to_base)\n      \n                  rst_files = [f for f in files if f.endswith(\".rst\")]\n                  root_dir_node = doc_directory_manager._get_node_for_path(\n                      doc_directory_manager.root, root_relative_to_base\n                  )\n      \n                  if rst_files or dirs:\n                      with open(os.path.join(root, \"index.rst\"), \"w\") as index_file:\n                          index_file.write(PyDocWriter.get_payload(root))\n      \n                          index_file.write(\".. toctree::\\n\")\n                          index_file.write(\n                              \"   :maxdepth: 2\\n\\n\"\n                              if not root_dir_node or root_dir_node.is_root_dir()  # type: ignore\n                              else \"   :maxdepth: 1\\n\\n\"\n                          )\n      \n                          for sub_dir_ in sorted(dirs):\n                              index_file.write(f\"   {sub_dir_}/index\\n\")\n                          for file in sorted(rst_files):\n                              if file != \"index.rst\":\n                                  index_file.write(f\"   {file[:-4]}\\n\")  # Remove .rst extension\n      \n                      self.generate_module_summary(root)\n      \n          \n      def generate_module_summary(self, module_dir: str):\n              \"\"\"\n              Function to generate a module-level summary. Here, we just assume that\n              all the .rst files in a directory correspond to the same module.\n              We read these files, use their content to generate a summary using\n              a language model and write this summary to the module's index.rst file.\n      \n              Args:\n                  module_dir (str): The directory of the module\n              \"\"\"\n              summary = \"\"\n              for file in self.directory_manager.get_files_in_dir(module_dir):\n                  if file.endswith(\".rst\") and file != \"index.rst\":\n                      with open(os.path.join(module_dir, file), \"r\") as f:\n                          content = f.read()\n                          summary += content + \"\\n\\n\"\n      \n              summary = self.generate_summary(summary)\n      \n              with open(os.path.join(module_dir, \"index.rst\"), \"a\") as f:\n                  f.write(\"\\n\\n\" + summary)\n      \n          \n      def generate_rst_files(\n              self, docs: Dict[Symbol, SymbolDocEmbedding], symbols: List[Symbol], docs_dir: str\n          ):\n              \"\"\"\n              Generate individual .rst files for each key (a key represents a module)\n                  and updates the file structure.\n      \n              Args:\n                  docs (Dict[Any, Any]): The documentation dictionary\n                  symbols (List[Any]): The symbols of the documentation dictionary\n                  docs_dir (str): The output directory for the docs\n              \"\"\"\n              for symbol in np.array(symbols):\n                  symbol_name = symbol.descriptors[-1].name\n      \n                  if symbol_name[0] == \"_\" or not PyDocWriter.check_camel_case(symbol_name):\n                      continue\n      \n                  snaked_symbol_name = PyDocWriter.camel_to_snake(symbol_name)\n                  module_dir = \"/\".join(symbol.dotpath.split(\".\")[1:-2])\n      \n                  new_module_dir = os.path.join(docs_dir, module_dir)\n                  self.directory_manager.ensure_directory_exists(new_module_dir)\n      \n                  with open(os.path.join(new_module_dir, f\"{snaked_symbol_name}.rst\"), \"w\") as f:\n                      try:\n                          doc_md_string = docs[symbol].embedding_source\n                          rst_string = pypandoc.convert_text(doc_md_string, \"rst\", format=\"md\")\n                          f.write(rst_string)\n                      except Exception as e:\n                          print(f\"Error converting {symbol_name} to rst: {e}\")\n      \n          \n      @staticmethod\n          def generate_summary(content: str) -> str:\n              \"\"\"This method should implement the logic to generate summary from the content.\"\"\"\n              # TODO: Implement summary generation function.\n              return \"Summary of content\"\n      \n          \n      @staticmethod\n          def get_payload(directory: str) -> str:\n              \"\"\"Returns a formatted string for the main body of the index.rst file.\"\"\"\n              payload = f\"\"\"{os.path.basename(directory)}\n      {\"=\" * len(os.path.basename(directory))}\n      \n      **Automata** is a Python library for autonomous agents.\n      \n      Check out the :doc:`usage` section for further information, including\n      how to :ref:`installation` the project.\n      \n      .. note::\n      \n      \"\"\"\n              return payload\n      \n          \n      def write_documentation(\n              self, docs: Dict[Symbol, SymbolDocEmbedding], symbols: List[Symbol], docs_dir: str\n          ):\n              \"\"\"\n              Generate the full documentation given the symbols and a directory.\n      \n              Args:\n                  docs (Dict[Any, Any]): The documentation dictionary\n                  symbols (List[Any]): The symbols of the documentation dictionary\n                  docs_dir (str): The relative directory\n              \"\"\"\n              self.generate_rst_files(docs, symbols, docs_dir)\n              self.generate_index_files(docs_dir)\n      \n          \n  Building context for related symbols -\n  \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator.generate_code\n    \n        def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            \n        \n    automata.tests.unit.sample_modules.sample.OuterClass\n    \n        class OuterClass:\n            class InnerClass:\n                \"\"\"Inner doc strings\"\"\"\n        \n                def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.tests.unit.sample_modules.sample.OuterClass.InnerClass\n    \n        class InnerClass:\n                \"\"\"Inner doc strings\"\"\"\n        \n                def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.core.coding.py_coding.writer.PyCodeWriter\n    \n        PyCodeWriter is a utility class designed for writing and updating Python code in the Abstract Syntax Tree (AST) format, enabling programmatic manipulation of Python elements such as classes, functions, and imports. The main functionality includes initializing with a PyCodeRetriever instance, creating a new module object from source code, updating an existing module, and writing the updated module to disk. However, PyCodeWriter's primary limitation is its reliance on RedBaron, which has known limitations and bugs, along with relatively low support in recent years. Additionally, error reporting in PyCodeWriter can be improved for a better user experience. \n        \n        ```python\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        from automata.core.coding.py_coding.writer import PyCodeWriter\n        \n        # Initialize the PyCodeWriter with a PyCodeRetriever instance\n        retriever = PyCodeRetriever()\n        writer = PyCodeWriter(retriever)\n        \n        # Create a new module object from source code\n        module_dotpath = \"my_module\"\n        source_code = \"def hello():\\n    print('Hello, World!')\\n\"\n        writer.create_new_module(module_dotpath, source_code)\n        \n        # Update the existing module by adding a new function\n        new_function_code = \"def goodbye():\\n    print('Goodbye, World!')\\n\"\n        writer.update_existing_module(module_dotpath, new_function_code, do_write=True)\n        ```\n        \n      Class Docstring:\n        A utility class for writing Python code along AST nodes\n        \n      Methods:\n        def __init__(self, python_retriever: PyCodeRetriever):\n                \"\"\"\n                Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n                Args:\n                    python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n                \"\"\"\n                self.code_retriever = python_retriever\n        \n            \n        create_new_module(self, module_dotpath: str, source_code: str, do_write: bool = False) -> None\n        \n        delete_from_existing__module(self, module_dotpath: str, object_dotpath: str, do_write: bool = False) -> None\n        \n        replace(match) -> None\n        \n        replace_newline_chars(input_str: str) -> str\n        \n        update_existing_module(self,\n                module_dotpath: str,\n                source_code: str,\n                disambiguator: Optional[str] = \"\",\n                do_write: bool = False,\n            ) -> None\n        \n    automata.tests.unit.test_py_writer.python_writer\n    \n        @pytest.fixture\n        def python_writer():\n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            return PyCodeWriter(retriever)\n        \n        \n        \n        \n    automata.tests.unit.test_py_code_retriever.test_get_docstring_no_docstring_class\n    \n        def test_get_docstring_no_docstring_class(getter):\n            module_name = \"sample\"\n            object_path = \"Person\"\n            result = getter.get_docstring(module_name, object_path)\n            expected_match = \"This is a sample class.\"\n            assert result == expected_match\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample.OuterClass.InnerClass.inner_method\n    \n        def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.tests.unit.test_py_code_retriever.test_get_code_no_docstring_method\n    \n        def test_get_code_no_docstring_method(getter):\n            module_name = \"sample\"\n            object_path = \"Person.say_hello\"\n            result = getter.get_source_code_without_docstrings(module_name, object_path)\n            expected_match = 'def say_hello(self):\\n        return f\"Hello, I am {self.name}.\"\\n\\n    '\n            assert result == expected_match\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.test_write_and_retrieve_mock_code\n    \n        def test_write_and_retrieve_mock_code(python_writer):\n            mock_generator = MockCodeGenerator(\n                has_class=True,\n                has_method=True,\n                has_function=True,\n                has_import=True,\n                has_module_docstring=True,\n                has_class_docstring=True,\n                has_method_docstring=True,\n                has_function_docstring=True,\n            )\n            source_code = mock_generator.generate_code()\n            python_writer._create_module_from_source_code(\"sample_module_2\", source_code)\n        \n            python_writer._write_module_to_disk(\"sample_module_2\")\n        \n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            module_docstring = retriever.get_docstring(\"sample_module_2\", None)\n            assert module_docstring == mock_generator.module_docstring\n        \n        \n  Building context for dependencies -\n  \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.coding.directory.DirectoryManager.get_files_in_dir\n    \n      Class Docstring:\n        Get a list of files in the given directory\n        \n        Args:\n        path (str): Path of the directory\n        \n        Returns:\n        List[str]: List of files in the directory\n        \n      Methods:\n        get_files_in_dir(self, path: str) -> List[str]\n        \n    automata.core.coding.directory.DirectoryManager.ensure_directory_exists\n    \n      Class Docstring:\n        Creates the directory if it does not exist already\n        \n        Args:\n        directory_path (str): Path of the directory to create\n        \n      Methods:\n        ensure_directory_exists(self, directory_path: str) -> None\n        \n    automata.core.coding.directory.DirectoryManager._get_node_for_path\n    \n      Class Docstring:\n        Find the node for a given path\n        \n        Args:\n        root (Directory): Root node of the tree\n        path (str): Path to find the node for\n        \n        Returns:\n        Optional[Node]: Node for the given path, None if not found\n        \n      Methods:\n    automata.core.symbol.symbol_types.SymbolDocEmbedding\n    \n        `SymbolDocEmbedding` is a class representing the embedding for symbol documents, extending the `SymbolEmbedding` class with added metadata such as source code, summary, and context. This class is utilized alongside `SymbolDocEmbeddingHandler` to manage and access these embeddings for tasks like search and similarity comparison. However, it relies on external handler classes and assumes embeddings are provided as NumPy arrays, potentially limiting usage for other embedding types.\n        \n        ```python\n        import numpy as np\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.symbol.symbol_types import SymbolDocEmbedding\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        symbol = Symbol.from_string(symbol_str)\n        \n        document = \"This is a sample document\"\n        vector = np.array([0.1, 0.2, 0.3])\n        source_code = \"class ActionIndicator(Enum): ...\"\n        summary = \"This class represents an enum for action indicators.\"\n        context = \"The ActionIndicator enum is used to describe the current state...\"\n        \n        embedding = SymbolDocEmbedding(symbol, document, vector, source_code=source_code, summary=summary, context=context)\n        ```\n        \n      Class Docstring:\n        Embedding for symbol documents\n        \n      Methods:\n        def __init__(\n                self,\n                symbol: Symbol,\n                document: str,\n                vector: np.array,\n                source_code: Optional[str] = None,\n                summary: Optional[str] = None,\n                context: Optional[str] = None,\n            ):\n                super().__init__(symbol, document, vector)\n                # begin additional meta data\n                self.source_code = source_code\n                self.summary = summary\n                self.context = context\n        \n    automata.core.coding.directory.DirectoryManager\n    \n        DirectoryManager is a utility class for handling directory structures, providing methods for creating directories and obtaining lists of files and subdirectories within a given directory. To create a DirectoryManager instance, simply import the class and initialize it with the base path of the desired directory structure. However, it has some limitations, such as assuming a specific directory structure based on the base path provided and not having error handling for incorrect or inaccessible paths. Here's an example usage:\n        \n        ```python\n        from automata.core.coding.directory import DirectoryManager\n        \n        # Creating a new directory\n        base_path = \"/path/to/base/directory\"\n        dm = DirectoryManager(base_path)\n        dm.ensure_directory_exists(\"new_directory\")\n        \n        # Retrieving the list of files and subdirectories in a given directory\n        files = dm.get_files_in_dir(\"new_directory\")\n        subdirs = dm.get_subdirectories(\"new_directory\")\n        print(\"Files:\", files)\n        print(\"Subdirectories:\", subdirs)\n        ```\n        \n        \n      Class Docstring:\n        Handles operations related to directory structure.\n        \n      Methods:\n        def __init__(self, base_path: str):\n                \"\"\"\n                Args:\n                    base_path (str): Base path of the directory structure\n                \"\"\"\n                self.root = self._load_directory_structure(base_path)\n        \n            \n        ensure_directory_exists(self, directory_path: str) -> None\n        \n        get_files_in_dir(self, path: str) -> List[str]\n        \n        get_subdirectories(self, path: str) -> List[str]\n        \n    automata.core.coding.directory.DirectoryManager.get_subdirectories\n    \n      Class Docstring:\n        Get a list of subdirectories in the given directory\n        \n        Args:\n        path (str): Path of the directory\n        \n        Returns:\n        List[str]: List of subdirectories in the directory\n        \n      Methods:\n        get_subdirectories(self, path: str) -> List[str]\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.context.py_context.retriever`/PyContextRetriever#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.context.py_context.retriever", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "PyContextRetriever", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# PyContextRetriever\n\n`PyContextRetriever` is a class used to retrieve the context of a symbol in a Python project. The retriever is capable of processing abstract syntax tree (AST) nodes of classes, methods, and module-level code to extract relevant information about the symbol. The PyContextRetriever is useful for generating detailed documentation and understanding the relationships between symbols in a codebase.\n\n## Overview\n\n`PyContextRetriever` operates on a `SymbolGraph` and takes in a configuration object `PyContextRetrieverConfig`. With these inputs, it offers several methods to process symbols, AST nodes of the methods and class docstrings, and related symbols. The main entry point for processing a symbol is the `process_symbol` method, which retrieves the context and stores it in the local message buffer.\n\n## Related Symbols\n\n- `automata.core.symbol.graph.SymbolGraph`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.symbol_utils.convert_to_fst_object`\n\n## Usage Example\n\n```python\nfrom automata.core.context.py_context.retriever import PyContextRetriever\nfrom automata.core.symbol.graph import SymbolGraph\n\ngraph = SymbolGraph()\npy_context_retriever = PyContextRetriever(graph)\nsymbol = some_symbol\n\n# Process the context of the symbol\npy_context_retriever.process_symbol(symbol)\n\n# Retrieve the context buffer\ncontext_buffer = py_context_retriever.get_context_buffer()\n```\n\n## Limitations\n\n`PyContextRetriever` relies on the `SymbolGraph` and `PyContextRetrieverConfig` passed to it. It assumes that all symbols are represented in the `SymbolGraph` and that the configuration values are set correctly in the `PyContextRetrieverConfig`. Inaccuracies or errors in these inputs may lead to issues when processing symbols and their relationships.\n\n## Follow-up Questions:\n\n- What if symbol relationships in the `SymbolGraph` are not correctly defined?\n- How can we update or modify the `PyContextRetrieverConfig` after initializing the `PyContextRetriever`?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class PyContextRetriever:\n    \"\"\"The PyContextRetriever is used to retrieve the context of a symbol in a Python project\"\"\"\n\n    def __init__(\n        self,\n        graph: SymbolGraph,\n        config: PyContextRetrieverConfig = PyContextRetrieverConfig(),\n        doc_embedding_db: Optional[VectorDatabaseProvider] = None,\n    ):\n        \"\"\"\n        Args:\n            graph (SymbolGraph): The symbol graph to use\n            config (PyContextRetrieverConfig): The configuration to use\n        \"\"\"\n        self.graph = graph\n        self.config = config\n        self.indent_level = 0\n        self.doc_embedding_db = doc_embedding_db\n        self.encoding = tiktoken.encoding_for_model(self.config.model_name)\n\n        self.reset()\n\n    @contextmanager\n    def IndentManager(self):\n        \"\"\"A context manager to manage the indentation level\"\"\"\n        self.indent_level += 1\n        yield\n        self.indent_level -= 1\n\n    def process_message(self, message: str):\n        \"\"\"\n        Process a message by appending indentation and adding it to the message\n\n        Args:\n            message (str): The message to process\n        \"\"\"\n\n        def indent() -> str:\n            return self.config.spacer * self.indent_level\n\n        self.context += \"\\n\".join([f\"{indent()}{ele}\" for ele in message.split(\"\\n\")]) + \"\\n\"\n\n    def get_context_buffer(self) -> str:\n        \"\"\"\n        Get the context buffer\n\n        Returns:\n            str: The context buffer\n        \"\"\"\n        return self.context\n\n    def reset(self):\n        \"\"\"\n        Reset the retriever to its initial state\n        \"\"\"\n        self.context = \"\"\n        self.obs_symbols: Set[Symbol] = set([])\n        self.global_level = 0\n\n    def process_symbol(\n        self,\n        symbol: Symbol,\n        related_symbols: List[Symbol] = [],\n    ):\n        \"\"\"\n        Process the context of a symbol\n        Theh output is stored into the local message buffer\n\n        Args:\n            symbol (Symbol): The symbol to process\n            ranked_symbols (List[Symbol]): The list ranked symbols to use\n                with the nearest symbol processor\n        \"\"\"\n        with self.IndentManager():\n            self.process_headline(symbol)\n            self.process_ast(symbol)\n\n            if self._is_main_symbol():\n                related_symbols_processed = 0\n                self.process_message(f\"Building context for related symbols -\\n\")\n\n                for related_symbol in related_symbols:\n                    if related_symbols_processed >= self.config.max_related_symbols_to_process:\n                        break\n                    # Check that the related symbol passes filter requirements\n                    if not PyContextRetriever._pass_symbol_filter(symbol, related_symbol):\n                        continue\n                    \n                    if not self._below_context_limit():\n                            break\n\n                    if related_symbol not in self.obs_symbols:\n                        self.process_symbol(related_symbol)\n                        related_symbols_processed += 1\n\n                dependencies_processed = 0\n                self.process_message(f\"Building context for dependencies -\\n\")\n                all_dependencies = list(self.graph.get_symbol_dependencies(symbol))\n                filtered_dependencies = get_rankable_symbols(all_dependencies)\n\n                for dependency in filtered_dependencies:\n                    if dependencies_processed >= self.config.max_dependencies_to_process:\n                        break\n                    # Check that the dependency passes filter requirements\n                    if not PyContextRetriever._pass_symbol_filter(symbol, dependency):\n                        continue\n\n                    if not self._below_context_limit():\n                            break\n\n                    if dependency not in self.obs_symbols:\n                        try:\n                            self.process_symbol(dependency)\n                        except Exception as e:\n                            logger.error(f\"Failure processing dependent {dependency} with {e}\")\n                            continue\n                        dependencies_processed += 1\n\n        self.obs_symbols.add(symbol)\n\n    def process_headline(self, symbol: Symbol):\n        \"\"\"\n        Process the headline of a symbol\n\n        Args:\n            symbol (Symbol): The symbol to process\n        \"\"\"\n        # Print the headline\n        if self._is_main_symbol():\n            self.process_message(f\"Building context for primary symbol - {symbol.dotpath} -\\n\")\n        else:\n            self.process_message(f\"{symbol.dotpath}\\n\")\n\n    def process_ast(self, symbol: Symbol):\n        \"\"\"\n        Process the variables of a symbol\n\n        Args:\n            ast_object (RedBaron): The ast representation of the symbol\n        \"\"\"\n        ast_object = convert_to_fst_object(symbol)\n        is_main_symbol = self._is_main_symbol()\n        methods = sorted(ast_object.find_all(\"DefNode\"), key=lambda x: x.name)\n\n        with self.IndentManager():\n            if \"test\" in symbol.dotpath or \"Config\" in symbol.dotpath:\n                with self.IndentManager():\n                    self.process_message(f\"{ast_object.dumps()}\\n\")\n            else:\n                if is_main_symbol:\n                    self.process_imports(symbol)\n                self.process_documentation(symbol, is_main_symbol)\n\n                self.process_docstring(ast_object)\n\n                if len(methods) > 0:\n                    self.process_message(f\"Methods:\")\n                for method in methods:\n                    self.process_method(method, is_main_symbol)\n\n    def process_imports(self, symbol: Symbol):\n        \"\"\"\n        Process the imports of a symbol\n\n        Args:\n            symbol (Symbol): The symbol to process\n        \"\"\"\n        # Compute the file path from the symbol's path\n        file_path = os.path.join(\n            root_py_fpath(), \"..\", str(symbol.dotpath).replace(\".\", os.path.sep)\n        )\n        while not os.path.isdir(os.path.dirname(file_path)):\n            file_path = os.path.dirname(file_path)\n\n        # Load the source code with RedBaron\n        with open(file_path + \".py\", \"r\") as f:\n            red = RedBaron(f.read())\n\n        # Find and print import statements\n        imports = red.find_all(\"ImportNode\")\n        from_imports = red.find_all(\"FromImportNode\")\n        if len(imports) + len(from_imports) > 0:\n            self.process_message(\"Import Statements:\")\n            with self.IndentManager():\n                for import_node in imports + from_imports:\n                    self.process_message(str(import_node.dumps()))\n                self.process_message(\"\")  # Add an empty line for separation\n\n    def process_docstring(self, ast_object: RedBaron):\n        \"\"\"\n        Process the docstring of a symbol\n\n        Args:\n            ast_object (RedBaron): The ast representation of the symbol\n        \"\"\"\n        docstring = PyContextRetriever._get_docstring(ast_object)\n        # Print the docstring if it exists\n        if docstring:\n            self.process_message(\"Class Docstring:\")\n            with self.IndentManager():\n                self.process_message(docstring)\n                self.process_message(\"\")  # Add an empty line for separation\n\n    def process_documentation(self, symbol: Symbol, is_main_symbol: bool):\n        if self.doc_embedding_db is not None:\n            if self.doc_embedding_db.contains(symbol):\n                if is_main_symbol:\n                    document = self.doc_embedding_db.get(symbol).embedding_source\n                else:\n                    document = self.doc_embedding_db.get(symbol).summary\n                with self.IndentManager():\n                    self.process_message(document)\n                    self.process_message(\"\")  # Add an empty line for separation\n\n    def process_method(self, method: RedBaron, is_main_symbol: bool):\n        \"\"\"\n        Processes a specified method\n\n        Args:\n            method (RedBaron): The ast representation of the method\n        \"\"\"\n        if PyContextRetriever._is_private_method(method):\n            return\n        with self.IndentManager():\n            if is_main_symbol:\n                for code_line in method.dumps().split(\"\\n\"):\n                    self.process_message(code_line)\n            else:\n                if method.name == \"__init__\":\n                    for code_line in method.dumps().split(\"\\n\"):\n                        self.process_message(code_line)\n                else:\n                    method_definition = f\"{method.name}({method.arguments.dumps()})\"\n                    return_annotation = (\n                        method.return_annotation.dumps() if method.return_annotation else \"None\"\n                    )\n                    self.process_message(f\"{method_definition} -> {return_annotation}\\n\")\n\n    def _is_main_symbol(self) -> bool:\n        \"\"\"\n        Check if this is the main symbol call\n\n        Returns:\n            bool: True if this is the main symbol call, False otherwise\n\n        \"\"\"\n        return self.indent_level == 1\n\n    def _below_context_limit(self) -> bool:\n        \"\"\"\n        Check if we are below the context limit\n\n        Returns:\n            bool: True if we are below the context limit, False otherwise\n        \"\"\"\n        return len(self.encoding.encode(self.context)) < self.config.max_context\n    \n    @staticmethod\n    def _is_private_method(ast_object: RedBaron) -> bool:\n        \"\"\"\n        Check if the ast object is private\n\n        Args:\n            ast_object (RedBaron): The RedBaron object to check\n\n        Returns:\n            bool: True if the method is private, False otherwise\n        \"\"\"\n        return ast_object.name[0] == \"_\" and ast_object.name[1] != \"_\"\n\n    @staticmethod\n    def _get_docstring(ast_object) -> str:\n        \"\"\"\n        Get the docstring an ast object\n\n        Args:\n            ast_object (RedBaron): The RedBaron object to get the docstring from\n\n        Returns:\n            str: Newline separated docstring\n        \"\"\"\n\n        raw_doctring = PyCodeRetriever.get_docstring_from_node(ast_object).split(\"\\n\")\n        return \"\\n\".join([ele.strip() for ele in raw_doctring]).strip()\n\n    @staticmethod\n    def _pass_symbol_filter(primary_symbol: Symbol, secondary_symbol: Symbol) -> bool:\n        \"\"\"\n        Check if the symbol passes the filter on package and dotpath\n\n        Args:\n            primary_symbol (Symbol): The primary symbol\n            secondary_symbol (Symbol): The secondary symbol\n\n        Returns:\n            bool: True if the symbol passes the filter, False otherwise\n        \"\"\"\n\n        primary_symbol_dotpath = primary_symbol.dotpath\n        primary_package = primary_symbol_dotpath.split(\".\")[0]\n\n        secondary_symbol_dotpath = secondary_symbol.dotpath\n        secondary_package = secondary_symbol_dotpath.split(\".\")[0]\n        return not (\n            primary_symbol_dotpath in secondary_symbol_dotpath\n            or primary_package != secondary_package\n        )\n", "summary": "PyContextRetriever is a class for retrieving the context of symbols in a Python project by processing abstract syntax tree (AST) nodes of classes, methods, and module-level code. This class is particularly useful for generating detailed documentation and understanding the relationships between symbols in a codebase. PyContextRetriever operates on a SymbolGraph and takes in a PyContextRetrieverConfig configuration object. The main entry point for processing a symbol is the process_symbol method, which retrieves the context and stores it in the local message buffer. However, PyContextRetriever relies on the SymbolGraph and PyContextRetrieverConfig passed to it, and inaccuracies or errors in these inputs may lead to issues when processing symbols and their relationships.\n\nUsage Example:\n```python\nfrom automata.core.context.py_context.retriever import PyContextRetriever\nfrom automata.core.symbol.graph import SymbolGraph\n\ngraph = SymbolGraph()\npy_context_retriever = PyContextRetriever(graph)\nsymbol = some_symbol\n\n# Process the context of the symbol\npy_context_retriever.process_symbol(symbol)\n\n# Retrieve the context buffer\ncontext_buffer = py_context_retriever.get_context_buffer()\n```\n", "context": "\n    Generate the documentation for PyContextRetriever using the context shown below -\n  Building context for primary symbol - automata.core.context.py_context.retriever.PyContextRetriever -\n  \n    Import Statements:\n      import logging\n      import os\n      import tiktoken\n      from contextlib import contextmanager\n      from typing import List, Optional, Set\n      from redbaron import RedBaron\n      from automata.core.database.vector import JSONVectorDatabase, VectorDatabaseProvider\n      from automata.core.coding.py_coding.retriever import PyCodeRetriever\n      from automata.core.symbol.graph import SymbolGraph\n      from automata.core.symbol.symbol_types import Symbol\n      from automata.core.symbol.symbol_utils import convert_to_fst_object, get_rankable_symbols\n      from automata.core.utils import root_py_fpath\n      \n      # PyContextRetriever\n      \n      `PyContextRetriever` is a class used to retrieve the context of a symbol in a Python project. The retriever is capable of processing abstract syntax tree (AST) nodes of classes, methods, and module-level code to extract relevant information about the symbol. The PyContextRetriever is useful for generating detailed documentation and understanding the relationships between symbols in a codebase.\n      \n      ## Overview\n      \n      `PyContextRetriever` operates on a `SymbolGraph` and takes in a configuration object `PyContextRetrieverConfig`. With these inputs, it offers several methods to process symbols, AST nodes of the methods and class docstrings, and related symbols. The main entry point for processing a symbol is the `process_symbol` method, which retrieves the context and stores it in the local message buffer.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.graph.SymbolGraph`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.symbol_utils.convert_to_fst_object`\n      \n      ## Usage Example\n      \n      ```python\n      from automata.core.context.py_context.retriever import PyContextRetriever\n      from automata.core.symbol.graph import SymbolGraph\n      \n      graph = SymbolGraph()\n      py_context_retriever = PyContextRetriever(graph)\n      symbol = some_symbol\n      \n      # Process the context of the symbol\n      py_context_retriever.process_symbol(symbol)\n      \n      # Retrieve the context buffer\n      context_buffer = py_context_retriever.get_context_buffer()\n      ```\n      \n      ## Limitations\n      \n      `PyContextRetriever` relies on the `SymbolGraph` and `PyContextRetrieverConfig` passed to it. It assumes that all symbols are represented in the `SymbolGraph` and that the configuration values are set correctly in the `PyContextRetrieverConfig`. Inaccuracies or errors in these inputs may lead to issues when processing symbols and their relationships.\n      \n      ## Follow-up Questions:\n      \n      - What if symbol relationships in the `SymbolGraph` are not correctly defined?\n      - How can we update or modify the `PyContextRetrieverConfig` after initializing the `PyContextRetriever`?\n      \n    Class Docstring:\n      The PyContextRetriever is used to retrieve the context of a symbol in a Python project\n      \n    Methods:\n      @contextmanager\n          def IndentManager(self):\n              \"\"\"A context manager to manage the indentation level\"\"\"\n              self.indent_level += 1\n              yield\n              self.indent_level -= 1\n      \n          \n      def __init__(\n              self,\n              graph: SymbolGraph,\n              config: PyContextRetrieverConfig = PyContextRetrieverConfig(),\n              doc_embedding_db: Optional[VectorDatabaseProvider] = None,\n          ):\n              \"\"\"\n              Args:\n                  graph (SymbolGraph): The symbol graph to use\n                  config (PyContextRetrieverConfig): The configuration to use\n              \"\"\"\n              self.graph = graph\n              self.config = config\n              self.indent_level = 0\n              self.doc_embedding_db = doc_embedding_db\n              self.encoding = tiktoken.encoding_for_model(self.config.model_name)\n      \n              self.reset()\n      \n          \n      def get_context_buffer(self) -> str:\n              \"\"\"\n              Get the context buffer\n      \n              Returns:\n                  str: The context buffer\n              \"\"\"\n              return self.context\n      \n          \n      def indent() -> str:\n                  return self.config.spacer * self.indent_level\n      \n              \n      def process_ast(self, symbol: Symbol):\n              \"\"\"\n              Process the variables of a symbol\n      \n              Args:\n                  ast_object (RedBaron): The ast representation of the symbol\n              \"\"\"\n              ast_object = convert_to_fst_object(symbol)\n              is_main_symbol = self._is_main_symbol()\n              methods = sorted(ast_object.find_all(\"DefNode\"), key=lambda x: x.name)\n      \n              with self.IndentManager():\n                  if \"test\" in symbol.dotpath or \"Config\" in symbol.dotpath:\n                      with self.IndentManager():\n                          self.process_message(f\"{ast_object.dumps()}\\n\")\n                  else:\n                      if is_main_symbol:\n                          self.process_imports(symbol)\n                      self.process_documentation(symbol, is_main_symbol)\n      \n                      self.process_docstring(ast_object)\n      \n                      if len(methods) > 0:\n                          self.process_message(f\"Methods:\")\n                      for method in methods:\n                          self.process_method(method, is_main_symbol)\n      \n          \n      def process_docstring(self, ast_object: RedBaron):\n              \"\"\"\n              Process the docstring of a symbol\n      \n              Args:\n                  ast_object (RedBaron): The ast representation of the symbol\n              \"\"\"\n              docstring = PyContextRetriever._get_docstring(ast_object)\n              # Print the docstring if it exists\n              if docstring:\n                  self.process_message(\"Class Docstring:\")\n                  with self.IndentManager():\n                      self.process_message(docstring)\n                      self.process_message(\"\")  # Add an empty line for separation\n      \n          \n      def process_documentation(self, symbol: Symbol, is_main_symbol: bool):\n              if self.doc_embedding_db is not None:\n                  if self.doc_embedding_db.contains(symbol):\n                      if is_main_symbol:\n                          document = self.doc_embedding_db.get(symbol).embedding_source\n                      else:\n                          document = self.doc_embedding_db.get(symbol).summary\n                      with self.IndentManager():\n                          self.process_message(document)\n                          self.process_message(\"\")  # Add an empty line for separation\n      \n          \n      def process_headline(self, symbol: Symbol):\n              \"\"\"\n              Process the headline of a symbol\n      \n              Args:\n                  symbol (Symbol): The symbol to process\n              \"\"\"\n              # Print the headline\n              if self._is_main_symbol():\n                  self.process_message(f\"Building context for primary symbol - {symbol.dotpath} -\\n\")\n              else:\n                  self.process_message(f\"{symbol.dotpath}\\n\")\n      \n          \n      def process_imports(self, symbol: Symbol):\n              \"\"\"\n              Process the imports of a symbol\n      \n              Args:\n                  symbol (Symbol): The symbol to process\n              \"\"\"\n              # Compute the file path from the symbol's path\n              file_path = os.path.join(\n                  root_py_fpath(), \"..\", str(symbol.dotpath).replace(\".\", os.path.sep)\n              )\n              while not os.path.isdir(os.path.dirname(file_path)):\n                  file_path = os.path.dirname(file_path)\n      \n              # Load the source code with RedBaron\n              with open(file_path + \".py\", \"r\") as f:\n                  red = RedBaron(f.read())\n      \n              # Find and print import statements\n              imports = red.find_all(\"ImportNode\")\n              from_imports = red.find_all(\"FromImportNode\")\n              if len(imports) + len(from_imports) > 0:\n                  self.process_message(\"Import Statements:\")\n                  with self.IndentManager():\n                      for import_node in imports + from_imports:\n                          self.process_message(str(import_node.dumps()))\n                      self.process_message(\"\")  # Add an empty line for separation\n      \n          \n      def process_message(self, message: str):\n              \"\"\"\n              Process a message by appending indentation and adding it to the message\n      \n              Args:\n                  message (str): The message to process\n              \"\"\"\n      \n              def indent() -> str:\n                  return self.config.spacer * self.indent_level\n      \n              self.context += \"\\n\".join([f\"{indent()}{ele}\" for ele in message.split(\"\\n\")]) + \"\\n\"\n      \n          \n      def process_method(self, method: RedBaron, is_main_symbol: bool):\n              \"\"\"\n              Processes a specified method\n      \n              Args:\n                  method (RedBaron): The ast representation of the method\n              \"\"\"\n              if PyContextRetriever._is_private_method(method):\n                  return\n              with self.IndentManager():\n                  if is_main_symbol:\n                      for code_line in method.dumps().split(\"\\n\"):\n                          self.process_message(code_line)\n                  else:\n                      if method.name == \"__init__\":\n                          for code_line in method.dumps().split(\"\\n\"):\n                              self.process_message(code_line)\n                      else:\n                          method_definition = f\"{method.name}({method.arguments.dumps()})\"\n                          return_annotation = (\n                              method.return_annotation.dumps() if method.return_annotation else \"None\"\n                          )\n                          self.process_message(f\"{method_definition} -> {return_annotation}\\n\")\n      \n          \n      def process_symbol(\n              self,\n              symbol: Symbol,\n              related_symbols: List[Symbol] = [],\n          ):\n              \"\"\"\n              Process the context of a symbol\n              Theh output is stored into the local message buffer\n      \n              Args:\n                  symbol (Symbol): The symbol to process\n                  ranked_symbols (List[Symbol]): The list ranked symbols to use\n                      with the nearest symbol processor\n              \"\"\"\n              with self.IndentManager():\n                  self.process_headline(symbol)\n                  self.process_ast(symbol)\n      \n                  if self._is_main_symbol():\n                      related_symbols_processed = 0\n                      self.process_message(f\"Building context for related symbols -\\n\")\n      \n                      for related_symbol in related_symbols:\n                          if related_symbols_processed >= self.config.max_related_symbols_to_process:\n                              break\n                          # Check that the related symbol passes filter requirements\n                          if not PyContextRetriever._pass_symbol_filter(symbol, related_symbol):\n                              continue\n                          \n                          if not self._below_context_limit():\n                                  break\n      \n                          if related_symbol not in self.obs_symbols:\n                              self.process_symbol(related_symbol)\n                              related_symbols_processed += 1\n      \n                      dependencies_processed = 0\n                      self.process_message(f\"Building context for dependencies -\\n\")\n                      all_dependencies = list(self.graph.get_symbol_dependencies(symbol))\n                      filtered_dependencies = get_rankable_symbols(all_dependencies)\n      \n                      for dependency in filtered_dependencies:\n                          if dependencies_processed >= self.config.max_dependencies_to_process:\n                              break\n                          # Check that the dependency passes filter requirements\n                          if not PyContextRetriever._pass_symbol_filter(symbol, dependency):\n                              continue\n      \n                          if not self._below_context_limit():\n                                  break\n      \n                          if dependency not in self.obs_symbols:\n                              try:\n                                  self.process_symbol(dependency)\n                              except Exception as e:\n                                  logger.error(f\"Failure processing dependent {dependency} with {e}\")\n                                  continue\n                              dependencies_processed += 1\n      \n              self.obs_symbols.add(symbol)\n      \n          \n      def reset(self):\n              \"\"\"\n              Reset the retriever to its initial state\n              \"\"\"\n              self.context = \"\"\n              self.obs_symbols: Set[Symbol] = set([])\n              self.global_level = 0\n      \n          \n  Building context for related symbols -\n  \n    automata.tests.unit.test_py_code_retriever.getter\n    \n        @pytest.fixture\n        def getter(module_map):\n            return PyCodeRetriever(module_map)\n        \n        \n        \n        \n    automata.core.coding.py_coding.retriever.PyCodeRetriever\n    \n        `PyCodeRetriever` is a class designed to fetch Python code from a specified module, enabling the retrieval of source code, docstrings, and source code without docstrings for a given module, class, or function/method. Through methods like `get_docstring`, `get_source_code`, and `get_source_code_without_docstrings`, it offers a way to programmatically analyze, extract, and comprehend Python projects. However, this class assumes a specific directory structure for the modules and relies on the RedBaron library for parsing, which may have limitations when parsing complex or unconventional code patterns.\n        \n        An example usage of `PyCodeRetriever` for retrieving the source code of a function from a specified module is as follows:\n        \n        ```python\n        from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        \n        module_tree_map = LazyModuleTreeMap.cached_default()\n        code_retriever = PyCodeRetriever(module_tree_map)\n        \n        module_dotpath = \"mymodule.example\"\n        object_path = \"ExampleClass.example_function\"\n        \n        source_code = code_retriever.get_source_code(module_dotpath, object_path)\n        print(source_code)\n        ```\n        \n        \n      Class Docstring:\n        Code retriever for fetching python code\n        \n      Methods:\n        def __init__(self, module_tree_map: LazyModuleTreeMap = LazyModuleTreeMap.cached_default()):\n                self.module_tree_map = module_tree_map\n        \n            \n        get_docstring(self, module_dotpath: str, object_path: Optional[str]) -> str\n        \n        get_docstring_from_node(node: Optional[FSTNode]) -> str\n        \n        get_source_code(self, module_dotpath: str, object_path: Optional[str] = None) -> str\n        \n        get_source_code_without_docstrings(self, module_dotpath: str, object_path: Optional[str]\n            ) -> str\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_py_writer.python_writer\n    \n        @pytest.fixture\n        def python_writer():\n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            return PyCodeWriter(retriever)\n        \n        \n        \n        \n    automata.core.coding.py_coding.writer.PyCodeWriter\n    \n        PyCodeWriter is a utility class designed for writing and updating Python code in the Abstract Syntax Tree (AST) format, enabling programmatic manipulation of Python elements such as classes, functions, and imports. The main functionality includes initializing with a PyCodeRetriever instance, creating a new module object from source code, updating an existing module, and writing the updated module to disk. However, PyCodeWriter's primary limitation is its reliance on RedBaron, which has known limitations and bugs, along with relatively low support in recent years. Additionally, error reporting in PyCodeWriter can be improved for a better user experience. \n        \n        ```python\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        from automata.core.coding.py_coding.writer import PyCodeWriter\n        \n        # Initialize the PyCodeWriter with a PyCodeRetriever instance\n        retriever = PyCodeRetriever()\n        writer = PyCodeWriter(retriever)\n        \n        # Create a new module object from source code\n        module_dotpath = \"my_module\"\n        source_code = \"def hello():\\n    print('Hello, World!')\\n\"\n        writer.create_new_module(module_dotpath, source_code)\n        \n        # Update the existing module by adding a new function\n        new_function_code = \"def goodbye():\\n    print('Goodbye, World!')\\n\"\n        writer.update_existing_module(module_dotpath, new_function_code, do_write=True)\n        ```\n        \n      Class Docstring:\n        A utility class for writing Python code along AST nodes\n        \n      Methods:\n        def __init__(self, python_retriever: PyCodeRetriever):\n                \"\"\"\n                Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n                Args:\n                    python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n                \"\"\"\n                self.code_retriever = python_retriever\n        \n            \n        create_new_module(self, module_dotpath: str, source_code: str, do_write: bool = False) -> None\n        \n        delete_from_existing__module(self, module_dotpath: str, object_dotpath: str, do_write: bool = False) -> None\n        \n        replace(match) -> None\n        \n        replace_newline_chars(input_str: str) -> str\n        \n        update_existing_module(self,\n                module_dotpath: str,\n                source_code: str,\n                disambiguator: Optional[str] = \"\",\n                do_write: bool = False,\n            ) -> None\n        \n    automata.core.coding.py_coding.writer.PyCodeWriter.__init__\n    \n      Class Docstring:\n        Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n        Args:\n        python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n        \n      Methods:\n        def __init__(self, python_retriever: PyCodeRetriever):\n                \"\"\"\n                Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n                Args:\n                    python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n                \"\"\"\n                self.code_retriever = python_retriever\n        \n            \n    automata.tests.unit.test_py_writer.test_write_and_retrieve_mock_code\n    \n        def test_write_and_retrieve_mock_code(python_writer):\n            mock_generator = MockCodeGenerator(\n                has_class=True,\n                has_method=True,\n                has_function=True,\n                has_import=True,\n                has_module_docstring=True,\n                has_class_docstring=True,\n                has_method_docstring=True,\n                has_function_docstring=True,\n            )\n            source_code = mock_generator.generate_code()\n            python_writer._create_module_from_source_code(\"sample_module_2\", source_code)\n        \n            python_writer._write_module_to_disk(\"sample_module_2\")\n        \n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            module_docstring = retriever.get_docstring(\"sample_module_2\", None)\n            assert module_docstring == mock_generator.module_docstring\n        \n        \n    automata.core.symbol.symbol_types.SymbolDescriptor\n    \n        `SymbolDescriptor` is a Python class that wraps the descriptor component of a Universal Resource Identifier (URI) and represents various symbols such as local, namespace, type, method, term, macro, parameter, and type-parameter. It provides methods to convert the descriptor suffix from the URI representation to a Python representation, extract the escaped name from a string, and represent the object as a URI string. However, it may not support custom URI representations or descriptors that do not follow the predefined format and structure. For example, an instance of `SymbolDescriptor` can be created using a name, suffix, and an optional disambiguator like this:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolDescriptor\n        from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n        \n        name = \"example_descriptor\"\n        suffix = DescriptorProto.Type\n        disambiguator = \"example_disambiguator\"\n        \n        descriptor = SymbolDescriptor(name, suffix, disambiguator)\n        ```\n        \n        Follow-up questions include exploring ways to update `SymbolDescriptor` to handle custom URI representations or descriptors that do not follow the predefined format and understanding any precautions that need to be taken when using `SymbolDescriptor`.\n        \n      Class Docstring:\n        Wraps the descriptor component of the URI into a python object\n        \n      Methods:\n        def __init__(self, name: str, suffix: DescriptorProto, disambiguator: Optional[str] = None):\n                self.name = name\n                self.suffix = suffix\n                self.disambiguator = disambiguator\n        \n            \n        __repr__(self) -> None\n        \n        convert_scip_to_python_suffix(descriptor_suffix: DescriptorProto,\n            ) -> PyKind\n        \n        get_escaped_name(name) -> None\n        \n        is_simple_identifier(name) -> None\n        \n        unparse(self) -> None\n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.tests.unit.test_symbol_search.test_retrieve_source_code_by_symbol\n    \n        def test_retrieve_source_code_by_symbol(symbols, symbol_searcher):\n            with patch(\n                \"automata.core.symbol.search.symbol_search.convert_to_fst_object\",\n                return_value=\"module1\",\n            ) as mock_method:\n                result = symbol_searcher.retrieve_source_code_by_symbol(symbols[0].uri)\n                assert result == \"module1\"\n            mock_method.assert_called_once_with(symbols[0])\n        \n        \n        \n        \n  Building context for dependencies -\n  \n    automata.core.symbol.graph.SymbolGraph.get_symbol_dependencies\n    \n      Class Docstring:\n        Gets all symbols which contain a specified partial path\n        \n        Args:\n        partial_py_path (PyPath): The partial path to explain\n        Returns:\n        Set[Symbol]: Set of symbols that follow the partial path\n        \n      Methods:\n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n    automata.core.coding.py_coding.retriever.PyCodeRetriever.get_docstring_from_node\n    \n      Class Docstring:\n        Gets the docstring from the specified node\n        \n        Args:\n        node: The FST node to get the docstring from\n        \n      Methods:\n        get_docstring_from_node(node: Optional[FSTNode]) -> str\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.context.py_context.retriever`/PyContextRetrieverConfig#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.context.py_context.retriever", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "PyContextRetrieverConfig", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# PyContextRetrieverConfig\n\n`PyContextRetrieverConfig` is a configuration class for the `PyContextRetriever`, which helps retrieve the context of a symbol in a Python project. It contains various attributes such as `spacer`, `max_dependencies_to_process`, `max_related_symbols_to_process`, `model_name`, and others to control the behavior, settings, and resources used by the `PyContextRetriever`.\n\n## Overview\n\n`PyContextRetrieverConfig` provides a way to configure the indentation style, the maximum depth to print dependencies and recurse into dependencies, the number of nearest symbols to print, as well as the model name used for generating context with a specific model. This class provides a convenient way to customize the processing capabilities of the `PyContextRetriever`.\n\n## Related Symbols\n\n- `automata.core.context.py_context.retriever.PyContextRetriever`\n- `automata.core.symbol.graph.SymbolGraph`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `PyContextRetrieverConfig` with custom settings.\n\n```python\nfrom automata.core.context.py_context.retriever import PyContextRetrieverConfig\n\nconfig = PyContextRetrieverConfig(\n    spacer=\"  \",\n    max_dependencies_to_process=10,\n    max_related_symbols_to_process=10,\n    model_name=\"gpt-4\",\n    max_context=6_500,\n)\n```\n\n## Limitations\n\n`PyContextRetrieverConfig` relies on proper input values for its settings. Having erroneous input values can cause issues, such as incorrect context retrieval or errors in the `PyContextRetriever` operation.\n\n## Follow-up Questions:\n\n- Is there any validation needed for the input values provided to the `PyContextRetrieverConfig` class?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class PyContextRetrieverConfig:\n    \"\"\"The configuration for the PyContextRetriever\"\"\"\n\n    def __init__(\n        self,\n        spacer: str = \"  \",\n        max_dependencies_to_process: int = 10,\n        max_related_symbols_to_process: int = 10,\n        model_name: str = \"gpt-4\",\n        max_context: int = 6_500,\n    ):\n        \"\"\"\n        Args:\n            spacer (str): The string to use for indentation\n            max_dependency_print_depth (int): The maximum depth to print dependencies\n            max_recursion_depth (int): The maximum depth to recurse into dependencies\n            max_related_symbols_to_process (int): The number of nearest symbols to print\n        \"\"\"\n        self.spacer = spacer\n        self.max_dependencies_to_process = max_dependencies_to_process\n        self.max_related_symbols_to_process = max_related_symbols_to_process\n        self.model_name = model_name\n        self.max_context = max_context\n\n", "summary": "PyContextRetrieverConfig is a configuration class for the PyContextRetriever used to retrieve the context of a symbol in a Python project. It offers customization options for indentation style, maximum depth for dependencies, number of nearest symbols, and model name used to generate the context. By modifying its attributes such as spacer, max_dependencies_to_process, max_related_symbols_to_process, and others, users can control the behavior and resources of the PyContextRetriever. For example:\n\n```python\nfrom automata.core.context.py_context.retriever import PyContextRetrieverConfig\n\nconfig = PyContextRetrieverConfig(\n    spacer=\"  \",\n    max_dependencies_to_process=10,\n    max_related_symbols_to_process=10,\n    model_name=\"gpt-4\",\n    max_context=6_500,\n)\n```\n\nHowever, PyContextRetrieverConfig relies on proper input values, and erroneous inputs can cause incorrect context retrieval or operational errors in the PyContextRetriever.", "context": "\n    Generate the documentation for PyContextRetrieverConfig using the context shown below -\n  Building context for primary symbol - automata.core.context.py_context.retriever.PyContextRetrieverConfig -\n  \n      class PyContextRetrieverConfig:\n          \"\"\"The configuration for the PyContextRetriever\"\"\"\n      \n          def __init__(\n              self,\n              spacer: str = \"  \",\n              max_dependencies_to_process: int = 10,\n              max_related_symbols_to_process: int = 10,\n              model_name: str = \"gpt-4\",\n              max_context: int = 6_500,\n          ):\n              \"\"\"\n              Args:\n                  spacer (str): The string to use for indentation\n                  max_dependency_print_depth (int): The maximum depth to print dependencies\n                  max_recursion_depth (int): The maximum depth to recurse into dependencies\n                  max_related_symbols_to_process (int): The number of nearest symbols to print\n              \"\"\"\n              self.spacer = spacer\n              self.max_dependencies_to_process = max_dependencies_to_process\n              self.max_related_symbols_to_process = max_related_symbols_to_process\n              self.model_name = model_name\n              self.max_context = max_context\n      \n      \n      \n  Building context for related symbols -\n  \n    automata.core.context.py_context.retriever.PyContextRetriever\n    \n        PyContextRetriever is a class that retrieves the context of a symbol in a Python project, helping generate documentation and understanding symbol relationships. It processes abstract syntax tree (AST) nodes and operates on a SymbolGraph with a PyContextRetrieverConfig object. To use it, create a SymbolGraph instance, instantiate the PyContextRetriever with the graph, process a symbol using the `process_symbol` method, and retrieve the context buffer. Note that PyContextRetriever relies on accurate SymbolGraph and PyContextRetrieverConfig inputs; errors in these may cause issues when processing symbols. \n        \n        Usage Example:\n        \n        ```python\n        from automata.core.context.py_context.retriever import PyContextRetriever\n        from automata.core.symbol.graph import SymbolGraph\n        \n        graph = SymbolGraph()\n        py_context_retriever = PyContextRetriever(graph)\n        symbol = some_symbol\n        \n        # Process the context of the symbol\n        py_context_retriever.process_symbol(symbol)\n        \n        # Retrieve the context buffer\n        context_buffer = py_context_retriever.get_context_buffer()\n        ```\n        \n      Class Docstring:\n        The PyContextRetriever is used to retrieve the context of a symbol in a Python project\n        \n      Methods:\n        IndentManager(self) -> None\n        \n        def __init__(\n                self,\n                graph: SymbolGraph,\n                config: PyContextRetrieverConfig = PyContextRetrieverConfig(),\n                doc_embedding_db: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                Args:\n                    graph (SymbolGraph): The symbol graph to use\n                    config (PyContextRetrieverConfig): The configuration to use\n                \"\"\"\n                self.graph = graph\n                self.config = config\n                self.indent_level = 0\n                self.doc_embedding_db = doc_embedding_db\n                self.encoding = tiktoken.encoding_for_model(self.config.model_name)\n        \n                self.reset()\n        \n            \n        get_context_buffer(self) -> str\n        \n        indent() -> str\n        \n        process_ast(self, symbol: Symbol) -> None\n        \n        process_docstring(self, ast_object: RedBaron) -> None\n        \n        process_documentation(self, symbol: Symbol, is_main_symbol: bool) -> None\n        \n        process_headline(self, symbol: Symbol) -> None\n        \n        process_imports(self, symbol: Symbol) -> None\n        \n        process_message(self, message: str) -> None\n        \n        process_method(self, method: RedBaron, is_main_symbol: bool) -> None\n        \n        process_symbol(self,\n                symbol: Symbol,\n                related_symbols: List[Symbol] = [],\n            ) -> None\n        \n        reset(self) -> None\n        \n    automata.tests.unit.test_py_code_retriever.getter\n    \n        @pytest.fixture\n        def getter(module_map):\n            return PyCodeRetriever(module_map)\n        \n        \n        \n        \n    automata.core.coding.py_coding.retriever.PyCodeRetriever\n    \n        `PyCodeRetriever` is a class designed to fetch Python code from a specified module, enabling the retrieval of source code, docstrings, and source code without docstrings for a given module, class, or function/method. Through methods like `get_docstring`, `get_source_code`, and `get_source_code_without_docstrings`, it offers a way to programmatically analyze, extract, and comprehend Python projects. However, this class assumes a specific directory structure for the modules and relies on the RedBaron library for parsing, which may have limitations when parsing complex or unconventional code patterns.\n        \n        An example usage of `PyCodeRetriever` for retrieving the source code of a function from a specified module is as follows:\n        \n        ```python\n        from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        \n        module_tree_map = LazyModuleTreeMap.cached_default()\n        code_retriever = PyCodeRetriever(module_tree_map)\n        \n        module_dotpath = \"mymodule.example\"\n        object_path = \"ExampleClass.example_function\"\n        \n        source_code = code_retriever.get_source_code(module_dotpath, object_path)\n        print(source_code)\n        ```\n        \n        \n      Class Docstring:\n        Code retriever for fetching python code\n        \n      Methods:\n        def __init__(self, module_tree_map: LazyModuleTreeMap = LazyModuleTreeMap.cached_default()):\n                self.module_tree_map = module_tree_map\n        \n            \n        get_docstring(self, module_dotpath: str, object_path: Optional[str]) -> str\n        \n        get_docstring_from_node(node: Optional[FSTNode]) -> str\n        \n        get_source_code(self, module_dotpath: str, object_path: Optional[str] = None) -> str\n        \n        get_source_code_without_docstrings(self, module_dotpath: str, object_path: Optional[str]\n            ) -> str\n        \n    automata.core.context.py_context.retriever.PyContextRetriever.__init__\n    \n      Class Docstring:\n        Args:\n        graph (SymbolGraph): The symbol graph to use\n        config (PyContextRetrieverConfig): The configuration to use\n        \n      Methods:\n        def __init__(\n                self,\n                graph: SymbolGraph,\n                config: PyContextRetrieverConfig = PyContextRetrieverConfig(),\n                doc_embedding_db: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                Args:\n                    graph (SymbolGraph): The symbol graph to use\n                    config (PyContextRetrieverConfig): The configuration to use\n                \"\"\"\n                self.graph = graph\n                self.config = config\n                self.indent_level = 0\n                self.doc_embedding_db = doc_embedding_db\n                self.encoding = tiktoken.encoding_for_model(self.config.model_name)\n        \n                self.reset()\n        \n            \n    automata.tests.unit.test_py_writer.python_writer\n    \n        @pytest.fixture\n        def python_writer():\n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            return PyCodeWriter(retriever)\n        \n        \n        \n        \n    automata.core.coding.py_coding.writer.PyCodeWriter.__init__\n    \n      Class Docstring:\n        Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n        Args:\n        python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n        \n      Methods:\n        def __init__(self, python_retriever: PyCodeRetriever):\n                \"\"\"\n                Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n                Args:\n                    python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n                \"\"\"\n                self.code_retriever = python_retriever\n        \n            \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.coding.py_coding.writer.PyCodeWriter\n    \n        PyCodeWriter is a utility class designed for writing and updating Python code in the Abstract Syntax Tree (AST) format, enabling programmatic manipulation of Python elements such as classes, functions, and imports. The main functionality includes initializing with a PyCodeRetriever instance, creating a new module object from source code, updating an existing module, and writing the updated module to disk. However, PyCodeWriter's primary limitation is its reliance on RedBaron, which has known limitations and bugs, along with relatively low support in recent years. Additionally, error reporting in PyCodeWriter can be improved for a better user experience. \n        \n        ```python\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        from automata.core.coding.py_coding.writer import PyCodeWriter\n        \n        # Initialize the PyCodeWriter with a PyCodeRetriever instance\n        retriever = PyCodeRetriever()\n        writer = PyCodeWriter(retriever)\n        \n        # Create a new module object from source code\n        module_dotpath = \"my_module\"\n        source_code = \"def hello():\\n    print('Hello, World!')\\n\"\n        writer.create_new_module(module_dotpath, source_code)\n        \n        # Update the existing module by adding a new function\n        new_function_code = \"def goodbye():\\n    print('Goodbye, World!')\\n\"\n        writer.update_existing_module(module_dotpath, new_function_code, do_write=True)\n        ```\n        \n      Class Docstring:\n        A utility class for writing Python code along AST nodes\n        \n      Methods:\n        def __init__(self, python_retriever: PyCodeRetriever):\n                \"\"\"\n                Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n                Args:\n                    python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n                \"\"\"\n                self.code_retriever = python_retriever\n        \n            \n        create_new_module(self, module_dotpath: str, source_code: str, do_write: bool = False) -> None\n        \n        delete_from_existing__module(self, module_dotpath: str, object_dotpath: str, do_write: bool = False) -> None\n        \n        replace(match) -> None\n        \n        replace_newline_chars(input_str: str) -> str\n        \n        update_existing_module(self,\n                module_dotpath: str,\n                source_code: str,\n                disambiguator: Optional[str] = \"\",\n                do_write: bool = False,\n            ) -> None\n        \n    automata.tests.unit.test_py_writer.test_write_and_retrieve_mock_code\n    \n        def test_write_and_retrieve_mock_code(python_writer):\n            mock_generator = MockCodeGenerator(\n                has_class=True,\n                has_method=True,\n                has_function=True,\n                has_import=True,\n                has_module_docstring=True,\n                has_class_docstring=True,\n                has_method_docstring=True,\n                has_function_docstring=True,\n            )\n            source_code = mock_generator.generate_code()\n            python_writer._create_module_from_source_code(\"sample_module_2\", source_code)\n        \n            python_writer._write_module_to_disk(\"sample_module_2\")\n        \n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            module_docstring = retriever.get_docstring(\"sample_module_2\", None)\n            assert module_docstring == mock_generator.module_docstring\n        \n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.database.provider`/SymbolDatabaseProvider#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.database.provider", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolDatabaseProvider", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolDatabaseProvider\n\n`SymbolDatabaseProvider` is an abstract base class for database providers that handle symbol embedding storage and retrieval. The class defines a set of abstract methods for interacting with symbol embeddings, such as adding, updating, clearing, and retrieving embeddings from the database. Implementations of `SymbolDatabaseProvider` can utilize different storage methods, such as in-memory storage, file storage, or using external storage services. Related symbols include `automata.core.symbol.symbol_types.Symbol`, `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`, and `automata.core.database.vector.JSONVectorDatabase`.\n\n## Overview\n\nThe `SymbolDatabaseProvider` serves as a generic interface for managing database operations related to symbol embeddings. It provides a standardized way to interact with different types of databases, which allows for customization and flexibility in how symbol embeddings are stored and retrieved. The abstract base class ensures that all database implementations adhere to a consistent API. Subclasses may implement different storage mechanisms, which can be optimized for specific requirements or situations, while users can still interact with the database in a consistent way.\n\n## Related Symbols\n\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n- `automata.core.database.vector.JSONVectorDatabase`\n- `automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler`\n- `automata.core.symbol.graph.SymbolGraph`\n- `automata.core.database.vector.VectorDatabaseProvider`\n- `automata.core.embedding.embedding_types.EmbeddingProvider`\n- `automata.core.symbol.symbol_types.SymbolEmbedding`\n- `automata.core.embedding.embedding_types.SymbolEmbeddingHandler`\n- `automata.core.symbol.symbol_types.SymbolDescriptor`\n\n## Example\n\nAn example implementation of `SymbolDatabaseProvider` using a JSON file for storage:\n\n```python\nfrom automata.core.database.provider import SymbolDatabaseProvider\nfrom automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n\nclass JSONSymbolDatabase(SymbolDatabaseProvider):\n\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        # Initialize an empty list for storing SymbolEmbedding objects, and an empty dictionary for indexing.\n        self.data = []\n        self.index = {}\n\n    # Implement abstract methods as necessary for the specific storage method (e.g., adding, updating, clearing)\n```\n\n## Limitations\n\nSince `SymbolDatabaseProvider` is an abstract base class, it cannot be directly instantiated and requires the implementation of its abstract methods. Therefore, users need to subclass `SymbolDatabaseProvider` to provide their own database implementation with specific storage mechanisms. This allows for customization but might require users to have a deeper understanding of the underlying storage methods.\n\n## Follow-up Questions:\n\n- Are there any performance considerations or trade-offs when choosing different storage methods for `SymbolDatabaseProvider` implementations?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "AAAAII7Qmb8AAABg6lSRvwAAAEDC1Cc/AAAAgMTgo78AAADgHG6dvwAAAGAVAqE/AAAAAPXAUT8AAAAAP8F8vwAAAMDF+Ie/AAAAoMcKmL8AAADgpbGUvwAAACDkKok/AAAAYNvNZr8AAABgpJySPwAAAIB8GWc/AAAAgP0gdj8AAABg5jaVPwAAACCBWI0/AAAAoEcenz8AAAAgoIFovwAAAABwm3Y/AAAAIN3fhr8AAAAgTkWVvwAAAKCyLHO/AAAA4AJXVr8AAABA+xSaPwAAAOCDXpU/AAAAgLE7nb8AAADAdcuCvwAAAEA9r4w/AAAAYKarcL8AAADg5TypvwAAACAp73+/AAAAwPK0hb8AAABgPJGEPwAAAIADTnC/AAAAYDqCdj8AAABgUoqfvwAAAKCXIaQ/AAAAgCrdkz8AAABge/6QPwAAAMCaS2g/AAAAQLynfb8AAABgnGCavwAAAODraXO/AAAAAOlmnT8AAADAv8udvwAAAKD38Im/AAAAgF3we78AAABA1IWGvwAAAGAhhoU/AAAA4OEenT8AAAAgv6qTvwAAAECOzXc/AAAAIJ5yij8AAAAAn2aCPwAAACCWDIK/AAAAgJLogT8AAACghXCFvwAAAKBpSpC/AAAAAEXuhj8AAACgkwOYPwAAAICMu4e/AAAAYOhFg78AAAAghXaZvwAAAGCcYJq/AAAA4Es5eb8AAABAQc2YPwAAAACt+ZQ/AAAAYPr2kT8AAADgo6KmPwAAAICOyqU/AAAAgLl3dT8AAACAfihlPwAAAGA6gpY/AAAAgO1+pb8AAABga1xwvwAAAACTDJ4/AAAAgLNKi78AAADgIYBxvwAAAKD21YO/AAAAoId/k78AAADATUuJvwAAAEAu/pE/AAAAQPGfgz8AAACgI5KRPwAAAMBtj5q/AAAAAIJMhT8AAAAA63WLvwAAAOCFbYO/AAAAgAE/oj8AAADgIIyZPwAAAEDG8oM/AAAAQF8CfD8AAABgkfeLPwAAAACr6qY/AAAAYN3chD8AAABAyAGSPwAAAGA+oGI/AAAAQKvnlL8AAAAAVZCHvwAAAOC8nnc/AAAAYLQ+o78AAADgrPyGvwAAAOBD06C/AAAAwOYwgb8AAADgrReNvwAAAOC+rZW/AAAA4FSTmT8AAABAp8l4PwAAAKC4g42/AAAAgMTgoz8AAAAgEPOevwAAAAAgbqG/AAAAgGMdBj8AAACA629XPwAAAMBlKZI/AAAA4KGTiD8AAADg9d5pvwAAAIBVioO/AAAAoJ+HnD8AAABA63KZPwAAAGBQUZE/AAAAoLQ7kb8AAAAgu4yHPwAAAEDasqC/AAAAwNjHPj8AAADgZDWKvwAAAKDxw4+/AAAAADVMZr8AAACA7X6VvwAAACBtbpA/AAAAQC7+kb8AAADAs0d5vwAAAAD9Jnq/AAAAABpBlz8AAACA+QKavwAAAMCmz4y/AAAAAGQXkj8AAAAAnVeUvwAAAKACWpg/AAAAQNSFlj8AAACgtDuRvwAAAKC0O4E/AAAA4OU8qb8AAACAjLt3PwAAAOA3eXw/AAAAQEHNmD8AAACAV5mBPwAAAEBPYHu/AAAAAMTmdz8AAACgz0ZgPwAAAMBpcZ6/AAAAoNF/nr8AAAAAdsiAvwAAAKC8oUk/AAAAoBDtir8AAAAAtV9NvwAAAKBMMHO/AAAAoAJamL8AAABAYgWiPwAAAACr6pY/AAAA4N3WkL8AAAAAWsx7vwAAAEA5Z5A/AAAAYI/onT8AAADAhos7PwAAAKCJjmG/AAAAQLRBlb8AAABALO+DPwAAACBE+n6/AAAAIOQqGT8AAADA/R2UvwAAAMDwpXe/AAAAYJMGmr8AAACgFhpFvwAAAAAeX4M/AAAAINnBWj8AAAAA7YSZvwAAAODCy5G/AAAAoLiDnT8AAACANmGYvwAAAEBTfpc/AAAAYKKNpD8AAADgBGaUvwAAACAVBZO/AAAAID6jhD8AAABAmTZ2vwAAAOCLxJ0/AAAAwB9xYz8AAACAo6iaPwAAAICQ2ZM/AAAAoN3Zgj8AAABAWauBvwAAACDRW+K/AAAAAMDIez8AAAAAGkGHvwAAACBtbrC/AAAAwL/Ljb8AAAAgewGDPwAAACBmTZ6/AAAAYMcNej8AAABgBGyovwAAAMANwKQ/AAAAIL2bhT8AAABgHWiJvwAAAGDPSYK/AAAAoO17oz8AAADASh5zPwAAAMABPKC/AAAA4DMxoD8AAABg4fqgvwAAAEDUhYY/AAAAoM03gj8AAABAWauRvwAAAID/L6Q/AAAAwCraob8AAAAgjtCJPwAAAKCBUpk/AAAAQFWNpT8AAADAjLiFvwAAAMCEfI0/AAAAgDyOoj8AAABgmlGMPwAAAOAxIqK/AAAAIPCunT8AAADgLh+cPwAAACB7AZO/AAAAwPTDoz8AAAAglgySPwAAAAD1wJG/AAAAAMwioD8AAAAAkwyOPwAAAIBb4Z0/AAAAACrjh78AAABgb6ScvwAAAKAGeHQ/AAAAoGQ4nD8AAAAAqduIPwAAAIDKN34/AAAAALhigz8AAABAcqeCPwAAAECbRYS/AAAAgEPZhD8AAACgkfSJPwAAAABSZlO/AAAAYOpUcT8AAABADcaIPwAAACAvHJo/AAAAQAmoXD8AAADg2biUPwAAAKBxsJi/AAAAwOADlz8AAADAVYeBPwAAAKC0O4E/AAAAQEtCbz8AAADAmz+QPwAAAOAr9Ye/AAAAoH9De78AAAAA/hqSPwAAAOA9pma/AAAAwHCSQL8AAAAg8K5tvwAAAEDaspC/AAAAoDVDcD8AAAAg02qQPwAAACCS7oU/AAAAQB5ckb8AAADALiKOPwAAAMALsZY/AAAAoMxDmj8AAACAkNmDvwAAACBQVHO/AAAAQFFvmT8AAAAgyy6YPwAAAGBlL4a/AAAAYEwzlb8AAACAQ9lkvwAAACAGfqg/AAAAoHfdkj8AAABgqOSOvwAAAAAAKnC/AAAAYB93dz8AAADg4y17vwAAAOCyKZE/AAAA4G6AoD8AAADA0XycvwAAAEBXnKO/AAAAoFi0Jz8AAADgo6KWPwAAACCYG3A/AAAA4MC8o78AAAAgu4x3vwAAAKACWmg/AAAA4PbSEb8AAAAguX2ZvwAAACCuFIu/AAAAwA3AhD8AAABgv6eRPwAAAGCyL3W/AAAAYGICkL8AAAAAboyYPwAAAGCijXQ/AAAAIFBUYz8AAACgVqV5PwAAAMB8FpW/AAAAYKargD8AAACAm0KSPwAAAKB26Xo/AAAA4D+1pL8AAACgJcuvPwAAAAAktk2/AAAAoLQ7kb8AAAAgzT12PwAAAEDC1Je/AAAA4Hj1dr8AAADgqN5qPwAAAOCddXy/AAAAgH4odb8AAABgUFGhPwAAAGBg85G/AAAAoMcKiL8AAABg3dyUvwAAAIDxnIE/AAAAQM5YnD8AAACAiJ0LPwAAAEDIAZI/AAAAYOH6kD8AAABgu4mVPwAAACCaVI4/AAAAgJtCoj8AAAAgWa6DvwAAAOD+OJq/AAAAYMcNej8AAADABYSMPwAAAADf8WY/AAAAgFnSbz8AAADgaFOWvwAAAOAvE6S/AAAAwEXlkL8AAAAAXNuJvwAAAGB7/kA/AAAAwNrWfL8AAABAn2OAvwAAAODbx3I/AAAAwFKEW78AAADAxwd2PwAAAKAhg6M/AAAAQKGcjr8AAAAA0nmavwAAAGDqVJG/AAAAwIA0kb8AAABAcJhUPwAAAGCo5E6/AAAAgMTgkz8AAAAgpq5yPwAAAMDviqG/AAAAwMkWdD8AAADg0F6kvwAAAOBscYK/AAAAQCSzi78AAAAgK/6dPwAAACB11Gi/AAAAQI2yob8AAADgg16lvwAAAKDMQ3q/AAAAAJk5iD8AAAAgvZulPwAAAADf8XY/AAAAQFFvib8AAADA0GF2PwAAAOB32qA/AAAAgLVZmT8AAABACah8vwAAAMA6fJI/AAAAYEgVib8AAADAExefvwAAACDZwZq/AAAA4KOipj8AAAAgJaeDPwAAAGCTBpo/AAAA4Kjeer8AAACgEO2KPwAAAICdUWA/AAAAwL28f78AAADA5CGTPwAAAOBoU4a/AAAAwGELVr8AAABgOY6evwAAAGA+oJI/AAAAABDMoL8AAADAKMuDvwAAAAAAKnC/AAAAoMsolD8AAACArfOgPwAAAECdVHI/AAAA4PftZ78AAABgLxl4vwAAAGC0PoM/AAAAACjUib8AAADAqdJyvwAAAGAlpEE/AAAAACS2fT8AAADgcsiMPwAAAMBpcZ4/AAAAIHfjlj8AAABgLQp6PwAAAMDF+Ic/AAAAgEYDKb8AAACgamWWPwAAAOCVD5Q/AAAAYEYGiz8AAADAhHxtvwAAACA+o4Q/AAAAYFaom78AAABA5CdnvwAAACCWDHI/AAAAYG2VXj8AAAAgrhSLPwAAACAXFJE/AAAAQDlnoD8AAADAOnxSvwAAAOAvE2Q/AAAAgG+hqr8AAAAASQyTPwAAAAD/NYg/AAAAoKz/mL8AAACA1IKUvwAAACAT9oQ/AAAAYN3clD8AAADAOG1UvwAAAOABY56/AAAA4L6thT8AAACAKM6VvwAAAKC0O4G/AAAAIHfjlj8AAADA0nCkPwAAAODXqZa/AAAAYLuJlT8AAABgH3d3vwAAAEAMq4I/AAAAQDRVjD8AAAAA0nmavwAAAOAYJoG/AAAAYE5Co78AAAAAO3lQvwAAAICInXs/AAAAAJ1XlD8AAAAgwblxvwAAAEAks3s/AAAAAP4agr8AAAAgUmORPwAAAGCsAos/AAAAADEuij8AAADA+f+XPwAAACB340a/AAAAwGUpkj8AAACAdN1+PwAAAGDJHKg/AAAAwLNHab8AAABATVGNvwAAAEA0VYy/AAAAgFWKk78AAABgrhF5PwAAACCikJa/AAAAIC4BpL8AAACg1Z2avwAAAEANxoi/AAAAYARsmD8AAACg9/CZvwAAAGC9mJM/AAAAQMLUpz8AAACgooqCPwAAACAr/m0/AAAAAIV5i78AAAAgTDanvwAAAOD5/JU/AAAAQPGfkz8AAAAAyhOCvwAAAABazJu/AAAAAKW9jL8AAADg16mWPwAAAEA4c3i/AAAAwIA0kT8AAABAvKddvwAAAMB+JaM/AAAAILAjeT8AAABADrpQvwAAAOCJtY8/AAAAYJUViD8AAABgw++dPwAAAADWl3a/AAAAQDlnoL8AAABglRWYPwAAAOCP4mk/AAAAgK8sjz8AAADASh5DPwAAAIAcSpE/AAAAwFWHsT8AAACAZSyEvwAAAIAcSjG/AAAAYPwFcL8AAACguIN9vwAAACAjmKW/AAAAQJcnaL8AAABgYgJgPwAAAABe6pe/AAAAYL6ziT8AAAAg02qQPwAAAOC+rYU/AAAAAOUekb8AAABADKuSPwAAAKDRf54/AAAAoHXOlD8AAABgvKSbvwAAACC7jJe/AAAAIOY5l78AAAAgRgmNPwAAAOCfhJo/AAAAgANOgD8AAADA7paJvwAAAKAEaWa/AAAAwG2Pir8AAACA/y9EvwAAAACzUI+/AAAAQKvnlL8AAAAAuGKTPwAAAECAOmU/AAAAgP8vlL8AAABAT2CbvwAAAEBF62Q/AAAAYOhFgz8AAAAgRgmdPwAAAMANwJQ/AAAAgG6GpL8AAABgSiRnvwAAAKCebKY/AAAAoJUSpr8AAADgSSqLvwAAAAAJq16/AAAA4Gxxkr8AAADAbY+aPwAAAKBc0pM/AAAAgDZhmL8AAABge/6gPwAAAMDQYXa/AAAAIJYMkj8AAAAAtV+tvwAAAKAp6Wu/AAAAIKi9oD8AAABgYgKQPwAAAOAEZqQ/AAAA4MC8cz8AAAAgpq6SPwAAAMDa1pw/AAAAINeynD8AAADgwsuBPwAAAAD7F4w/AAAAAIA9pz8AAADgTUiXPwAAAOCLxH0/AAAAgEDWbr8AAACANmF4PwAAAECdVIK/AAAAwBMXn78AAAAA/hpyPwAAAKBiKY6/AAAAIPCujT8AAABAq+eUvwAAACBCwYA/AAAAAMoTkr8AAADgbHGSvwAAAOCgeKI/AAAAYBUCYb8AAACgbHRkPwAAAOAYJnE/AAAAIN3fhr8AAABAvKetvwAAAGBrXJC/AAAAAH4ueb8AAACA4AaJPwAAAGDXr5q/AAAAgG6GhL8AAABgnm9IvwAAAODnS5e/AAAAAPXAkT8AAAAgYRR8vwAAAKAQ7Xo/AAAAYDmOnj8AAADAhHyNvwAAAOA7l2g/AAAAoKz/eL8AAADAnFp2PwAAAEC4X4E/AAAAoDEldL8AAACg+OSBvwAAAKBIEne/AAAA4MLLgb8AAAAgvZt1vwAAAEAeXKG/AAAAYA/Vhr8AAABgkNylvwAAAADQajw/AAAA4Bgmgb8AAACgWsOFPwAAAKBpSnA/AAAAwBlEib8AAACg2buWPwAAAKBqZYY/AAAAANV8UD8AAAAg3MRQPwAAAOCs/IY/AAAAwEgPdT8AAAAA9cBBvwAAAKDPRpA/AAAAwFWHkT8AAAAAyhOSvwAAAGCq85y/AAAAQK32cr8AAACgPp1QPwAAAEBPYFs/AAAA4JHxl78AAACAHEqRPwAAACDqV2O/AAAAQOH9cr8AAADAdcuCvwAAAEDUhYa/AAAA4LiAOz8AAAAAtV9tvwAAAGDd3HS/AAAAQEXrlL8AAABAaFx8PwAAAODd1oC/AAAA4BYXUz8AAADgIptXvwAAAOCwGpM/AAAAQFFvmb8AAAAgc8WavwAAAKCDYXe/AAAAQOIYaT8AAAAAV5+FPwAAAOBXvZ0/AAAAgPsRaD8AAACAX/+ZPwAAAKCTA2g/AAAAYN/ror8AAAAgC7qMvwAAAOBawJO/AAAAQPOucT8AAADAqdKSPwAAAOAYJqG/AAAAwFFplb8AAABgnGB6PwAAAODOT4Y/AAAAoPXhm78AAAAgjMF7vwAAAIAJpTo/AAAAwOISdb8AAAAAtV99vwAAAMBwkpC/AAAAgLuGc78AAACgWLSXvwAAAKCDYZe/AAAAYHPCmL8AAADAJryFvwAAAIBd8Js/AAAA4AFjfj8AAACAMkOMPwAAACAvHJq/AAAAIAZ+aL8AAABA4wyRPwAAAACFeYs/AAAA4NBedD8AAAAgMzpWvwAAAOABY24/AAAAwHCSkD8AAADAsTibPwAAAAAJq54/AAAAwDyLoD8AAACANmF4vwAAACCDZ0s/AAAAQEXrlD8AAABA1pRkPwAAAKCkmUA/AAAAIGEUjD8AAABAQc1ovwAAAGCijZS/AAAAYN3cZD8AAAAAm0iWvwAAACDVo36/AAAAYEokl78AAABg3+tSvwAAAIA2YVg/AAAAwNaOkD8AAAAAbH2avwAAAEDh/YK/AAAAYDVGgr8AAADASA+lvwAAAAAJq56/AAAAoH00jT8AAAAgCI2GPwAAAODteJE/AAAAoGlKsL8AAABgiZGTvwAAAMBrgIy/AAAAQE1Rjb8AAACg8cN/PwAAAGDpYHk/AAAAgMo3jj8AAADg+wt0PwAAAMBvnpg/AAAAgDZhaD8AAABgamiIPwAAAOB/QEm/AAAAoN/okD8AAABgXuSTvwAAAMD5/4e/AAAAQEtCX78AAADAZziAPwAAAIC9laE/AAAAoMkZhj8AAACAjLtnPwAAAKAYKYM/AAAAwJxadj8AAABg3dwkPwAAAMCmz3y/AAAAYDyRpD8AAACA0nOWvwAAACD225e/AAAAIK4Uq78AAADgpbGkvwAAAABRcpu/AAAAII7Qmb8AAACgzTeSPwAAAGA3VXA/AAAAgNSClD8AAAAgA1SEPwAAACAfepm/AAAA4A7bOr8AAAAgcbaMvwAAAKDPRqA/AAAAwBMXj78AAABA866RPwAAAEAMq6I/AAAAwKnScr8AAADAGjiBvwAAAMBNS4k/AAAAwLNHiT8AAAAAzluOvwAAAKCVEpY/AAAAIJ5yij8AAADAo6WIvwAAAIDC0ZU/AAAAAGQXkj8AAADgA3KcvwAAAMDmMGE/AAAAYImRk78AAADAp8OEPwAAAOAtBJY/AAAAIJ5ymj8AAAAgQLJiPwAAAKCiipI/AAAAwP0ddL8AAAAgUFSDPwAAAKAhg6O/AAAAoKSZcL8AAADgQcRyvwAAAMBShIu/AAAAYIVzl78AAACgvrBHvwAAAEAOuqA/AAAAoId/oz8AAADADcCUvwAAACDun3+/AAAAIL+qo78AAACAxu9xvwAAAKAfdJW/AAAAQDJGfr8AAABA866RPwAAAKCuDoc/AAAAQBxNkz8AAACgTj+RvwAAAOBawJM/AAAAgNSCdL8AAABglgmQvwAAAEAMq4K/AAAAgJ1RkL8AAAAAhXmbPwAAAMBRaaW/AAAAQFWNlb8AAAAAN1uEPwAAAKC4g40/AAAAQLl6Zz8AAAAAj8SBPwAAAKAYKZO/AAAA4PPPe78AAAAg7GaRPwAAAGCN2X8/AAAAoEcePz8AAABAAUKUPwAAAICxO32/AAAAgK3zgL8AAAAgsCNJvwAAAKD38Gm/AAAA4E9Xdb8AAABA9/ZNvwAAAGBKJKc/AAAA4N3WoL8AAADgVqKnvwAAAOA9poa/AAAAwO6WeT8AAADAs0dpvwAAAEAq4IW/AAAAANV8cL8AAADAtVaHPwAAAGAdaKk/AAAAoPTGhT8AAACgSiFlvwAAACDmOZc/AAAAAKrPoD8AAADAo6WovwAAAGB574K/AAAAYKjknr8AAACgcbCYvwAAACADVIQ/AAAAIECykr8AAADg1ZqIvwAAACA8lIa/AAAAwJ5plL8AAAAA6WadPwAAAABe6oc/AAAAQDZkOr8AAADAJK13PwAAAGBzwmi/AAAAAMgElD8AAACgkwOIvwAAAOCJtX+/AAAAwGuAnD8AAACAfiiFvwAAAMAmvJW/AAAA4Cv1N78AAADgDMxMvwAAAKCiimI/AAAAAOMPg78AAAAAtlOVvwAAAGBGBou/AAAAQGhcrL8AAADgBGZkvwAAAOBawIO/AAAAYMPvjb8AAABg+OeTvwAAAKAEaVa/AAAAwJ5pZL8AAACAQcpWvwAAAKAzNHK/AAAAgAeWjD8AAADghW1TvwAAAKBmR3o/AAAAQCzvg78AAADAOG2UvwAAAOCfhIo/AAAAAGYmgD8AAADg2MSMvwAAAKD45IE/AAAA4LAaU78AAADgBnWSvwAAACD225e/AAAAwMcHlj8AAADA5CFjvwAAACB9EKE/AAAAwJxalj8AAADAUHWdvwAAAGAdaJm/AAAAwCfXez8AAABAlyd4vwAAAGBlL0a/AAAAgP8vdD8AAAAAKuN3vwAAAOA1ap4/AAAAgMLRVb8AAACAjsqVPwAAAICS6IE/AAAAoMcKWL8AAAAAKcihPwAAAEBkFKC/AAAA4BQIlT8AAAAAAUWGvwAAAADG9XW/AAAAIINnaz8AAADgoHhiPwAAAKBYtEc/AAAAAN/xhr8AAAAgmBtgPwAAAOCFbZM/AAAAQLRBVb8AAADAFzWrPwAAAOBcz6G/AAAAAI/Ekb8AAACg16xYPwAAAMAFhIw/AAAAACKnb78AAABAtlCTPwAAAMAXNYs/AAAA4NOLer8AAAAAm0hmvwAAAEAFYJA/AAAAwOADdz8AAABASQmBPwAAAIBH94C/AAAAQJUYmj8AAADg+wuUvwAAACBc2Jc/AAAAoLiDjb8AAACgAEtqPwAAAKC0O4E/AAAA4CGAQT8AAABAVY2VPwAAAODCy1E/AAAAQAVgoL8AAADglx5yPwAAACBMNme/AAAAwOIShT8AAADgo6KWvwAAAECXJ2i/AAAAwHwWhb8AAACARPR6vwAAAEDzroG/AAAAwIiaSb8AAACAHoNPPwAAAMCbP6C/AAAAIAVjoj8AAAAAPbKOvwAAAEAXO38/AAAAwE5mL78AAACg0X+evwAAACCggZi/AAAAgN73ij8AAABgqvOcvwAAAKC2dJ+/AAAAgAE/kj8AAAAg+OqFvwAAAMCmz4y/AAAAYNvNdr8AAABAuF9xPwAAAICzSmu/AAAAIC0NnD8AAADAp8OUPwAAAGAvGZi/AAAAACzydb8AAACAmTN0vwAAAOCZLaC/AAAA4HTXmj8AAADgHG6NvwAAAIDWkZK/AAAAwKOlyD8AAABAYRF6vwAAAEDYo4I/AAAAAI21kz8AAABAcJiUvwAAAICt85C/AAAAYOY2VT8AAADAJrx1PwAAAEDrcpm/AAAAgEHKVj8AAADgZkSIvwAAAEBoXIw/AAAAYCv7m78AAADgwLyDPwAAAODVmpg/AAAAIGtfor8AAACgVqWZvwAAAACowIK/AAAAYP4+nr8AAACgbHRUPwAAAMC9vG8/AAAAQPOugb8AAAAAO3lwvwAAAACHiIm/AAAAQOAJmz8AAAAAHFBVPwAAAEBF65S/AAAAwMcHdj8AAABg9MmXPwAAAGBrXKA/AAAAgPGcgb8AAADg2MR8PwAAAMBRaZU/AAAAwFWHkb8AAABgRgZ7PwAAAICnxpa/AAAAAOlmjT8AAACgAlpoPwAAAKCiimK/AAAAYJpRjD8AAAAAQ994vwAAAIDYoIC/AAAAIFi6e78AAAAAV5+FvwAAAEDC1Jc/AAAAoN/oYD8AAACAQuWMvwAAAGAlpIG/AAAAoHGweD8AAACAQuWcPwAAAACp24i/AAAAAEHQej8AAADASA+VPwAAAGAxKEY/AAAAIDAQkr8AAABANUmUvwAAAKAtB5g/AAAAoKz/iD8AAAAAKciBPwAAAMCjpZi/AAAAgEf3kL8AAABAtVxrPwAAACDRW4K/AAAAYLAghz8AAAAAVHWBvwAAAAAip58/AAAAAAFFhr8AAAAAqMCiPwAAAKA+nTA/AAAAIEgYWz8AAABAcqeSvwAAAECnyVg/AAAAwGc4kL8AAADgIIx5vwAAAKCBUlk/AAAAgKW3iL8AAADgcsicPwAAAECGkY8/AAAAIDIfkD8AAAAg4huLPwAAAAAgbkE/AAAA4C0EZj8AAABAmTZ2vwAAAGCVFZg/AAAAIPjqhT8AAABAP76avwAAAGAIipQ/AAAAwGlxjr8AAAAgYRQ8vwAAAEAeXGG/AAAAIAdyYD8AAABgXuSDvwAAAAC4YpO/AAAAwCKeeT8AAACgfTSNvwAAAIDMRly/AAAAQMHgjz8AAAAgUmOBPwAAACAyH5C/AAAAoDElpL8AAACgpJmAvwAAAMAbU7c/AAAAQLhfkT8AAADABYQcPwAAACAHcpC/AAAAYImRkz8AAADAegeXvwAAAAApyJG/AAAAAN3imL8AAABArwWBPwAAAADIBIQ/AAAAAD2ynr8AAABAfBxpPwAAAAAKn4Y/AAAAwCjLc78AAACAgDeDPwAAAMCr4aA/AAAAoJ14fr8AAAAA51ePPwAAAKCuDmc/AAAA4KB4kr8AAADAVYeRPwAAAGAvGXg/AAAAoCv4iT8AAABALO+TvwAAAGAMqIC/AAAAoKKKkr8AAACg046MPwAAAECXJ2i/AAAAgIJGob8AAADgrPyWPwAAAMDe9Ji/AAAAoGx0hD8AAACgXNJzvwAAAGA/u5g/AAAAgAWHjr8AAABg8rp5PwAAAOAYJmG/AAAAIMkfir8AAACgPamYPwAAAGCR94s/AAAAAMwikD8AAACgamVmvwAAAIBGA5k/AAAAQMoQgL8AAADAaXGevwAAAEBXnJO/AAAAIDM6lj8AAADgamKEPwAAAOAIhKC/AAAAIPbbd78AAABg3dxkPwAAACAT9oQ/AAAAYDudnL8AAABA866BvwAAAIALtKi/AAAAADEuir8AAABgb6ScvwAAACDiG5u/AAAAYOlgSb8AAABArfaivwAAAEDasqC/AAAAYFrGdz8AAAAAQdBqvwAAAOBD05C/AAAAIPbbh78AAADgkwDGvwAAAODOT5Y/AAAAwO+KkT8AAABg/AWAvwAAAOAMzIw/AAAA4N8Pj78AAADgd9qAPwAAAGCyL6W/AAAAYFi3mb8AAADgNWp+vwAAACAzOoY/AAAAQBo+db8AAABgkuujvwAAAACyNZm/AAAA4GImnD8AAADgcLlePwAAAADnV1+/AAAAYGICoL8AAACAuXeVPwAAAOCFbaM/AAAA4Neplj8AAADASh6DvwAAAODGE34/AAAAYN3clD8AAADAZzhgPwAAACDTapA/AAAAoLyhmb8AAABADrqAPwAAACBpUJQ/AAAAAFWQl78AAABA9/aNPwAAAACCTHW/AAAAIFzYhz8AAACAKM6FPwAAAMCmz4y/AAAAABYje78AAADA4hKFPwAAAIAFh56/AAAAgFWKk78AAABA75CFPwAAACBjI2q/AAAAwMPpiT8AAABAtVybvwAAAMD8KUy/AAAAYC0Kmj8AAACAs0qLPwAAAIANw4Y/AAAAALVfnb8AAADA/R2UPwAAAIAksJm/AAAAYDEodj8AAACgoHtkPwAAAEDvkIW/AAAAACjUeT8AAAAA63WbPwAAAGD8BZC/AAAAILl9ib8AAAAA9cCBPwAAAODVmlg/AAAAIPwIcr8AAAAAfyJxPwAAAOCR8Ze/AAAAgNSCdL8AAAAAs1CPvwAAAGCuEYk/AAAAAKvqlr8AAABgUFGhvwAAAEAo0Xc/AAAAwFFplb8AAABgMzeUvwAAAODKMZq/AAAAoKGWmj8AAACg0X9uPwAAAIBPXZk/AAAAAGYmgL8AAABgxf6bPwAAAGDlQn2/AAAAAEkMgz8AAADgibV/PwAAACAp74+/AAAA4MxAmL8AAADguo+ZPwAAAKC8oYm/AAAA4MLLgb8AAACgZkdqvwAAAADnVz+/AAAAYLZNkT8AAAAgyR+avwAAAEA1SZS/AAAAYNFYgL8AAACAyjeOPwAAAKBpSqC/AAAAQAu3ir8AAACA0nOGPwAAAODXqYY/AAAAYJxgaj8AAAAAIG5RPwAAAMB+JYO/AAAAIDM6lj8AAADAa4CMvwAAAAAeX5M/AAAAQKW6mj8AAAAAam6cvwAAAGDjM5+/AAAAQEtCX78AAABgyyuGPwAAAIDmM6O/AAAAYHv+gD8AAADgrReNPwAAAEASAl2/AAAAAGD5hb8AAAAgWa4zvwAAAKCwHaU/AAAAAFzbmT8AAADAHWJ1vwAAAIBuhqQ/AAAAYOMzf78AAACAZSx0vwAAACD225c/AAAAAD2ybj8AAACgtnSvPwAAAMC7g4E/AAAAQF8CjD8AAACAePuKPwAAAMB9MYu/AAAAYKB+Zj8AAACA1pGyvwAAAGB575K/AAAAIB96aT8AAADgYiZ8PwAAAICdUaC/AAAAQP8ylr8AAACAEeGCvwAAAKDAv5U/AAAAIECyor8AAACA6EKBvwAAAOCDXpW/AAAAQG6Jpr8AAACAmD+cvwAAAOBoU5a/AAAAICnvjz8AAADAGUSJvwAAAABXn5W/AAAAYGUvlj8AAACg506ZvwAAAKDz0o0/AAAAQANRYj8AAACA+QKKPwAAACCvCFM/AAAAQGMgiD8AAADg9tJRPwAAAIAaO5M/AAAAwGc4kL8AAABg+OeDvwAAACAtDYw/AAAAYM9Jkj8AAABAWauRPwAAAGBGBou/AAAAgL2Vgb8AAABgj+iNvwAAAGDHDVq/AAAAgLE7jT8AAADg+wuEvwAAAEAu/nG/AAAAYE5Coz8AAACg9tWTvwAAAABUdYE/AAAAQCjRh78AAABgE/OSPwAAAAD1wIG/AAAAoKSZoL8AAADAnmmEvwAAAIDD7Iu/AAAAAKF1YD8AAADAyRakPwAAAECGkX+/AAAAIAdyoL8AAABAt2uZvwAAACCU/ZO/AAAAgEDWXr8AAAAAYPmVPwAAACALumw/AAAA4Mslcj8AAADgibV/PwAAAEA1SYS/AAAAgNaRcj8AAACAVYqDvwAAAGBAr4A/AAAA4I3Ta78AAABA/SOYvwAAAODYxIy/AAAAoK4ORz8AAADAmDyavwAAAKDNN0I/AAAA4OEebT8AAAAgsjKXvwAAACDcxIC/AAAAgF3we78AAACgRx6PvwAAAAChdVA/AAAA4Dd5nD8AAADAT1qXPwAAAODhHl0/AAAAwAeTar8AAAAAfyKBPwAAAICr5IK/AAAAoH00fT8AAADgIIxZPwAAAIADToA/AAAAQL62m78AAACA6EKRPwAAAMCImpk/AAAAIFJjUb8AAABAt2uZPwAAAMC5dKM/AAAAwPK0lb8AAACAmD+MPwAAAKAUC5c/AAAAoBL8mD8AAACgNUOgvwAAAOBcz4G/AAAAgAeWbD8AAABgAl1qPwAAACD6+ZM/AAAAIAZ+eL8AAACAVYqDPwAAAEC8p62/AAAAoKKKgj8AAADAnmm0vwAAAMD5/5c/AAAAwA3AlD8AAABgDKiQvwAAAADE5oc/AAAAgJkzlL8AAADA5jBRPwAAACDLLpg/AAAAYJYJkD8AAAAAlypKPwAAAICbQpK/AAAAANaXZj8AAAAgLxyaPwAAAECfY5A/AAAAgFFsl78AAADg62mTvwAAACD8CKI/AAAAQK32cr8AAADANl6mPwAAAMC3ZZU/AAAA4Faih78AAABAqdiWPwAAACAr/o0/AAAAAI21oz8AAADAGjihvwAAACB9EHG/AAAAAP0mij8AAAAggViNPwAAAID382u/AAAAgCSwmb8AAACALOyBPwAAAKCge4S/AAAAQNqygL8AAAAAVZCnPwAAAOBPV5U/AAAAwKnSgr8AAADAmkuYPwAAAEC+tmu/AAAAoHXOpD8AAAAAVZCnPwAAAEBBzYi/AAAA4AJXpr8AAACAWdKPPwAAAGCWCaC/AAAAQPXnn78AAAAg7p9/PwAAAAAmxXu/AAAAwCa8lT8AAAAAtlNFvwAAAKB1zoS/AAAAQJk2hj8AAADA5jBxvwAAAED150+/AAAAQGQUoL8AAADgEOpYPwAAAMAuIo6/AAAA4CSqdT8AAADA3vRovwAAAAAnuWO/AAAA4AiEcL8AAADA+hqePwAAAOCyKaE/AAAA4BL5lj8AAABAT2CbvwAAAKDZu5Y/AAAA4DmIir8AAAAAqduovwAAAIAmv4e/AAAAQOQnhz8AAABgi6CBPwAAAGCU+pG/AAAAgEXogj8AAACAX/9pvwAAAGBKJIe/AAAAAJ1XlL8AAADABYScvwAAAKA7moo/AAAAgBxKgb8AAABgu4mFvwAAAAApyGG/AAAAALRElz8AAACAHEqhvwAAAKA/uGY/AAAAgCa/lz8AAADgIYCxPwAAAEC5eoc/AAAAoKB7hL8AAAAgh4WXvwAAAIAioYs/AAAAwEoeo78AAADAHWKFvwAAAEDE45U/AAAAIC4BhL8AAAAgHWt7PwAAAMBhC4Y/AAAAQIJJk78AAAAgB3JwvwAAAADOW34/AAAAAK35pD8AAADgrReNPwAAACBSY5E/AAAAoNvKhL8AAADg62lTPwAAAGAZSo2/AAAAgK3zoL8AAAAAxvWVPwAAACDiG5u/AAAA4AJXhr8AAACAgkZxPwAAAKCkmeA+AAAAgIqsib8AAABg4fqQPwAAACAGfqi/AAAAoMTdcT8AAAAguph/vwAAACAXFIG/AAAAgJLogT8AAABgWLeJvwAAAIBH95C/AAAAoL6whz8AAADgrRedvwAAAGDF/js/AAAAoM03oj8AAABAcqeCPwAAAGCP6I0/AAAAQA66kD8AAAAAkwx+vwAAAOCtF52/AAAAAKrPgD8AAADA8rRlPwAAACBE+o6/AAAAQL62i78AAABgUFGRvwAAACAxK5i/AAAAYJxgWr8AAAAgaVCEvwAAAECXJ4i/AAAAoKSZcD8AAABAC7eaPwAAAKBaw7U/AAAAALAmmz8AAACgMSVkPwAAAAB2yFC/AAAAQP8ylr8AAABgj+iNPwAAACCS7oU/AAAAgCrdQ78AAACAljCOPwAAACDTapC/AAAAAOMPY78AAADAMkCavwAAAOAWF5O/AAAAYEwzlb8AAADghW2DvwAAAICInYs/AAAAQNSFpr8AAACAIJKNPwAAAODraYO/AAAAYBHkhD8AAAAgB3KgPwAAAMBzvGQ/AAAAQFWNpT8AAABgJaRBPwAAACDVo46/AAAAwIJtbz8AAADA9MOjPwAAAAA/wYy/AAAAINzEcD8AAABAjs2HvwAAACCYG2A/AAAAYNvNlj8AAACgQcekvwAAAACR/Z+/AAAAABDMgD8AAABgGUqNPwAAAACZOXg/AAAAoAZ4dL8AAABAMA2QPwAAAKDVnUo/AAAAgBlHi78AAADgIYBxPwAAAIDumVu/AAAAgIJGob8AAAAg9tt3vwAAAMBjGoQ/AAAAYKjkjr8AAADgqN6KvwAAAECjq5y/"}]}]}, "source_code": "class SymbolDatabaseProvider(abc.ABC):\n    \"\"\"\n    Abstract base class for different types of database providers.\n    \"\"\"\n\n    @abc.abstractmethod\n    def save(self):\n        \"\"\"\n        Abstract method to save data.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def load(self) -> Any:\n        \"\"\"\n        Abstract method to load data.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def add(self, embedding: SymbolEmbedding):\n        \"\"\"\n        Abstract method to add an embedding to the database.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def update(self, embedding: SymbolEmbedding):\n        \"\"\"\n        Abstract method to update an existing embedding.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def discard(self, symbol: Symbol):\n        \"\"\"\n        Abstract method to discard a specific embedding.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get(self, symbol: Symbol) -> Any:\n        \"\"\"\n        Abstract method to get a specific embedding.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def clear(self):\n        \"\"\"\n        Abstract method to clear all embeddings.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def contains(self, symbol: Symbol) -> bool:\n        \"\"\"\n        Abstract method to check if a specific embedding is present.\n        \"\"\"\n        pass\n", "summary": "The SymbolDatabaseProvider is an abstract base class for managing symbol embedding storage and retrieval in databases. It offers a consistent API for interacting with different types of databases, allowing flexibility in storage methods such as in-memory, file or external storage services. To use it, users must subclass SymbolDatabaseProvider and implement its abstract methods for their chosen storage mechanism, providing customization based on their specific requirements while maintaining a standardized way of interaction.\n\nAs this is an abstract base class, direct instantiation is not possible, and users need to have a deeper understanding of the storage methods to implement their own database. For example, using a JSON file for storage:\n\n```python\nfrom automata.core.database.provider import SymbolDatabaseProvider\nfrom automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n\nclass JSONSymbolDatabase(SymbolDatabaseProvider):\n\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.data = []\n        self.index = {}\n```\n\nWhen choosing different storage methods, there might be performance considerations or trade-offs involved, depending on the specific requirements and situations.", "context": "\n    Generate the documentation for SymbolDatabaseProvider using the context shown below -\n  Building context for primary symbol - automata.core.database.provider.SymbolDatabaseProvider -\n  \n    Import Statements:\n      import abc\n      from typing import Any\n      from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n      \n      # SymbolDatabaseProvider\n      \n      `SymbolDatabaseProvider` is an abstract base class for database providers that handle symbol embedding storage and retrieval. The class defines a set of abstract methods for interacting with symbol embeddings, such as adding, updating, clearing, and retrieving embeddings from the database. Implementations of `SymbolDatabaseProvider` can utilize different storage methods, such as in-memory storage, file storage, or using external storage services. Related symbols include `automata.core.symbol.symbol_types.Symbol`, `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`, and `automata.core.database.vector.JSONVectorDatabase`.\n      \n      ## Overview\n      \n      The `SymbolDatabaseProvider` serves as a generic interface for managing database operations related to symbol embeddings. It provides a standardized way to interact with different types of databases, which allows for customization and flexibility in how symbol embeddings are stored and retrieved. The abstract base class ensures that all database implementations adhere to a consistent API. Subclasses may implement different storage mechanisms, which can be optimized for specific requirements or situations, while users can still interact with the database in a consistent way.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n      - `automata.core.database.vector.JSONVectorDatabase`\n      - `automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler`\n      - `automata.core.symbol.graph.SymbolGraph`\n      - `automata.core.database.vector.VectorDatabaseProvider`\n      - `automata.core.embedding.embedding_types.EmbeddingProvider`\n      - `automata.core.symbol.symbol_types.SymbolEmbedding`\n      - `automata.core.embedding.embedding_types.SymbolEmbeddingHandler`\n      - `automata.core.symbol.symbol_types.SymbolDescriptor`\n      \n      ## Example\n      \n      An example implementation of `SymbolDatabaseProvider` using a JSON file for storage:\n      \n      ```python\n      from automata.core.database.provider import SymbolDatabaseProvider\n      from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n      \n      class JSONSymbolDatabase(SymbolDatabaseProvider):\n      \n          def __init__(self, file_path: str):\n              self.file_path = file_path\n              # Initialize an empty list for storing SymbolEmbedding objects, and an empty dictionary for indexing.\n              self.data = []\n              self.index = {}\n      \n          # Implement abstract methods as necessary for the specific storage method (e.g., adding, updating, clearing)\n      ```\n      \n      ## Limitations\n      \n      Since `SymbolDatabaseProvider` is an abstract base class, it cannot be directly instantiated and requires the implementation of its abstract methods. Therefore, users need to subclass `SymbolDatabaseProvider` to provide their own database implementation with specific storage mechanisms. This allows for customization but might require users to have a deeper understanding of the underlying storage methods.\n      \n      ## Follow-up Questions:\n      \n      - Are there any performance considerations or trade-offs when choosing different storage methods for `SymbolDatabaseProvider` implementations?\n      \n    Class Docstring:\n      Abstract base class for different types of database providers.\n      \n    Methods:\n      @abc.abstractmethod\n          def add(self, embedding: SymbolEmbedding):\n              \"\"\"\n              Abstract method to add an embedding to the database.\n              \"\"\"\n              pass\n      \n          \n      @abc.abstractmethod\n          def clear(self):\n              \"\"\"\n              Abstract method to clear all embeddings.\n              \"\"\"\n              pass\n      \n          \n      @abc.abstractmethod\n          def contains(self, symbol: Symbol) -> bool:\n              \"\"\"\n              Abstract method to check if a specific embedding is present.\n              \"\"\"\n              pass\n      \n      @abc.abstractmethod\n          def discard(self, symbol: Symbol):\n              \"\"\"\n              Abstract method to discard a specific embedding.\n              \"\"\"\n              pass\n      \n          \n      @abc.abstractmethod\n          def get(self, symbol: Symbol) -> Any:\n              \"\"\"\n              Abstract method to get a specific embedding.\n              \"\"\"\n              pass\n      \n          \n      @abc.abstractmethod\n          def load(self) -> Any:\n              \"\"\"\n              Abstract method to load data.\n              \"\"\"\n              pass\n      \n          \n      @abc.abstractmethod\n          def save(self):\n              \"\"\"\n              Abstract method to save data.\n              \"\"\"\n              pass\n      \n          \n      @abc.abstractmethod\n          def update(self, embedding: SymbolEmbedding):\n              \"\"\"\n              Abstract method to update an existing embedding.\n              \"\"\"\n              pass\n      \n          \n  Building context for related symbols -\n  \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler\n    \n        The `SymbolDocEmbeddingHandler` class is responsible for generating, storing, and managing document embeddings for symbols in an AutomataDocs project. It relies on the `VectorDatabaseProvider`, `EmbeddingProvider` classes, and uses methods like `build_symbol_doc_embedding`, `update_embedding`, `get_embedding`, `get_doc`, and `get_summary` for managing symbol document embeddings and their summaries. The class utilizes various other components like `SymbolGraph`, `SymbolSimilarity`, and `SymbolRankConfig` to search, rank, and generate context for symbol embeddings. However, it has limitations concerning the embedding models and algorithms used and can sometimes produce suboptimal context or examples. Improving the underlying components can potentially enhance the embedding quality.\n        \n        Example usage:\n        \n        ```python\n        from automata.core.embedding.doc_embedding import SymbolDocEmbeddingHandler\n        from automata.core.database.vector import JSONVectorDatabase, VectorDatabaseProvider\n        from automata.core.embedding.embedding_types import OpenAIEmbedding, EmbeddingProvider\n        from automata.core.symbol.symbol_types import Symbol\n        \n        # Initialize the database provider and embedding provider\n        db_provider = VectorDatabaseProvider(JSONVectorDatabase(\"path/to/symbol_doc_embedding.json\"))\n        embedding_provider = EmbeddingProvider(OpenAIEmbedding())\n        \n        # Create an instance of SymbolDocEmbeddingHandler\n        embedding_handler = SymbolDocEmbeddingHandler(db_provider, embedding_provider)\n        \n        # Example symbol and source code\n        symbol = Symbol.from_string(\"symbol-uri-as-string\")\n        source_code = \"def example_function():\\n    pass\"\n        \n        # Build the symbol document embedding\n        symbol_doc_embedding = embedding_handler.build_symbol_doc_embedding(source_code, symbol)\n        ```\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n                code_embedding_handler: SymbolCodeEmbeddingHandler,\n                embedding_db_l2: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                A constructor for SymbolDocEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (EmbeddingProvider): The provider to get the embeddings from\n                    code_embedding_handler (SymbolCodeEmbeddingHandler): The code embedding handler\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n                from automata.core.embedding.symbol_similarity import SymbolSimilarity\n                from automata.core.symbol.search.rank import SymbolRankConfig\n                from automata.core.symbol.search.symbol_search import SymbolSearch\n        \n                graph = SymbolGraph()\n                subgraph = graph.get_rankable_symbol_subgraph()\n                symbol_similarity = SymbolSimilarity(code_embedding_handler)\n                self.graph = graph\n                self.symbol_search = SymbolSearch(\n                    graph, symbol_similarity, symbol_rank_config=SymbolRankConfig(), code_subgraph=subgraph\n                )\n                self.embedding_db_l2 = embedding_db_l2\n        \n            \n        build_symbol_doc_embedding(self, source_code: str, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_doc(prompt: str) -> str\n        \n        get_embedding(self, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_summary(input_doc: str) -> str\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n    automata.core.symbol.graph.SymbolGraph\n    \n        The `SymbolGraph` class represents a symbol graph that captures relationships between symbols found in source code files and is built from an index protobuf file. Utilizing NetworkX's MultiDiGraph, `SymbolGraph` represents relationships as a directed graph and includes methods for querying relationships, obtaining all available symbols and files, and filtering to subgraphs of rankable symbols. A navigator interface, _SymbolGraphNavigator, is required for getting reachable objects in the symbol subgraph.\n        \n        Example usage:\n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        \n        # Replace with your own file path\n        index_path = \"path/to/index.scip\"\n        symbol_graph = SymbolGraph(index_path)\n        all_symbols = symbol_graph.get_all_available_symbols()\n        ```\n        \n        Limitations include only being built from index protobuf files and the `get_potential_symbol_callers` method requiring downstream filtering to remove non-call statements. Future improvements may address these limitations and better handle edge cases in the symbol graph building process.\n        \n      Methods:\n        def __init__(\n                self, index_path: str = DEFAULT_SCIP_PATH, build_caller_relationships: bool = False\n            ):\n                \"\"\"\n                Initializes SymbolGraph with the path of an index protobuf file.\n        \n                Args:\n                    index_path (str): Path to index protobuf file\n                Returns:\n                    SymbolGraph instance\n                \"\"\"\n                index = self._load_index_protobuf(index_path)\n                builder = GraphBuilder(index, build_caller_relationships)\n                self._graph = builder.build_graph()\n                self.navigator = _SymbolGraphNavigator(self._graph)\n        \n            \n        get_all_available_symbols(self) -> List[Symbol]\n        \n        get_all_files(self) -> List[SymbolFile]\n        \n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n        get_rankable_symbol_subgraph(self, flow_rank=\"bidirectional\", path_filter: Optional[str] = None) -> SubGraph\n        \n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n    automata.core.database.vector.VectorDatabaseProvider\n    \n        `VectorDatabaseProvider` is an abstract base class designed for implementing custom vector database providers. It provides a basic structure for a vector storage system and requires subclasses to implement the `calculate_similarity()` and `get_all_symbols()` abstract methods. The former computes the similarity between a given vector and all stored vectors, while the latter retrieves a list of all symbols in the database. However, the base class does not offer built-in functionality for adding, updating, or removing symbols and their embeddings, requiring implementers to handle these operations themselves. A basic example implementation of the `VectorDatabaseProvider` class can be seen in the provided code snippet.\n        \n      Class Docstring:\n        Abstract base class for different types of vector database providers.\n        \n      Methods:\n        calculate_similarity(self, embedding: SymbolEmbedding) -> List[Dict[Symbol, float]]\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n    automata.core.embedding.embedding_types.EmbeddingProvider\n    \n        `EmbeddingProvider` is an abstract base class that serves as an interface for obtaining mathematical representations called embeddings for symbols, used in tasks such as similarity search, ranking, and other natural language processing-related work. Its single abstract method, `build_embedding`, should be implemented by all subclasses to provide specific embedding implementations. Users must create their own classes that inherit from `EmbeddingProvider` and implement these methods, which might be a limitation for those unfamiliar with custom classes and abstract methods.\n        \n        Here is an example of using the `OpenAIEmbedding` class, a concrete implementation of `EmbeddingProvider`:\n        \n        ```python\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        import numpy as np\n        \n        symbol_source = \"This is an example of a Python function.\"\n        embedding_provider = OpenAIEmbedding() \n        embedding = embedding_provider.build_embedding(symbol_source)\n        \n        # Check if the generated embedding is a numpy array\n        assert isinstance(embedding, np.ndarray)\n        ```\n        Performance and accuracy of embeddings depend on the specific model and approach used in the concrete implementation of `EmbeddingProvider`.\n        \n      Class Docstring:\n        A class to provide embeddings for symbols\n        \n      Methods:\n        build_embedding(self, symbol_source: str) -> np.ndarray\n        \n    automata.core.symbol.symbol_types.SymbolEmbedding\n    \n        SymbolEmbedding is an abstract base class used to represent various symbol embeddings, such as SymbolCodeEmbedding and SymbolDocEmbedding. It provides a basic structure for initializing and managing these embeddings, taking into account their source and their vector representation in the feature space. SymbolEmbedding is utilized by different embedding handlers like SymbolCodeEmbeddingHandler and SymbolDocEmbeddingHandler. As a base class, its functionality is limited and should be extended by classes with specific embedding types. An example of creating a SymbolCodeEmbedding instance is shown below:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def __init__(self, message): pass\"\n        vector = np.array([0.1, 0.2, 0.3])\n        \n        symbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Abstract base class for different types of embeddings\n        \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n    automata.core.embedding.embedding_types.SymbolEmbeddingHandler\n    \n        `SymbolEmbeddingHandler` is an abstract class that manages symbol embeddings by fetching and updating the vector embeddings related to various kinds of symbols. It must be subclassed by other classes that provide implementations of the defined abstract methods, such as `get_embedding()` and `update_embedding()`. The performance of these methods may depend on the chosen embedding provider and database used for storing the embeddings.\n        \n        Here is an example of how to subclass `SymbolEmbeddingHandler` and implement the abstract methods:\n        \n        ```python\n        from automata.core.embedding.embedding_types import SymbolEmbeddingHandler\n        from automata.core.symbol.symbol_types import Symbol\n        \n        class CustomSymbolEmbeddingHandler(SymbolEmbeddingHandler):\n            def __init__(self, embedding_db, embedding_provider):\n                super().__init__(embedding_db, embedding_provider)\n        \n            def get_embedding(self, symbol: Symbol):\n                # Implement logic to get the embedding for a custom symbol\n                pass\n        \n            def update_embedding(self, symbol: Symbol):\n                # Implement logic to update the embedding for a custom symbol\n                pass\n        \n        # Example usage:\n        custom_handler = CustomSymbolEmbeddingHandler(embedding_db, embedding_provider)\n        custom_embedding = custom_handler.get_embedding(custom_symbol)\n        ```\n        \n      Class Docstring:\n        An abstract class to handle the embedding of symbols\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"An abstract constructor for SymbolEmbeddingHandler\"\"\"\n                self.embedding_db = embedding_db\n                self.embedding_provider = embedding_provider\n        \n            \n        get_embedding(self, symbol: Symbol) -> Any\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n    automata.core.symbol.symbol_types.SymbolReference\n    \n        `SymbolReference` is a class representing a reference to a symbol in a file, used for managing references to symbols within a codebase. It offers utility methods for comparing and hashing symbol references based on their URI, line number, and column number. In conjunction with other symbol-related classes, it helps track and manage references to symbols in files based on their location and usage. However, there is a potential limitation of causing collisions when the same symbol is referenced in different files at the same location (line and column). This is rare, but important to consider when working with multiple symbol references across files.\n        \n        Example usage: \n        ```python\n        from automata.core.symbol.symbol_types import SymbolReference\n        from automata.core.symbol.parser import parse_symbol\n        \n        symbol_uri = \"example_uri\"\n        line_number = 10\n        column_number = 5\n        symbol = parse_symbol(symbol_uri)\n        \n        symbol_ref1 = SymbolReference(symbol, line_number, column_number)\n        symbol_ref2 = SymbolReference(symbol, line_number + 1, column_number)\n        \n        assert symbol_ref1 != symbol_ref2\n        assert hash(symbol_ref1) != hash(symbol_ref2)\n        \n        symbol_ref3 = SymbolReference(symbol, line_number, column_number)\n        assert symbol_ref1 == symbol_ref3\n        ```\n        \n      Class Docstring:\n        Represents a reference to a symbol in a file\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.database.vector`/JSONVectorDatabase#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.database.vector", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "JSONVectorDatabase", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# JSONVectorDatabase\n\n`JSONVectorDatabase` is a concrete class to provide a vector database that saves into a JSON file. It is part of the Automata documentation processing pipeline and is responsible for loading, saving, adding, updating, and discarding SymbolEmbedding objects in a JSON file. The class also includes methods for calculating similarity between vectors and retrieving all symbols present in the database.\n\n## Related Symbols\n\n- `automata.core.database.provider.SymbolDatabaseProvider`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.symbol_types.SymbolEmbedding`\n- `numpy`\n\n## Example\n\nThe following example demonstrates how to initialize a `JSONVectorDatabase`, add and retrieve `SymbolEmbedding` objects from it, and save the database to a JSON file.\n\n```python\nfrom automata.core.database.vector import JSONVectorDatabase\nfrom automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\nimport numpy as np\n\n# Initialize the JSONVectorDatabase\nvector_db = JSONVectorDatabase(\"example_vector_db.json\")\n\n# Create SymbolEmbeddings\nsymbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\nembedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n\nsymbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\nembedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n\n# Add SymbolEmbeddings to the database\nvector_db.add(embedding_1)\nvector_db.add(embedding_2)\n\n# Retrieve embedding for a specific symbol\nretrieved_embedding = vector_db.get(symbol_1)\n\n# Save the vector database to a JSON file\nvector_db.save()\n```\n\n## Limitations\n\nThe class currently has a `NotImplementedError` for the `calculate_similarity` method, which means there is no logic implemented for calculating similarity between vectors. \n\n## Follow-up Questions:\n\n- What similarity measure should be used for calculating similarity between vectors in the database?\n- Is there a more efficient storage structure to use other than a JSON file?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "AAAAINoNpr8AAABgAVyTvwAAAACntme/AAAAIIslk78AAADAX4CRvwAAAGC2BpI/AAAAoGBojj8AAACA9VJivwAAAEB7iZC/AAAA4BQXob8AAADgtmZ5vwAAAABgHGY/AAAAAL+ga78AAABgVMOIPwAAAAAJ+pA/AAAAwP08WL8AAAAA5iqWPwAAAKCXeow/AAAAYMaipD8AAACA+fmSvwAAAECfLHk/AAAAAHgGer8AAACgCUaZvwAAAICf3Jy/AAAAAGwRiD8AAAAAFe+SPwAAACDuUGm/AAAAQJfylr8AAADgc3N4vwAAAACffJU/AAAAYBWLd78AAACAhxqnvwAAAGCyX3E/AAAAAFRPYr8AAABAZId5vwAAAMDdLIG/AAAA4AVjiz8AAABg9jqfvwAAAKBE66g/AAAAQDiCgD8AAACgLD2SPwAAAICyS1I/AAAAQObGmr8AAACAUByYvwAAAAC/jHy/AAAA4JODnz8AAADASGqLvwAAAACffJW/AAAAgBVPir8AAACAf+CEvwAAAEAFF5M/AAAAwLL7pT8AAACgd36UvwAAAAAli4W/AAAAAItNgT8AAABgp1JcvwAAAECXBoY/AAAAYOpFfb8AAACAuoWEvwAAAOBbxYG/AAAAAJvpkz8AAADADcWbPwAAAGAlE4u/AAAAgHAsj78AAAAg1maVvwAAAADaNZS/AAAAgCxlkL8AAABAAYShPwAAAKC+BJc/AAAAoKKboD8AAADArmikPwAAAOBXHqE/AAAAoHdqVT8AAAAA2jVUPwAAACA115s/AAAAoIfymL8AAABAh35ivwAAAACrXWg/AAAAoNqBjL8AAABgHcV5vwAAAKDdQIC/AAAAQGzVir8AAACgEYCLvwAAAOCm8oQ/AAAAYNq9iT8AAAAgow+HPwAAAOAkn6S/AAAAwCTHoj8AAADApgaUvwAAAKCDS/g+AAAA4KJLlD8AAAAANf+ZPwAAAMAkx5I/AAAAYG9sgL8AAAAACQ5wPwAAACDiW4c/AAAAQNY+lz8AAACgbzCDPwAAAGBoBow/AAAAYKvljb8AAADAvtyYvwAAAKAdYV6/AAAAIFx1pb8AAADg1baRvwAAAABQlJK/AAAAIMqFYr8AAAAgOWqNvwAAAGDWKni/AAAAoK58kz8AAADga02FPwAAAGC6rXK/AAAAIIeSoT8AAADg2XGhvwAAAOAFT5y/AAAAQDwpkb8AAADAl1JuvwAAAIDxl6I/AAAAYDAgcD8AAABAJSeavwAAAID1UpK/AAAA4HvVmD8AAAAg8uOaPwAAAABwpJk/AAAAoHd+lL8AAAAA/tiMPwAAAAANoYG/AAAAwChukz8AAAAgETSDvwAAAGAVd5i/AAAAQCUner8AAAAgLZ2JvwAAAMD17qY/AAAAQIdqc78AAADg2XFxPwAAAKDK5Ym/AAAA4MqpnD8AAADAAdCJvwAAAICf3Gw/AAAAIHxxjb8AAAAA0ucyvwAAAGD5DZI/AAAAQPZinT8AAABADVGlvwAAACAFP2E/AAAAYJfep78AAACgi5mZPwAAACDqlVm/AAAAgG9Eoj8AAABgOG6BPwAAAMDlZnO/AAAAINoNdj8AAABAXDl4PwAAAIC6hZS/AAAAgKZWUL8AAADg1baRvwAAAOAcZWI/AAAAIB0Vlr8AAACgHWF+vwAAAEB7iVA/AAAAIEztkb8AAABgGR55PwAAAMAB0Ik/AAAAIOqVmb8AAAAAy22PvwAAAICbSZs/AAAA4KbelT8AAADAooeRPwAAAICuuJC/AAAAYFTDmL8AAADgBU+MvwAAAGAVi5e/AAAAAFydkz8AAAAAx8aevwAAAGAdxXk/AAAAQHT7nb8AAADg/RRavwAAAABofpY/AAAAwN4Afz8AAABA/dygvwAAAICDh5W/AAAA4NW2kT8AAADgGKqCvwAAAED+sJ4/AAAA4HOHpz8AAAAgVCeUvwAAAGDyk56/AAAAgB2diz8AAABgsnOQvwAAAID1UqI/AAAAwCwVhD8AAABg5p6cPwAAACCIZo8/AAAAgFz9ej8AAADgEUSOvwAAACAJ5uG/AAAAgL5ARD8AAADA3SyBPwAAAIDCv6a/AAAA4A2djT8AAACAvkA0PwAAAOAFT5y/AAAAQNY+dz8AAADA4b+ivwAAAOAYvpE/AAAAgM7Ih78AAABgUDB3vwAAACDetIa/AAAAQCU7mT8AAACgwquHPwAAAOCa/ZK/AAAAIFjOpD8AAACg7cijvwAAAMCmGoO/AAAAYFTXhz8AAABAu6mOvwAAAIBMYag/AAAA4I4coL8AAAAgOX6MPwAAAGDuAJ0/AAAAYI98lz8AAAAAyq2AvwAAAGBsrWw/AAAA4KbypD8AAACAn9yMPwAAACC70Zy/AAAAgCxRgT8AAACg4eeQPwAAAKDeKJ2/AAAAoP1Qpz8AAACgvhgWvwAAAGCPkIa/AAAAgCxloD8AAABgm3GJPwAAAICLrYg/AAAAoMKrl78AAABAi/2kvwAAAAANtXA/AAAAYAUDpD8AAACgTDlqPwAAAGBMnWU/AAAAIHQ3mz8AAABgJRNrvwAAACCEv36/AAAAgP14lb8AAADA2lmOPwAAAIDSR1o/AAAAQJNLhj8AAABA3qCXPwAAACBkr5c/AAAAAK8Eib8AAAAAq3GXPwAAAAAZgoS/AAAAQFimlj8AAABABStivwAAAMCih5E/AAAAQBWfdr8AAADg6fmUPwAAAECTS4a/AAAAAITnjL8AAACADRVYvwAAAABMAXG/AAAAYK+MXj8AAABgVNeXvwAAAOBXHpG/AAAAwFcyUD8AAADgypWNPwAAAED93IC/AAAAgOZ2bj8AAACgZ+KBPwAAAKCH8pg/AAAAAL+MnD8AAABg0m94PwAAAECD14G/AAAA4LoheT8AAACgsiOEPwAAAGB005+/AAAAIC2dmb8AAABAUFhlPwAAAODS454/AAAAwDj2lj8AAAAAQfSbvwAAACBBuF6/AAAAALvlez8AAADge9VYPwAAAGABXJM/AAAAYL5Uoz8AAACABceWvwAAAACLYaC/AAAAIAnmcT8AAAAAzmiAPwAAAKCukJI/AAAAgHP/kb8AAADgmv1CPwAAAGBMnSW/AAAAwPXudr8AAAAgAZiAvwAAACDeyGW/AAAA4MJbi78AAADAc6+VvwAAACANjXK/AAAAwKKHkb8AAADAmjmQPwAAAEDmxoo/AAAAoDgedb8AAABgbK2cvwAAAACXQpO/AAAAoAH4dz8AAACgY0+QPwAAAOCaEYK/AAAAIPaKq78AAADgNCeoPwAAACCbrVa/AAAAwP0oib8AAAAA3tx0PwAAAECTX5W/AAAAAEkujr8AAACgZA9vvwAAAKAsKXO/AAAAIEG4fr8AAACAKX6OPwAAAIDKIYe/AAAAADmSm78AAADgEHCgvwAAAACvGIg/AAAAIIs5kj8AAACgCUaJPwAAAOAg+JM/AAAAAN7chD8AAAAgFceUPwAAAMAceYE/AAAAYDwVoj8AAAAACs5OvwAAAMCPBI2/AAAAQCnOSr8AAADAMKiVPwAAAKAhCF8/AAAAwCA0YT8AAAAg9nacvwAAAEA96Z+/AAAAIFjOhL8AAABA7ihbvwAAACCHkpE/AAAAYPrhj78AAABgLU19PwAAAIDuxH8/AAAAgN48bD8AAABA/rB+vwAAAMDOZJw/AAAA4BBwgL8AAADgDZ2dvwAAAMBjJ5K/AAAAYM7chr8AAABA5tpZPwAAAADaSXO/AAAAwM54Sz8AAADgKDKWPwAAAMBXMpC/AAAA4DCAhz8AAADAAeSYvwAAAGCDr5O/AAAAAGwlZ78AAAAgDY2SPwAAAACzvyi/AAAAwPFblb8AAACAg3OGvwAAAKBotn+/AAAA4FvFkT8AAACg9RaVPwAAAEBg4Ig/AAAAIKMPdz8AAAAgGW6VvwAAAKDGPok/AAAAADmmmj8AAAAgzkCCvwAAAMC+8Ge/AAAAQEDQkb8AAABAOIJwvwAAACCbrZa/AAAAgL5ApD8AAADgqplVvwAAACANjaI/AAAAQDXDbD8AAAAAbBFovwAAAIDGZoc/AAAAoKrpgb8AAACANItzPwAAAADHxp6/AAAAQPoJXr8AAADA6Q2UvwAAAECLEYQ/AAAAAPL3mb8AAACgVIeLPwAAACBYuoU/AAAAYAmWhT8AAAAgm62GPwAAAED93GA/AAAAABmCZL8AAABA+TWQvwAAAMCb+X4/AAAAwCSzo78AAACA7QRhPwAAACBgCHe/AAAAgPn5gj8AAAAAQfRrPwAAACDmApg/AAAAgK64oD8AAABgUESGvwAAACARIJQ/AAAAYJ8Yij8AAADgKDKGPwAAAMAkx5I/AAAA4HNziD8AAACgIQhPPwAAAOBzc5g/AAAAoLa2lb8AAAAANRM5PwAAAGDC55Q/AAAAACV3Zr8AAABgr4x+PwAAAACnypY/AAAA4BFEXr8AAADAujWYPwAAAKA8xYU/AAAAICVjp78AAACgTDl6PwAAAECX8oY/AAAAYEQ7lb8AAACg/WSWvwAAAOBbxaE/AAAAoK6Qcr8AAAAgXGGGPwAAAEDejIi/AAAAwEAwab8AAADgRK+LvwAAAMCPBH2/AAAAAGTXhT8AAAAAUKiRPwAAAOAgDJO/AAAAYBkKmj8AAADgh7aLvwAAAEABhJE/AAAAgHAsfz8AAABgAUh0vwAAACDKmXE/AAAAYKO/mr8AAACACYKWvwAAAGD2Oo+/AAAAQNKXlj8AAAAg6qkoPwAAAOBXCpK/AAAAIIeSgb8AAABAp455vwAAAGA8FaI/AAAAgOZ2nj8AAACgX5SgPwAAAIDtBFG/AAAAoAlaWL8AAACg7dySPwAAACAJ0qI/AAAAIFQnlL8AAAAAVE+SvwAAAMD5qYa/AAAAgL5ARD8AAABgt9qPPwAAAOAJCpy/AAAAgDHMr78AAADAFRONvwAAAEBU/4W/AAAAgOLPnT8AAADg4ZeUvwAAAIARqJk/AAAAoBnOnD8AAACgrnyTPwAAAIB/4GQ/AAAAQLcCjj8AAACAUByovwAAAKC+GIY/AAAAwH+QeD8AAACAtt5zPwAAAECLEYS/AAAAgCxRUT8AAADANE+WPwAAAEA8KZE/AAAA4M48nj8AAABg4vd7PwAAAMDSH6w/AAAAQP6wjj8AAACgBbOHvwAAAMBcmY8/AAAAgCFEnD8AAACAYKSbPwAAAICqEZC/AAAAYHe6kb8AAADA5WaDPwAAAKBvMJM/AAAAwJOrfT8AAADg7XiXPwAAAMBEw3q/AAAAYJ8Eqz8AAABg8pNuPwAAAEBICpQ/AAAAQN6MeL8AAABA1lKGvwAAACCrSZm/AAAAQL6QcL8AAADA7aCFvwAAAIDeUJu/AAAAoCWvnz8AAACgj0CKPwAAAEDOBHU/AAAAoBnOjL8AAADAQDBpvwAAAKAgSKA/AAAAYEj2lD8AAAAA/ticvwAAAABcnaO/AAAAoOWOkb8AAABAAYSBPwAAACCPzJM/AAAA4L7IOb8AAABAdPuNvwAAAMA8iZi/AAAAAGh+pr8AAABAu6l+vwAAAABY9pK/AAAAwChuk78AAACgIEhQvwAAAACMNY4/AAAA4F9EpL8AAAAATdWevwAAAKBMOZo/AAAAwCSzkz8AAAAgDY2SPwAAAIBYQps/AAAAoJshnb8AAABASB6DvwAAAKB3aqU/AAAAwEBEqL8AAAAAtz5rvwAAAKDW2ou/AAAAgKu9j78AAACA6h1/PwAAAOD5bZk/AAAAYN54mb8AAACAcCyPPwAAAABB4Iy/AAAAwO2gdT8AAABAAXCivwAAAGDGonQ/AAAAoK58oz8AAADARNeJPwAAAEBgzKk/AAAAYPG/kL8AAAAgypmRPwAAACBA5KA/AAAA4MburD8AAAAAyq2QPwAAAAAZgmQ/AAAA4O14pz8AAADg6fmUPwAAAODCW4u/AAAAIA15Iz8AAAAggBiOPwAAAOAZkn+/AAAAYMLnlL8AAACgWBqNPwAAAGA1m46/AAAAILOXmj8AAABA9mJ9vwAAAGC2BoI/AAAAwNpZjr8AAABgg5uUvwAAAMCDI5o/AAAAwGfOcj8AAAAgbP0ovwAAAEB/MIE/AAAAIAnmgb8AAABAxrajvwAAAACMNZ6/AAAAIESLcT8AAADgQAhrPwAAACC/eJ2/AAAA4JoRkr8AAADAc5t2vwAAAEAd2Zi/AAAAIOqpiD8AAADgypWNvwAAAIBwLI+/AAAAAJOvQb8AAACgKIKSvwAAAACTr4G/AAAAQCGAmb8AAADg2XGhPwAAAGD9tIK/AAAAoAlGiT8AAACAZwqAPwAAAKDW2mu/AAAA4BQrkL8AAACgf7iGvwAAAIBrnaG/AAAA4MbubL8AAADAe+mHvwAAAKBkD3+/AAAAABmCZL8AAAAAePKKPwAAACCP4HI/AAAAQKshi78AAADA8VuVPwAAAEDm2ok/AAAAQP3cYD8AAACAqhGQPwAAAIARvIg/AAAA4P0Umj8AAAAgm8FlPwAAAKBgaF4/AAAAICVjlz8AAABA8rt8vwAAAOCWVqK/AAAAACkKeD8AAACA3jx8vwAAAKCmLpI/AAAA4BmSn78AAAAgxt6RPwAAAEDSq5W/AAAAAAKAjb8AAABAEQx1PwAAAOC2elg/AAAAQBEMhb8AAAAAw0ecvwAAAOB71Yg/AAAAANL7kb8AAABgPBWCPwAAAACXQoM/AAAAIGz9eD8AAABgj3xXvwAAAMAks3M/AAAAoGM7kb8AAAAA8guJvwAAAKAhCH8/AAAAwA3FSz8AAACAaN7NvgAAAAAOdY8/AAAA4CzZlj8AAABgdNOfPwAAAABsEZg/AAAAwDQ7l78AAACAb0SivwAAAICXtpk/AAAAAB0ppT8AAABAPemfPwAAAKCukJK/AAAAADmmGj8AAACgrpBSPwAAAAB8rWq/AAAA4Gs5lr8AAABgtgaSPwAAAEDyu4y/AAAAAJOvgb8AAAAASFqQPwAAAADaSYO/AAAA4PXGiL8AAADA2lmOvwAAAODS436/AAAAIN7Ilb8AAAAAWPaCvwAAACAxMEu/AAAAoJshXb8AAAAADnWPPwAAAMBQzJu/AAAAgOldcL8AAAAAQfRbPwAAAKCq6aG/AAAAwN4AX78AAACA4s+NPwAAAECvtIy/AAAAwFRLnj8AAAAgzkCiPwAAAACPCKE/AAAAgA0VqD8AAAAA6r2XvwAAAADS54K/AAAAYGRfWz8AAAAgHQFnvwAAAIBIzpY/AAAA4CD4kz8AAABgi+lVvwAAAAA9TYs/AAAAwChadD8AAAAAHSmFvwAAAABkwza/AAAAIM5Akr8AAADg2XFxPwAAAADmKpa/AAAA4K4slz8AAAAgGW5lvwAAACC3Kpy/AAAAgFzpm78AAADAsvulvwAAAOAV646/AAAAgMK/pj8AAAAgypmRPwAAAIBnCpA/AAAAYA0pp78AAAAANf+ZvwAAAKAJRok/AAAAwIfeaT8AAADg4ZeUPwAAAADyC4k/AAAAIIeSgT8AAABgj3yHPwAAAKB7/Ya/AAAA4CAMg78AAACAqhGgPwAAAKBAWHe/AAAA4FCkjT8AAAAgOX6cvwAAACCEv26/AAAAwJO/nD8AAACA8auRPwAAAOD12pc/AAAAoKNvjj8AAADgCfacPwAAAKC+BIe/AAAAoGBojj8AAAAgs5eKvwAAAADmFoe/AAAAINZmlT8AAAAgm61WvwAAACDuUJm/AAAA4OGXpL8AAABgdNOfvwAAAMBUS56/AAAAwF+Akb8AAAAgFcekPwAAAABofpY/AAAAoAlGiT8AAADgazl2PwAAAOB/aFo/AAAAAAkOgD8AAAAgq0mZvwAAAKCnFq8/AAAAwNayfb8AAAAgk3OUPwAAACCzl6o/AAAA4PEzVz8AAAAghL+evwAAAACrcZc/AAAAgAlulz8AAACgBbOHvwAAAKD50ZQ/AAAAAHytmj8AAABA+TWgvwAAAGAF74Q/AAAAwJdSnj8AAAAAMWyYvwAAAIAJbnc/AAAAwJO/nL8AAAAAfK2aPwAAACBs6Zk/AAAAwJo5cD8AAACABceWvwAAAIAJgoY/AAAAwEwli78AAACgtsqEPwAAAEBIHqO/AAAAwDQ7Zz8AAADgjhyQPwAAAGA1m34/AAAAQIsRpL8AAAAAdF+JPwAAAMAks5M/AAAAADX/qT8AAABAUFjVPgAAAEABcIK/AAAAgGudkb8AAABARGODvwAAAKDGUpi/AAAAoDR3lD8AAADAICCSPwAAAKAhCI8/AAAAIO5QeT8AAABgszOfvwAAAOBXCpI/AAAAYOpFfb8AAACA0kd6PwAAAOCSw4A/AAAAQMIPg78AAABAvpCgPwAAAKB3fqS/AAAAQObGmr8AAABABSuiPwAAAACXQlM/AAAAQERjgz8AAACAg4eVPwAAAIBwLJ+/AAAAwGt1k78AAACARCd2PwAAAADqvXc/AAAAgGcKkD8AAACAKX5evwAAAICq/ZA/AAAAgBVjmT8AAABgj5BmPwAAAAB48ko/AAAAQI+4RL8AAACgIQh/PwAAAKBYGo0/AAAA4Ez9nL8AAAAgu9GcvwAAAIB7OYS/AAAAgDgyVD8AAABAynFjvwAAAODZcYG/AAAAgFAceL8AAADAGNKQPwAAAGB7YaI/AAAAoPFvdD8AAAAgh5JRPwAAAACTr6E/AAAAAP7YnD8AAADAGbqtvwAAAEBU65a/AAAAwFjyjr8AAADARNeJvwAAAMCWfpA/AAAAAKM3hb8AAABg9jqPvwAAAICDh5W/AAAAoLpdhr8AAADg2V2iPwAAAEB7iYA/AAAAAIthkL8AAADgvrSKPwAAAEDKcUM/AAAAINK/lD8AAABAn0CIvwAAAMCTq22/AAAA4Ez9nD8AAABgsl9RvwAAAADuZIi/AAAAgDAMYT8AAADg+W15vwAAAOANnV2/AAAAAEhagD8AAABgQLyivwAAAGA0x4C/AAAAoGfiob8AAACgWBqdvwAAAIDalYu/AAAAANaOU78AAADAGbp9PwAAACAFP3G/AAAAYIvplb8AAAAAu/k6PwAAAKBn4pG/AAAAgGCkmz8AAACAJet8PwAAAEAJvpO/AAAAIAJYX78AAADgh6KMPwAAAADWjpM/AAAAYAFckz8AAADAX4CBvwAAAGBcEZq/AAAAwLaOZ78AAADgJJ+UvwAAACAxRJq/AAAAQBH4dT8AAACgj0B6vwAAAEDyu5w/AAAAwFvZoD8AAADAW9mQvwAAAEDa5Ze/AAAAoO3IM78AAABAcFR9vwAAAIBvWHG/AAAAYFh+iL8AAAAg7lCJvwAAAADe3KQ/AAAAQHT7bT8AAABgsl+RPwAAACDOLJM/AAAAgPnlcz8AAABgYLiaPwAAAKDWxpy/AAAAgGud8b4AAABgykmlvwAAAEA8KXE/AAAAQObaSb8AAADgazmGPwAAAOC6IXm/AAAAYPG/kD8AAACA2qmavwAAACDG8qA/AAAAwK5Udb8AAAAgOWqdPwAAAEDeoIe/AAAAYCX/m78AAAAgJU9oPwAAAGDqRY0/AAAAoGf2gL8AAAAgESCUPwAAAIDqHX8/AAAAwAV3mr8AAADgW8WhvwAAAACfkIQ/AAAAwFRLjr8AAABgusGBPwAAAOAgDJO/AAAAoKNvnj8AAADARNeJvwAAAOCqmYU/AAAAYMo1lr8AAAAAIeSEvwAAAAARXHE/AAAA4LLnhr8AAACAc+uSPwAAAEBswYs/AAAAAOYWh78AAACAZwqQPwAAAODdBIM/AAAAgGQ3jT8AAADg5VKUvwAAACDWeoQ/AAAAQN6gh78AAADA9e52vwAAAODZcYG/AAAAoCWvX78AAACAi62IPwAAAGCfBJu/AAAAQAUroj8AAABATMWTvwAAAMDip1+/AAAAwByNgL8AAABAOIKgvwAAAIBrsaC/AAAA4GP/cz8AAACgj0CavwAAAKBjT6C/AAAAQNY+dz8AAACAcCxfvwAAAAAJDmC/AAAAwJo5gL8AAAAgr/CZvwAAAIDKDWg/AAAA4Gs5lj8AAAAgWLqFPwAAAKBAbIY/AAAAoFgujL8AAACAZwqQvwAAAEAtYUy/AAAAII/gcj8AAACgVIeLvwAAAGD9oIO/AAAAICGoxz8AAAAA2klTvwAAACAJ0qI/AAAAgOodnz8AAADAjxh8vwAAACDDH16/AAAAYFBEhr8AAAAAi02RvwAAAEDOGJS/AAAAAItNcT8AAADA9e6GPwAAAACrXZg/AAAAoDDQk78AAAAgKfaIPwAAAMBjJ5I/AAAAINZ6lL8AAAAAoyOmvwAAAKAsKaO/AAAA4KJfk78AAABgYLiKvwAAAAANoWG/AAAAoHd+lL8AAADAvtx4PwAAAOAQcJC/AAAAwG8IhT8AAACAzsiHvwAAAGCTN4e/AAAAANaOcz8AAAAAi2GgPwAAAEBMxZM/AAAAoCwpc78AAADAyr1rvwAAAMAwvKQ/AAAAADFsmL8AAABAMQh9vwAAAABUO6O/AAAAoFSHiz8AAACAZDeNPwAAAKDeKG0/AAAAwEwlmz8AAACAvix1vwAAAKCyN6O/AAAAwK5Uhb8AAACAd6aSvwAAAAAClGw/AAAAgECAdT8AAADAAeRIPwAAAMAFi3k/AAAA4FNjcb8AAAAAk5uiPwAAAICLrYi/AAAA4I4ckL8AAACAwtOVPwAAACAxRIo/AAAAYEC8gr8AAAAAly6UvwAAAABUO5M/AAAAYEydZb8AAABA4h96PwAAAGCHVoS/AAAAYLYaYb8AAAAACs5uPwAAAKBflJA/AAAA4Fuxkj8AAADAFROdvwAAAOC2eoi/AAAAYHTTj78AAADAXJmfPwAAAMDhv4K/AAAA4K5AZj8AAAAgaEKJvwAAAMBQuEy/AAAAAC3Fl78AAAAAdF95vwAAACDuPFo/AAAAoBnii78AAADAm/mePwAAAEC+kIA/AAAAYMo1Rr8AAAAA6tGGPwAAAMCPGGw/AAAAIBludb8AAACg+b11PwAAAKA4CpY/AAAAAIthkL8AAACgJNuRvwAAAGB7YZI/AAAAoMKrp78AAACgKIKSvwAAAMBnunO/AAAAQOIfaj8AAABgp2abvwAAAGCzM4+/AAAAYDH0fb8AAACAZDedvwAAAGAJlmU/AAAAQFiSdz8AAABAutVwvwAAAACAQGy/AAAAgB2di78AAABABSuivwAAAIDi46w/AAAAoGQPnz8AAAAgLZ1ZvwAAAKD9ZHa/AAAAgM60mD8AAABgg5ukvwAAAEC2LqC/AAAAgLqZk78AAAAAs6t5vwAAAOBj63S/AAAAADX/mb8AAACAvix1vwAAAKBc1Ww/AAAA4AGoW78AAAAAMWx4PwAAAAAxbJg/AAAAIK/car8AAABgAVxzPwAAAEDCI4I/AAAAgGjefT8AAADgZ6aEPwAAAGAhbIq/AAAA4L7ImT8AAADA9e6WvwAAAEDSl5a/AAAAIObumL8AAACAHYmcPwAAAGCX3nc/AAAAQDiCkL8AAAAA1qKSPwAAAECvtJy/AAAAAA2hkT8AAAAgcHybvwAAAKAJWpg/AAAAQEyxdL8AAADAto6HvwAAAICnPn2/AAAA4AVje78AAACgOB6VPwAAAAAZgkQ/AAAAQLYuYL8AAAAA0ueSPwAAAMDxW3W/AAAAQDiCkL8AAACAPNmUvwAAAIAkA2C/AAAAYFhqiT8AAADAh8pavwAAAODOPJ6/AAAAQA1Rhb8AAAAgUIBzvwAAAOD5gYg/AAAAYHTTj78AAAAgk3OEvwAAAGBAqKO/AAAAQLcCTj8AAABAynGjvwAAAEDSq3W/AAAA4OGXlL8AAACA4s+tvwAAACBYupW/AAAAYEjidT8AAADgSFaMvwAAAADq0Za/AAAAIPaKi78AAACgvhjGvwAAAGDtGJA/AAAAwCTHkj8AAADgpvKkvwAAAMA0O4c/AAAAwJolcb8AAAAASS6OPwAAACDOLJO/AAAA4LZ6mL8AAADAytF6vwAAAIDGepY/AAAAAPILeT8AAADgFBehvwAAAACntpe/AAAAgJs1jD8AAAAASS6OPwAAAMC2omY/AAAAoAWfmL8AAADA5XqSPwAAAIA82aQ/AAAAYCFYmz8AAAAA3tyUvwAAAGBEO4U/AAAAYMo1Zj8AAACgIEiQvwAAACBIMqI/AAAAIPZ2fL8AAACASLpXvwAAAMBY8o4/AAAAQP6wnr8AAACgtraFPwAAACCTh4O/AAAAYIvplT8AAACAa7FQPwAAACAG/2+/AAAAAGAclj8AAACAZwqQPwAAAEBgzCm/AAAAgFSber8AAACg1sZcPwAAAECzb4w/AAAAwF+AgT8AAAAAw0ecvwAAAACMNV6/AAAAgEjOlj8AAADg6eWFPwAAAED93HA/AAAAAIw1nr8AAADgMJR2PwAAAAAld5a/AAAA4GP/gz8AAADAJMeSvwAAAKCjb44/AAAAAP7sa78AAADANE+mPwAAAOD5gZi/AAAA4J6ko78AAAAA1qKSPwAAAAA5pno/AAAAoJeOm78AAABAXE13PwAAAEB0+52/AAAAwEBEmL8AAADAjwSNvwAAAGBI4gW/AAAAQHuJoL8AAAAgBVOgvwAAACD2imu/AAAA4FcKkr8AAAAAh6ZgPwAAACBg9Ke/AAAAAJOboj8AAADAFRONvwAAAIDtBKE/AAAAoDzFRb8AAADAW9mAPwAAAGBAvJK/AAAAILvRjD8AAAAAn3x1PwAAAEA8PZC/AAAAQAFwor8AAAAAh6agPwAAAKCnFn+/AAAA4HOHh78AAABgt9qPPwAAAODOPG4/AAAAYGytfD8AAACAg4eVvwAAAEC+fJG/AAAAQEgKhD8AAABAlwZ2PwAAAEBA0KG/AAAAoCiWQb8AAABAHe2XPwAAAKBAWGe/AAAAgLbegz8AAADg2V1yvwAAAICLrYg/AAAA4BmSjz8AAABgp1KMvwAAAEBEY5M/AAAAICnimT8AAAAgdCOcvwAAACBs6Zm/AAAAgLbyAj8AAABAixGUPwAAAIAwDKG/AAAAwKJzkr8AAABgg6+TPwAAACDqlXm/AAAAgI9Uab8AAACAKX5+PwAAAMCXUo4/AAAAIMI3oT8AAAAgow+HvwAAAGCTN5c/AAAAYO7sjb8AAACgqtWCPwAAAAB8mZs/AAAAgNYCej8AAABgxqKkPwAAACAVx5Q/AAAAYFhqib8AAADAVzKQPwAAAIDOyDe/AAAAgFhWSr8AAACAeyW1vwAAAKBjT3C/AAAAQPk1QD8AAADgX1iTPwAAAECvyJu/AAAAoIcGeD8AAABgm116vwAAAEAJvqM/AAAAgDhGo78AAADgMJR2vwAAAGD5DZK/AAAAILvRnL8AAADAxiqavwAAAMBjE1M/AAAAoL4Yhr8AAAAAGZaDPwAAAODxM4e/AAAAgPU+kz8AAACAGfaavwAAAOA0J5g/AAAAwChaND8AAABAJTt5vwAAAIDiz52/AAAAgBVjaT8AAADADbGMvwAAAKBYGp0/AAAAANo1hD8AAAAAOaZqvwAAAGAx9G0/AAAAwK5UhT8AAADAX2ySPwAAAGCr5V2/AAAAANaigr8AAABgyjWWvwAAAEDSq6W/AAAAINZmdT8AAAAgUICDvwAAAACb6VO/AAAA4MYCnD8AAADgAaibvwAAAODp5YW/AAAAgDHMn78AAACAKX5+vwAAAIBc6Ys/AAAAwJ7Mkb8AAADgAbyKvwAAAIB3koO/AAAAIO5QeT8AAACgsjeDPwAAAGD9tIK/AAAAIPoxjL8AAAAAEVyBvwAAAKBE/4e/AAAAgIvBhz8AAAAA6tGGPwAAAACMNX4/AAAAIJutdj8AAABg8b+APwAAAGBU14e/AAAAwJ7gYD8AAADg0Q+hvwAAAOD5bZk/AAAAwLaihr8AAAAgQbiOPwAAAMDWso0/AAAAIMI3Ub8AAABguq2SvwAAAICHLna/AAAAoBU7az8AAACg3iiNvwAAAMD9PHi/AAAAAJObcj8AAABAl/KWvwAAAKDljnE/AAAAAC3Flz8AAACAyiGXPwAAAMD9KIm/AAAAYNYWib8AAABgBQOEPwAAAGCHQoW/AAAAIMJLkD8AAACAhxp3vwAAAKCfyI0/AAAAwFcygL8AAACAXOlrvwAAAKDSM3s/AAAA4CAMYz8AAACgaLaPPwAAAOA0J4g/AAAAAD1Nm78AAADgIPiTvwAAACAV24M/AAAA4CAMoz8AAACAbIWevwAAAKCXepy/AAAAQAm+kz8AAABAPClxPwAAAIAdiXw/AAAAoPUqZL8AAAAA2kmTPwAAAGBMiaa/AAAA4CSfdL8AAABgvmiyvwAAAGD2Oo8/AAAAIGhWmD8AAACArrigvwAAAOD9FIo/AAAAIIs5or8AAABgthqBvwAAAODOPH4/AAAA4FcKoj8AAABgsl9xvwAAACCEv26/AAAAgBVjiT8AAACgsjeTPwAAAIARvHi/AAAAAEhakL8AAACAvkCUvwAAAOA8dak/AAAAYJ8Yij8AAABAvpCgPwAAAEAtYZw/AAAAIMqFkr8AAABAh36SPwAAACA5ap0/AAAAoIfyqD8AAABAPel/vwAAAECX8na/AAAAoHPDhD8AAAAgxvKgPwAAAEBYpna/AAAAQPkhob8AAAAA5haHPwAAACA5fpy/AAAAgGyFjr8AAABAzhiUPwAAACBEi6E/AAAAYEjiVT8AAACgCUaJPwAAAGA0s2G/AAAAAAkOoD8AAADABXeaPwAAAGBMnaW/AAAAIKP7p78AAADA0gt9PwAAAMCqrZS/AAAA4JODj78AAADg3QSDvwAAAECX8kY/AAAAACV3Zj8AAABAvpBQPwAAAACHplA/AAAA4MqVfT8AAACgPLFWPwAAAIBkN42/AAAAoCiCor8AAAAA2jV0PwAAAED5IYG/AAAAwOKnjz8AAAAg+jF8vwAAAKDW2os/AAAAQGSHiT8AAACAQJSkPwAAAMDh05E/AAAA4Dx1mT8AAAAA8guJvwAAAMDh04E/AAAAACV3hr8AAACAkw+pvwAAAIBYQmu/AAAAIOqpiD8AAACA8ZcCPwAAAMCH3pm/AAAAQAUrcj8AAAAAdEt6PwAAAGDqWYy/AAAAwKYGlL8AAACABceWvwAAAEC+fHE/AAAAQHBonD8AAAAAzmhwvwAAACDmAng/AAAAYNYqmD8AAAAA+kWbvwAAAGBI4oW/AAAAoETriD8AAACAqv2wPwAAAEAVs5U/AAAAoOk1kr8AAADAIDQxvwAAAIDxl6I/AAAAwKqtpL8AAABgCZZFPwAAAEBg4Jg/AAAAAC2xiL8AAACgh/J4PwAAAGAF75Q/AAAAwBx5gb8AAADgpt6VvwAAAACTm3K/AAAAYL5Uoz8AAAAgCdKiPwAAAKA8sYY/AAAAICGod78AAADg0uN+vwAAAMDip3+/AAAAALv5ir8AAADAGNKAPwAAAOAgDJO/AAAAgKr9cD8AAABgaAZ8PwAAAAD6RXs/AAAAoP1kdr8AAAAAn5CUvwAAAIB7OaS/AAAAQGguOj8AAADArlSFPwAAAGCbcYk/AAAAwN0Ykj8AAADgzjxuPwAAAABwuIi/AAAAwJ7goD8AAACgWBqNvwAAAID9eIW/AAAAoINfpz8AAACAj2hIvwAAAACzq5k/AAAAIK/wmT8AAABgb2wgPwAAAOCeuJK/AAAAgL4shT8AAACg8W+EvwAAAADGBnC/AAAAwOkhgz8AAAAAGZaDvwAAAOCqmYW/AAAAgLqFFD8AAACArrigvwAAAMB3Voa/AAAAYG9skL8AAABAZIeZPwAAAGCL6bU/AAAAoLpxlT8AAAAgwx9+PwAAAMCaJVG/AAAAoJPnmr8AAABg7gCNPwAAAEBEY4M/AAAAIEztgT8AAABg/bRivwAAAKC6XZa/AAAAoJd6jD8AAADASGqbvwAAACACWJ+/AAAA4E+8oL8AAAAA4m+GvwAAAIARvJg/AAAAwG/0pb8AAADgg/ubPwAAAMBb2UA/AAAAYDH0Lb8AAABgOFqSPwAAAECnjpk/AAAAQP6wnj8AAABgNZt+PwAAAMAJMoq/AAAAIGD0hz8AAAAg4keYPwAAAOC2Zmm/AAAAQDXDTD8AAABgJROLvwAAAGB7TZM/AAAAALc+mz8AAACgrnyjvwAAACCnooi/AAAAwItxaz8AAADgVwqCvwAAAKDK+Vg/AAAAQAmqhL8AAAAAHSmFPwAAAGBvbJA/AAAAYIOblL8AAAAgPRFuPwAAAOAg+IO/AAAAwFRLnr8AAACAeyWFvwAAAADuZFg/AAAAQL9Qb78AAAAgs5eavwAAAAD+2Ky/"}]}]}, "source_code": "class JSONVectorDatabase(VectorDatabaseProvider):\n    \"\"\"\n    Concrete class to provide a vector database that saves into a JSON file.\n    \"\"\"\n\n    def __init__(self, file_path: str):\n        \"\"\"\n        Args:\n            file_path: The path to the JSON file to save the vector database to\n        \"\"\"\n        self.file_path = file_path\n        self.data: List[SymbolEmbedding] = []\n        self.index: Dict[str, int] = {}\n        self.load()\n\n    def save(self):\n        \"\"\"Saves the vector database to the JSON file\"\"\"\n        with open(self.file_path, \"w\") as file:\n            encoded_data = jsonpickle.encode(self.data)\n            file.write(encoded_data)\n\n    def load(self):\n        \"\"\"Loads the vector database from the JSON file\"\"\"\n        try:\n            with open(self.file_path, \"r\") as file:\n                self.data = jsonpickle.decode(file.read())\n                # We index on the dotpath of the symbol, which is unique and indepenent of commit hash\n                self.index = {embedding.symbol.dotpath: i for i, embedding in enumerate(self.data)}\n        except FileNotFoundError:\n            logger.info(\"Creating new vector embedding db at %s\" % self.file_path)\n\n    def add(self, embedding: SymbolEmbedding):\n        \"\"\"\n        Adds a new vector to the database\n\n        Args:\n            embedding: The vector to add\n        \"\"\"\n        self.data.append(embedding)\n        self.index[embedding.symbol.dotpath] = len(self.data) - 1\n\n    def update(self, embedding: SymbolEmbedding):\n        \"\"\"\n        Updates an embedding in the database\n\n        Args:\n            embedding: The vector to update\n\n        Raises:\n            KeyError: If the symbol is not in the database\n        \"\"\"\n        if embedding.symbol not in self.index:\n            raise KeyError(\"Symbol %s not in database\" % embedding.symbol)\n        self.data[self.index[embedding.symbol.dotpath]] = embedding\n\n    def discard(self, symbol: Symbol):\n        \"\"\"\n        Discards a vector from the database\n\n        Args:\n            symbol: The symbol to discard\n\n        Raises:\n            KeyError: If the symbol is not in the database\n        \"\"\"\n        if symbol.dotpath not in self.index:\n            raise KeyError(\"Symbol %s not in database\" % symbol)\n        index = self.index[symbol.dotpath]\n        del self.data[index]\n        del self.index[symbol.dotpath]\n        # Recalculate indices after deletion\n        self.index = {embedding.symbol.dotpath: i for i, embedding in enumerate(self.data)}\n\n    def contains(self, symbol: Symbol) -> bool:\n        \"\"\"\n        Checks if the database contains a vector for the given symbol\n\n        Args:\n            symbol: The symbol to check\n\n        Returns:\n            True if the database contains a vector for the given symbol, False otherwise\n        \"\"\"\n        return symbol.dotpath in self.index\n\n    def get(self, symbol: Symbol) -> SymbolEmbedding:\n        \"\"\"\n        Gets the vector for the given symbol\n\n        Args:\n            symbol: The symbol to get the vector for\n\n        Raises:\n            KeyError: If the symbol is not in the database\n        \"\"\"\n        if symbol.dotpath not in self.index:\n            raise KeyError(\"Symbol %s not in database\" % symbol)\n        return self.data[self.index[symbol.dotpath]]\n\n    def clear(self):\n        \"\"\"Removes all vectors from the database\"\"\"\n        self.data = []\n        self.index = {}\n\n    def calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]:\n        # Implement the logic to calculate similarity between the given vector and vectors in the data.\n        # This will depend on how the data is structured and the specific similarity measure to be used (e.g., cosine similarity).\n        # Here, just returning the data as a placeholder.\n        # return self.data\n        raise NotImplementedError\n\n    def get_all_symbols(self) -> List[Symbol]:\n        \"\"\"\n        Gets all symbols in the database\n\n        Returns:\n            A list of all symbols in the database\n        \"\"\"\n        symbol_list = [embedding.symbol for embedding in self.data]\n        return sorted(symbol_list, key=lambda x: str(x.dotpath))\n", "summary": "The `JSONVectorDatabase` class, part of the Automata documentation processing pipeline, provides a vector database that stores SymbolEmbedding objects in a JSON file. It handles loading, saving, adding, updating, and discarding these objects while offering methods for calculating similarity between vectors and retrieving all symbols in the database. However, the class currently has a `NotImplementedError` for the `calculate_similarity` method, indicating that similarity calculation logic has not been implemented yet. Possible follow-up questions include determining an appropriate similarity measure for comparing vectors in the database and considering more efficient storage structures aside from a JSON file.", "context": "\n    Generate the documentation for JSONVectorDatabase using the context shown below -\n  Building context for primary symbol - automata.core.database.vector.JSONVectorDatabase -\n  \n    Import Statements:\n      import abc\n      import logging\n      import logging.config\n      import jsonpickle\n      import numpy as np\n      from typing import Dict, List\n      from automata.core.database.provider import SymbolDatabaseProvider\n      from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n      \n      # JSONVectorDatabase\n      \n      `JSONVectorDatabase` is a concrete class to provide a vector database that saves into a JSON file. It is part of the Automata documentation processing pipeline and is responsible for loading, saving, adding, updating, and discarding SymbolEmbedding objects in a JSON file. The class also includes methods for calculating similarity between vectors and retrieving all symbols present in the database.\n      \n      ## Related Symbols\n      \n      - `automata.core.database.provider.SymbolDatabaseProvider`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.symbol_types.SymbolEmbedding`\n      - `numpy`\n      \n      ## Example\n      \n      The following example demonstrates how to initialize a `JSONVectorDatabase`, add and retrieve `SymbolEmbedding` objects from it, and save the database to a JSON file.\n      \n      ```python\n      from automata.core.database.vector import JSONVectorDatabase\n      from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n      import numpy as np\n      \n      # Initialize the JSONVectorDatabase\n      vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n      \n      # Create SymbolEmbeddings\n      symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n      embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n      \n      symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n      embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n      \n      # Add SymbolEmbeddings to the database\n      vector_db.add(embedding_1)\n      vector_db.add(embedding_2)\n      \n      # Retrieve embedding for a specific symbol\n      retrieved_embedding = vector_db.get(symbol_1)\n      \n      # Save the vector database to a JSON file\n      vector_db.save()\n      ```\n      \n      ## Limitations\n      \n      The class currently has a `NotImplementedError` for the `calculate_similarity` method, which means there is no logic implemented for calculating similarity between vectors. \n      \n      ## Follow-up Questions:\n      \n      - What similarity measure should be used for calculating similarity between vectors in the database?\n      - Is there more efficient storage structure to use other than a JSON file?\n      \n    Class Docstring:\n      Concrete class to provide a vector database that saves into a JSON file.\n      \n    Methods:\n      def __init__(self, file_path: str):\n              \"\"\"\n              Args:\n                  file_path: The path to the JSON file to save the vector database to\n              \"\"\"\n              self.file_path = file_path\n              self.data: List[SymbolEmbedding] = []\n              self.index: Dict[str, int] = {}\n              self.load()\n      \n          \n      def add(self, embedding: SymbolEmbedding):\n              \"\"\"\n              Adds a new vector to the database\n      \n              Args:\n                  embedding: The vector to add\n              \"\"\"\n              self.data.append(embedding)\n              self.index[embedding.symbol.dotpath] = len(self.data) - 1\n      \n          \n      def calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]:\n              # Implement the logic to calculate similarity between the given vector and vectors in the data.\n              # This will depend on how the data is structured and the specific similarity measure to be used (e.g., cosine similarity).\n              # Here, just returning the data as a placeholder.\n              # return self.data\n              raise NotImplementedError\n      \n          \n      def clear(self):\n              \"\"\"Removes all vectors from the database\"\"\"\n              self.data = []\n              self.index = {}\n      \n          \n      def contains(self, symbol: Symbol) -> bool:\n              \"\"\"\n              Checks if the database contains a vector for the given symbol\n      \n              Args:\n                  symbol: The symbol to check\n      \n              Returns:\n                  True if the database contains a vector for the given symbol, False otherwise\n              \"\"\"\n              return symbol.dotpath in self.index\n      \n          \n      def discard(self, symbol: Symbol):\n              \"\"\"\n              Discards a vector from the database\n      \n              Args:\n                  symbol: The symbol to discard\n      \n              Raises:\n                  KeyError: If the symbol is not in the database\n              \"\"\"\n              if symbol.dotpath not in self.index:\n                  raise KeyError(\"Symbol %s not in database\" % symbol)\n              index = self.index[symbol.dotpath]\n              del self.data[index]\n              del self.index[symbol.dotpath]\n              # Recalculate indices after deletion\n              self.index = {embedding.symbol.dotpath: i for i, embedding in enumerate(self.data)}\n      \n          \n      def get(self, symbol: Symbol) -> SymbolEmbedding:\n              \"\"\"\n              Gets the vector for the given symbol\n      \n              Args:\n                  symbol: The symbol to get the vector for\n      \n              Raises:\n                  KeyError: If the symbol is not in the database\n              \"\"\"\n              if symbol.dotpath not in self.index:\n                  raise KeyError(\"Symbol %s not in database\" % symbol)\n              return self.data[self.index[symbol.dotpath]]\n      \n          \n      def get_all_symbols(self) -> List[Symbol]:\n              \"\"\"\n              Gets all symbols in the database\n      \n              Returns:\n                  A list of all symbols in the database\n              \"\"\"\n              symbol_list = [embedding.symbol for embedding in self.data]\n              return sorted(symbol_list, key=lambda x: str(x.dotpath))\n      \n      def load(self):\n              \"\"\"Loads the vector database from the JSON file\"\"\"\n              try:\n                  with open(self.file_path, \"r\") as file:\n                      self.data = jsonpickle.decode(file.read())\n                      # We index on the dotpath of the symbol, which is unique and indepenent of commit hash\n                      self.index = {embedding.symbol.dotpath: i for i, embedding in enumerate(self.data)}\n              except FileNotFoundError:\n                  logger.info(\"Creating new vector embedding db at %s\" % self.file_path)\n      \n          \n      def save(self):\n              \"\"\"Saves the vector database to the JSON file\"\"\"\n              with open(self.file_path, \"w\") as file:\n                  encoded_data = jsonpickle.encode(self.data)\n                  file.write(encoded_data)\n      \n          \n      def update(self, embedding: SymbolEmbedding):\n              \"\"\"\n              Updates an embedding in the database\n      \n              Args:\n                  embedding: The vector to update\n      \n              Raises:\n                  KeyError: If the symbol is not in the database\n              \"\"\"\n              if embedding.symbol not in self.index:\n                  raise KeyError(\"Symbol %s not in database\" % embedding.symbol)\n              self.data[self.index[embedding.symbol.dotpath]] = embedding\n      \n          \n  Building context for related symbols -\n  \n    automata.tests.unit.test_database_vector.test_init_vector\n    \n        def test_init_vector(temp_output_filename):\n            JSONVectorDatabase(temp_output_filename)\n        \n        \n        \n        \n    automata.tests.unit.test_database_vector.test_load\n    \n        def test_load(temp_output_filename, symbols):\n            vector_db = JSONVectorDatabase(temp_output_filename)\n            embedded_symbol_0 = SymbolEmbedding(symbols[0], \"x\", [1, 2, 3])\n            vector_db.add(embedded_symbol_0)\n            embedded_symbol_1 = SymbolEmbedding(symbols[1], \"y\", [1, 2, 3, 4])\n            vector_db.add(embedded_symbol_1)\n            vector_db.save()\n        \n            vector_db_2 = JSONVectorDatabase(temp_output_filename)\n        \n            embedded_symbol_0 = vector_db_2.get(symbols[0])\n            embedded_symbol_1 = vector_db_2.get(symbols[1])\n        \n        \n    automata.tests.unit.test_database_vector.test_save\n    \n        def test_save(temp_output_filename, symbols):\n            vector_db = JSONVectorDatabase(temp_output_filename)\n            embedded_symbol_0 = SymbolEmbedding(symbols[0], \"x\", [1, 2, 3])\n            vector_db.add(embedded_symbol_0)\n            embedded_symbol_1 = SymbolEmbedding(symbols[1], \"y\", [1, 2, 3, 4])\n            vector_db.add(embedded_symbol_1)\n            vector_db.save()\n        \n        \n        \n        \n    automata.tests.unit.test_database_vector.test_delete_symbol\n    \n        def test_delete_symbol(temp_output_filename, symbols):\n            vector_db = JSONVectorDatabase(temp_output_filename)\n            symbol = symbols[0]\n            embedded_symbol = SymbolEmbedding(symbol, \"x\", [1, 2, 3])\n            vector_db.add(embedded_symbol)\n            vector_db.discard(symbol)\n        \n        \n        \n        \n    automata.tests.unit.test_database_vector.test_add_symbols\n    \n        def test_add_symbols(temp_output_filename, symbols):\n            vector_db = JSONVectorDatabase(temp_output_filename)\n            embedded_symbol_0 = SymbolEmbedding(symbols[0], \"x\", [1, 2, 3])\n            vector_db.add(embedded_symbol_0)\n            embedded_symbol_1 = SymbolEmbedding(symbols[1], \"y\", [1, 2, 3, 4])\n            vector_db.add(embedded_symbol_1)\n        \n        \n        \n        \n    automata.tests.unit.test_database_vector.test_add_symbol\n    \n        def test_add_symbol(temp_output_filename, symbols):\n            vector_db = JSONVectorDatabase(temp_output_filename)\n            symbol = symbols[0]\n            embedded_symbol = SymbolEmbedding(symbol, \"x\", [1, 2, 3])\n            vector_db.add(embedded_symbol)\n        \n        \n        \n        \n    automata.tests.unit.test_database_vector.test_lookup_symbol\n    \n        def test_lookup_symbol(temp_output_filename, symbols):\n            vector_db = JSONVectorDatabase(temp_output_filename)\n            embedded_symbol_0 = SymbolEmbedding(symbols[0], \"x\", [1, 2, 3])\n            vector_db.add(embedded_symbol_0)\n            embedded_symbol_1 = SymbolEmbedding(symbols[1], \"y\", [1, 2, 3, 4])\n            vector_db.add(embedded_symbol_1)\n        \n            vector_db.get(symbols[0])\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.SymbolEmbedding\n    \n        SymbolEmbedding is an abstract base class used to represent various symbol embeddings, such as SymbolCodeEmbedding and SymbolDocEmbedding. It provides a basic structure for initializing and managing these embeddings, taking into account their source and their vector representation in the feature space. SymbolEmbedding is utilized by different embedding handlers like SymbolCodeEmbeddingHandler and SymbolDocEmbeddingHandler. As a base class, its functionality is limited and should be extended by classes with specific embedding types. An example of creating a SymbolCodeEmbedding instance is shown below:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def __init__(self, message): pass\"\n        vector = np.array([0.1, 0.2, 0.3])\n        \n        symbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Abstract base class for different types of embeddings\n        \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n    automata.core.database.vector.VectorDatabaseProvider\n    \n        `VectorDatabaseProvider` is an abstract base class designed for implementing custom vector database providers. It provides a basic structure for a vector storage system and requires subclasses to implement the `calculate_similarity()` and `get_all_symbols()` abstract methods. The former computes the similarity between a given vector and all stored vectors, while the latter retrieves a list of all symbols in the database. However, the base class does not offer built-in functionality for adding, updating, or removing symbols and their embeddings, requiring implementers to handle these operations themselves. A basic example implementation of the `VectorDatabaseProvider` class can be seen in the provided code snippet.\n        \n      Class Docstring:\n        Abstract base class for different types of vector database providers.\n        \n      Methods:\n        calculate_similarity(self, embedding: SymbolEmbedding) -> List[Dict[Symbol, float]]\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n  Building context for dependencies -\n  \n    automata.core.symbol.symbol_types.Symbol.dotpath\n    \n      Class Docstring:\n        Returns the dotpath of the symbol\n        \n      Methods:\n        dotpath(self) -> str\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.database.vector`/VectorDatabaseProvider#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.database.vector", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "VectorDatabaseProvider", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# VectorDatabaseProvider\n\n`VectorDatabaseProvider` is an abstract base class for implementing different types of vector database providers. Its main purpose is to provide the basic structure for a vector storage system, allowing developers to easily customize and implement their own solutions. \n\nSubclasses must implement the abstract methods `calculate_similarity()` and `get_all_symbols()` to work correctly. `calculate_similarity()` computes the similarity between a provided vector and all vectors stored in the database, returning a list of dictionaries containing each symbol and its similarity score. `get_all_symbols()` retrieves a list of all symbols stored in the database.\n\n## Related Symbols\n\n- `automata.core.database.vector.JSONVectorDatabase`\n- `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.database.provider.SymbolDatabaseProvider`\n- `automata.core.embedding.embedding_types.EmbeddingProvider`\n\n## Example\n\nThe following example demonstrates a basic implementation of the `VectorDatabaseProvider` class.\n\n```python\nclass MyVectorDatabase(VectorDatabaseProvider):\n\n    def __init__(self):\n        self.data: List[SymbolEmbedding] = []\n        self.index: Dict[str, int] = {}\n\n    def calculate_similarity(self, embedding: SymbolEmbedding) -> List[Dict[Symbol, float]]:\n        similarities = []\n        for stored_embedding in self.data:\n            similarity = compute_cosine_similarity(embedding.vector, stored_embedding.vector)\n            similarities.append({stored_embedding.symbol: similarity})\n        return similarities\n\n    def get_all_symbols(self) -> List[Symbol]:\n        return [embedding.symbol for embedding in self.data]\n\n# Usage\nmy_vector_db = MyVectorDatabase()\n```\n\n## Limitations\n\nSince `VectorDatabaseProvider` is an abstract base class, it cannot be used directly. Instead, developers must create a subclass that implements the required abstract methods. Furthermore, this base class does not provide any built-in functionality for adding, updating, or removing symbols and their embeddings. Implementers must handle these operations in their own subclasses.\n\n## Follow-up Questions:\n\n- Are there any pre-built subclasses or examples of using `VectorDatabaseProvider` in a real project?\n- What are some other examples of vector databases, and how could they be implemented using this base class?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class VectorDatabaseProvider(SymbolDatabaseProvider):\n    \"\"\"\n    Abstract base class for different types of vector database providers.\n    \"\"\"\n\n    @abc.abstractmethod\n    def calculate_similarity(self, embedding: SymbolEmbedding) -> List[Dict[Symbol, float]]:\n        \"\"\"\n        Abstract method to calculate the similarity between the given vector and vectors in the database.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get_all_symbols(self) -> List[Symbol]:\n        \"\"\"\n        Abstract method to calculate the similarity between the given vector and vectors in the database.\n        \"\"\"\n        pass\n\n\n", "summary": "`VectorDatabaseProvider` is an abstract base class for creating custom vector database providers, providing a unified structure for vector storage systems. It requires subclasses to implement the abstract methods `calculate_similarity()`, which computes similarity between a provided vector and all stored vectors, returning a list of dictionaries with each symbol and similarity score, and `get_all_symbols()`, which retrieves a list of all symbols in the database. The base class does not include built-in functionality for adding, updating, or removing symbols and their embeddings, thus requiring implementers to handle these operations in their subclasses. An example implementation can be seen in the provided `MyVectorDatabase` class.", "context": "\n    Generate the documentation for VectorDatabaseProvider using the context shown below -\n  Building context for primary symbol - automata.core.database.vector.VectorDatabaseProvider -\n  \n    Import Statements:\n      import abc\n      import logging\n      import logging.config\n      import jsonpickle\n      import numpy as np\n      from typing import Dict, List\n      from automata.core.database.provider import SymbolDatabaseProvider\n      from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n      \n      # VectorDatabaseProvider\n      \n      `VectorDatabaseProvider` is an abstract base class for implementing different types of vector database providers. Its main purpose is to provide the basic structure for a vector storage system, allowing developers to easily customize and implement their own solutions. \n      \n      Subclasses must implement the abstract methods `calculate_similarity()` and `get_all_symbols()` to work correctly. `calculate_similarity()` computes the similarity between a provided vector and all vectors stored in the database, returning a list of dictionaries containing each symbol and its similarity score. `get_all_symbols()` retrieves a list of all symbols stored in the database.\n      \n      ## Related Symbols\n      \n      - `automata.core.database.vector.JSONVectorDatabase`\n      - `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.database.provider.SymbolDatabaseProvider`\n      - `automata.core.embedding.embedding_types.EmbeddingProvider`\n      \n      ## Example\n      \n      The following example demonstrates a basic implementation of the `VectorDatabaseProvider` class.\n      \n      ```python\n      class MyVectorDatabase(VectorDatabaseProvider):\n      \n          def __init__(self):\n              self.data: List[SymbolEmbedding] = []\n              self.index: Dict[str, int] = {}\n      \n          def calculate_similarity(self, embedding: SymbolEmbedding) -> List[Dict[Symbol, float]]:\n              similarities = []\n              for stored_embedding in self.data:\n                  similarity = compute_cosine_similarity(embedding.vector, stored_embedding.vector)\n                  similarities.append({stored_embedding.symbol: similarity})\n              return similarities\n      \n          def get_all_symbols(self) -> List[Symbol]:\n              return [embedding.symbol for embedding in self.data]\n      \n      # Usage\n      my_vector_db = MyVectorDatabase()\n      ```\n      \n      ## Limitations\n      \n      Since `VectorDatabaseProvider` is an abstract base class, it cannot be used directly. Instead, developers must create a subclass that implements the required abstract methods. Furthermore, this base class does not provide any built-in functionality for adding, updating, or removing symbols and their embeddings. Implementers must handle these operations in their own subclasses.\n      \n      ## Follow-up Questions:\n      \n      - Are there any pre-built subclasses or examples of using `VectorDatabaseProvider` in a real project?\n      - What are some other examples of vector databases, and how could they be implemented using this base class?\n      \n    Class Docstring:\n      Abstract base class for different types of vector database providers.\n      \n    Methods:\n      @abc.abstractmethod\n          def calculate_similarity(self, embedding: SymbolEmbedding) -> List[Dict[Symbol, float]]:\n              \"\"\"\n              Abstract method to calculate the similarity between the given vector and vectors in the database.\n              \"\"\"\n              pass\n      \n          \n      @abc.abstractmethod\n          def get_all_symbols(self) -> List[Symbol]:\n              \"\"\"\n              Abstract method to calculate the similarity between the given vector and vectors in the database.\n              \"\"\"\n              pass\n      \n      \n      \n  Building context for related symbols -\n  \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.database.provider.SymbolDatabaseProvider\n    \n        The SymbolDatabaseProvider is an abstract base class designed for handling symbol embedding storage and retrieval in databases. It offers a generic interface for managing database operations related to symbol embeddings, allowing customization and flexibility in storage methods. Subclasses can implement various storage mechanisms optimized for specific needs, while users interact with the database consistently. Since SymbolDatabaseProvider is an abstract base class, users need to subclass it and implement its abstract methods to provide their database implementation using specific storage mechanisms. This customization may require a deeper understanding of the underlying storage methods. An example implementation using a JSON file for storage can be found in the original documentation.\n        \n      Class Docstring:\n        Abstract base class for different types of database providers.\n        \n      Methods:\n        add(self, embedding: SymbolEmbedding) -> None\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> Any\n        \n        load(self) -> Any\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.tests.unit.test_database_vector.test_init_vector\n    \n        def test_init_vector(temp_output_filename):\n            JSONVectorDatabase(temp_output_filename)\n        \n        \n        \n        \n    automata.core.database.vector.JSONVectorDatabase.add\n    \n      Class Docstring:\n        Adds a new vector to the database\n        \n        Args:\n        embedding: The vector to add\n        \n      Methods:\n        add(self, embedding: SymbolEmbedding) -> None\n        \n    automata.core.symbol.symbol_types.SymbolEmbedding\n    \n        SymbolEmbedding is an abstract base class used to represent various symbol embeddings, such as SymbolCodeEmbedding and SymbolDocEmbedding. It provides a basic structure for initializing and managing these embeddings, taking into account their source and their vector representation in the feature space. SymbolEmbedding is utilized by different embedding handlers like SymbolCodeEmbeddingHandler and SymbolDocEmbeddingHandler. As a base class, its functionality is limited and should be extended by classes with specific embedding types. An example of creating a SymbolCodeEmbedding instance is shown below:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def __init__(self, message): pass\"\n        vector = np.array([0.1, 0.2, 0.3])\n        \n        symbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Abstract base class for different types of embeddings\n        \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n    automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler\n    \n        The `SymbolDocEmbeddingHandler` class is responsible for generating, storing, and managing document embeddings for symbols in an AutomataDocs project. It relies on the `VectorDatabaseProvider`, `EmbeddingProvider` classes, and uses methods like `build_symbol_doc_embedding`, `update_embedding`, `get_embedding`, `get_doc`, and `get_summary` for managing symbol document embeddings and their summaries. The class utilizes various other components like `SymbolGraph`, `SymbolSimilarity`, and `SymbolRankConfig` to search, rank, and generate context for symbol embeddings. However, it has limitations concerning the embedding models and algorithms used and can sometimes produce suboptimal context or examples. Improving the underlying components can potentially enhance the embedding quality.\n        \n        Example usage:\n        \n        ```python\n        from automata.core.embedding.doc_embedding import SymbolDocEmbeddingHandler\n        from automata.core.database.vector import JSONVectorDatabase, VectorDatabaseProvider\n        from automata.core.embedding.embedding_types import OpenAIEmbedding, EmbeddingProvider\n        from automata.core.symbol.symbol_types import Symbol\n        \n        # Initialize the database provider and embedding provider\n        db_provider = VectorDatabaseProvider(JSONVectorDatabase(\"path/to/symbol_doc_embedding.json\"))\n        embedding_provider = EmbeddingProvider(OpenAIEmbedding())\n        \n        # Create an instance of SymbolDocEmbeddingHandler\n        embedding_handler = SymbolDocEmbeddingHandler(db_provider, embedding_provider)\n        \n        # Example symbol and source code\n        symbol = Symbol.from_string(\"symbol-uri-as-string\")\n        source_code = \"def example_function():\\n    pass\"\n        \n        # Build the symbol document embedding\n        symbol_doc_embedding = embedding_handler.build_symbol_doc_embedding(source_code, symbol)\n        ```\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n                code_embedding_handler: SymbolCodeEmbeddingHandler,\n                embedding_db_l2: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                A constructor for SymbolDocEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (EmbeddingProvider): The provider to get the embeddings from\n                    code_embedding_handler (SymbolCodeEmbeddingHandler): The code embedding handler\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n                from automata.core.embedding.symbol_similarity import SymbolSimilarity\n                from automata.core.symbol.search.rank import SymbolRankConfig\n                from automata.core.symbol.search.symbol_search import SymbolSearch\n        \n                graph = SymbolGraph()\n                subgraph = graph.get_rankable_symbol_subgraph()\n                symbol_similarity = SymbolSimilarity(code_embedding_handler)\n                self.graph = graph\n                self.symbol_search = SymbolSearch(\n                    graph, symbol_similarity, symbol_rank_config=SymbolRankConfig(), code_subgraph=subgraph\n                )\n                self.embedding_db_l2 = embedding_db_l2\n        \n            \n        build_symbol_doc_embedding(self, source_code: str, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_doc(prompt: str) -> str\n        \n        get_embedding(self, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_summary(input_doc: str) -> str\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n    automata.core.embedding.embedding_types.EmbeddingProvider\n    \n        `EmbeddingProvider` is an abstract base class that serves as an interface for obtaining mathematical representations called embeddings for symbols, used in tasks such as similarity search, ranking, and other natural language processing-related work. Its single abstract method, `build_embedding`, should be implemented by all subclasses to provide specific embedding implementations. Users must create their own classes that inherit from `EmbeddingProvider` and implement these methods, which might be a limitation for those unfamiliar with custom classes and abstract methods.\n        \n        Here is an example of using the `OpenAIEmbedding` class, a concrete implementation of `EmbeddingProvider`:\n        \n        ```python\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        import numpy as np\n        \n        symbol_source = \"This is an example of a Python function.\"\n        embedding_provider = OpenAIEmbedding() \n        embedding = embedding_provider.build_embedding(symbol_source)\n        \n        # Check if the generated embedding is a numpy array\n        assert isinstance(embedding, np.ndarray)\n        ```\n        Performance and accuracy of embeddings depend on the specific model and approach used in the concrete implementation of `EmbeddingProvider`.\n        \n      Class Docstring:\n        A class to provide embeddings for symbols\n        \n      Methods:\n        build_embedding(self, symbol_source: str) -> np.ndarray\n        \n    automata.tests.unit.test_database_vector.test_load\n    \n        def test_load(temp_output_filename, symbols):\n            vector_db = JSONVectorDatabase(temp_output_filename)\n            embedded_symbol_0 = SymbolEmbedding(symbols[0], \"x\", [1, 2, 3])\n            vector_db.add(embedded_symbol_0)\n            embedded_symbol_1 = SymbolEmbedding(symbols[1], \"y\", [1, 2, 3, 4])\n            vector_db.add(embedded_symbol_1)\n            vector_db.save()\n        \n            vector_db_2 = JSONVectorDatabase(temp_output_filename)\n        \n            embedded_symbol_0 = vector_db_2.get(symbols[0])\n            embedded_symbol_1 = vector_db_2.get(symbols[1])\n        \n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.embedding.code_embedding`/SymbolCodeEmbeddingHandler#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.embedding.code_embedding", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolCodeEmbeddingHandler", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolCodeEmbeddingHandler\n\n`SymbolCodeEmbeddingHandler` is a class that manages the embedding of symbols and their source code. The class is responsible for building the embeddings for symbols, getting the embeddings from the database, and updating the embeddings based on the source code changes. It uses the `VectorDatabaseProvider` and `EmbeddingProvider` for storing and generating the embeddings, respectively.\n\n## Related Symbols\n\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.symbol_types.SymbolCodeEmbedding`\n- `automata.core.embedding.embedding_types.SymbolEmbeddingHandler`\n- `automata.core.embedding.embedding_types.EmbeddingProvider`\n- `automata.core.database.vector.VectorDatabaseProvider`\n- `automata.core.symbol.symbol_utils.convert_to_fst_object`\n\n## Example\n\nThe following example demonstrates how to create an instance of the `SymbolCodeEmbeddingHandler` and update the embeddings of a given symbol.\n\n```python\nfrom automata.core.database.vector import JSONVectorDatabase\nfrom automata.core.symbol.symbol_types import Symbol\nfrom automata.core.embedding.embedding_types import OpenAIEmbedding\nfrom automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n\n# Configure the necessary components\nembedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\nembedding_provider = OpenAIEmbedding()\n\n# Create the instance of SymbolCodeEmbeddingHandler\nhandler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n\n# Update the embeddings for a symbol\nsymbol = Symbol.from_string(\"symbol_string_here\")\nhandler.update_embedding(symbol)\n```\n\n## Limitations\n\n`SymbolCodeEmbeddingHandler` assumes a specific directory structure for the configuration files and relies on the `VectorDatabaseProvider` and `EmbeddingProvider` for storing and generating embeddings. It can only build embeddings from the provided source code and does not support building embeddings from custom data sources. Additionally, the provided `convert_to_fst_object` function may not support all language features and syntax variations, which might result in inaccuracies.\n\n## Follow-up questions:\n\n- Can the `SymbolCodeEmbeddingHandler` work with custom data sources or custom embedding algorithms?\n- What are the limitations of the `convert_to_fst_object` function when handling different programming languages or syntax variations?\n\n## Methods\n\n### `__init__(self, embedding_db: VectorDatabaseProvider, embedding_provider: EmbeddingProvider)`\n\nA constructor for `SymbolCodeEmbeddingHandler`.\n\n- `embedding_db (VectorDatabaseProvider)`: The database to store the embeddings in.\n- `embedding_provider (EmbeddingProvider)`: The provider to get the embeddings from.\n\n### `build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding`\n\nBuild the embedding for a symbol.\n\n- `symbol (Symbol)`: Symbol to build the embedding for.\n\nReturns:\n- `SymbolEmbedding`: The embedding for the symbol.\n\n### `get_all_supported_symbols(self) -> List[Symbol]`\n\nGet all the symbols in the database.\n\nReturns:\n- `List[Symbol]`: List of all the symbols in the database.\n\n### `get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding`\n\nGet the embedding of a symbol.\n\n- `symbol (Symbol)`: Symbol to get the embedding for.\n\nReturns:\n- `Embedding`: The embedding of the symbol.\n\n### `update_embedding(self, symbol: Symbol)`\n\nConcrete method to update the embedding for a symbol.\n\n- `symbols_to_update (List[Symbol])`: List of symbols to update.\n\nRaises:\n- `ValueError`: If the symbol has no source code.\n\n### `update_existing_embedding(self, source_code: str, symbol: Symbol)`\n\nCheck if the embedding for a symbol needs to be updated. This is done by comparing the source code of the symbol to the source code.\n\n- `source_code (str)`: The source code of the symbol.\n- `symbol (Symbol)`: The symbol to update.", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class SymbolCodeEmbeddingHandler(SymbolEmbeddingHandler):\n    def __init__(\n        self,\n        embedding_db: VectorDatabaseProvider,\n        embedding_provider: EmbeddingProvider,\n    ):\n        \"\"\"\n        A constructor for SymbolCodeEmbeddingHandler\n\n        Args:\n            embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n            embedding_provider (Optional[EmbeddingProvider]): The provider to\n                get the embeddings from\n        \"\"\"\n        super().__init__(embedding_db, embedding_provider)\n\n    def get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding:\n        \"\"\"\n        Get the embedding of a symbol.\n\n        Args:\n            symbol (Symbol): Symbol to get the embedding for\n\n        Returns:\n            Embedding: The embedding of the symbol\n        \"\"\"\n        return self.embedding_db.get(symbol)\n\n    def update_embedding(self, symbol: Symbol):\n        \"\"\"\n        Concrete method to update the embedding for a symbol.\n\n        Args:\n            symbols_to_update (List[Symbol]): List of symbols to update\n\n        Raises:\n            ValueError: If the symbol has no source code\n        \"\"\"\n        from automata.core.symbol.symbol_utils import (  # imported late for mocking\n            convert_to_fst_object,\n        )\n\n        source_code = str(convert_to_fst_object(symbol))\n\n        if not source_code:\n            raise ValueError(f\"Symbol {symbol} has no source code\")\n\n        if self.embedding_db.contains(symbol):\n            self.update_existing_embedding(source_code, symbol)\n        else:\n            symbol_embedding = self.build_embedding(source_code, symbol)\n            self.embedding_db.add(symbol_embedding)\n\n    def build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding:\n        \"\"\"\n        Build the embedding for a symbol.\n\n        Args:\n            symbol (Symbol): Symbol to build the embedding for\n\n        Returns:\n            SymbolEmbedding: The embedding for the symbol\n        \"\"\"\n        embedding_vector = self.embedding_provider.build_embedding(source_code)\n        return SymbolCodeEmbedding(symbol, source_code, embedding_vector)\n\n    def update_existing_embedding(self, source_code: str, symbol: Symbol):\n        \"\"\"\n        Check if the embedding for a symbol needs to be updated.\n        This is done by comparing the source code of the symbol to the source code\n\n        Args:\n            source_code (str): The source code of the symbol\n            symbol (Symbol): The symbol to update\n        \"\"\"\n        existing_embedding = self.embedding_db.get(symbol)\n        if existing_embedding.embedding_source != source_code:\n            logger.debug(\"Building a new embedding for %s\", symbol)\n            self.embedding_db.discard(symbol)\n            symbol_embedding = self.build_embedding(source_code, symbol)\n            self.embedding_db.add(symbol_embedding)\n        elif existing_embedding.symbol != symbol:\n            logger.debug(\"Updating the embedding for %s\", symbol)\n            self.embedding_db.discard(symbol)\n            existing_embedding.symbol = symbol\n            self.embedding_db.add(existing_embedding)\n        else:\n            logger.debug(\"Passing for %s\", symbol)\n            pass\n\n    def get_all_supported_symbols(self) -> List[Symbol]:\n        \"\"\"\n        Get all the symbols in the database.\n\n        Returns:\n            List[Symbol]: List of all the symbols in the database\n        \"\"\"\n        return self.embedding_db.get_all_symbols()\n", "summary": "The `SymbolCodeEmbeddingHandler` class is responsible for managing the embedding of symbols and their source code. It builds, gets, and updates embeddings for symbols using the `VectorDatabaseProvider` and `EmbeddingProvider`. However, it cannot work with custom data sources or custom embedding algorithms and may have inaccuracies due to limitations with `convert_to_fst_object`.\n\nHere's an example of how to create an instance of `SymbolCodeEmbeddingHandler` and update the embeddings of a symbol:\n\n```python\nfrom automata.core.database.vector import JSONVectorDatabase\nfrom automata.core.symbol.symbol_types import Symbol\nfrom automata.core.embedding.embedding_types import OpenAIEmbedding\nfrom automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n\n# Configure the necessary components\nembedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\nembedding_provider = OpenAIEmbedding()\n\n# Create the instance of SymbolCodeEmbeddingHandler\nhandler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n\n# Update the embeddings for a symbol\nsymbol = Symbol.from_string(\"symbol_string_here\")\nhandler.update_embedding(symbol)\n```\n", "context": "\n    Generate the documentation for SymbolCodeEmbeddingHandler using the context shown below -\n  Building context for primary symbol - automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler -\n  \n    Import Statements:\n      import logging\n      from typing import List\n      from automata.core.database.vector import VectorDatabaseProvider\n      from automata.core.symbol.symbol_types import Symbol, SymbolCodeEmbedding\n      from .embedding_types import EmbeddingProvider, SymbolEmbeddingHandler\n      from automata.core.symbol.symbol_utils import (  # imported late for mocking\n                  convert_to_fst_object,\n              )\n      \n      # SymbolCodeEmbeddingHandler\n      \n      `SymbolCodeEmbeddingHandler` is a class to handle the embedding of symbols and their source code. It is responsible for building the embeddings for symbols, getting the embeddings from the database, and updating the embeddings based on the source code changes. The class uses the `VectorDatabaseProvider` and `EmbeddingProvider` for storing and generating the embeddings, respectively.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.symbol_types.SymbolCodeEmbedding`\n      - `automata.core.embedding.embedding_types.SymbolEmbeddingHandler`\n      - `automata.core.embedding.embedding_types.EmbeddingProvider`\n      - `automata.core.database.vector.VectorDatabaseProvider`\n      - `automata.core.symbol.symbol_utils.convert_to_fst_object`\n      \n      ## Example\n      \n      The following example demonstrates how to create an instance of the `SymbolCodeEmbeddingHandler` and update the embeddings of a given symbol.\n      \n      ```python\n      from automata.core.database.vector import JSONVectorDatabase\n      from automata.core.symbol.symbol_types import Symbol\n      from automata.core.embedding.embedding_types import OpenAIEmbedding\n      from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n      \n      # Configure the necessary components\n      embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n      embedding_provider = OpenAIEmbedding()\n      \n      # Create the instance of SymbolCodeEmbeddingHandler\n      handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n      \n      # Update the embeddings for a symbol\n      symbol = Symbol.from_string(\"symbol_string_here\")\n      handler.update_embedding(symbol)\n      ```\n      \n      ## Limitations\n      \n      `SymbolCodeEmbeddingHandler` assumes a specific directory structure for the configuration files, and it relies on the `VectorDatabaseProvider` and `EmbeddingProvider` for storing and generating embeddings. It can only build embeddings from the provided source code and does not support building embeddings from custom data sources. In addition, the provided `convert_to_fst_object` function may not support all language features and syntax variations, which might result in inaccuracies.\n      \n      ## Follow-up Questions:\n      \n      - Can the `SymbolCodeEmbeddingHandler` work with custom data sources or custom embedding algorithms?\n      - What are the limitations of the `convert_to_fst_object` function when handling different programming languages or syntax variations?\n      \n    Methods:\n      def __init__(\n              self,\n              embedding_db: VectorDatabaseProvider,\n              embedding_provider: EmbeddingProvider,\n          ):\n              \"\"\"\n              A constructor for SymbolCodeEmbeddingHandler\n      \n              Args:\n                  embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                  embedding_provider (Optional[EmbeddingProvider]): The provider to\n                      get the embeddings from\n              \"\"\"\n              super().__init__(embedding_db, embedding_provider)\n      \n          \n      def build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding:\n              \"\"\"\n              Build the embedding for a symbol.\n      \n              Args:\n                  symbol (Symbol): Symbol to build the embedding for\n      \n              Returns:\n                  SymbolEmbedding: The embedding for the symbol\n              \"\"\"\n              embedding_vector = self.embedding_provider.build_embedding(source_code)\n              return SymbolCodeEmbedding(symbol, source_code, embedding_vector)\n      \n          \n      def get_all_supported_symbols(self) -> List[Symbol]:\n              \"\"\"\n              Get all the symbols in the database.\n      \n              Returns:\n                  List[Symbol]: List of all the symbols in the database\n              \"\"\"\n              return self.embedding_db.get_all_symbols()\n      \n      def get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding:\n              \"\"\"\n              Get the embedding of a symbol.\n      \n              Args:\n                  symbol (Symbol): Symbol to get the embedding for\n      \n              Returns:\n                  Embedding: The embedding of the symbol\n              \"\"\"\n              return self.embedding_db.get(symbol)\n      \n          \n      def update_embedding(self, symbol: Symbol):\n              \"\"\"\n              Concrete method to update the embedding for a symbol.\n      \n              Args:\n                  symbols_to_update (List[Symbol]): List of symbols to update\n      \n              Raises:\n                  ValueError: If the symbol has no source code\n              \"\"\"\n              from automata.core.symbol.symbol_utils import (  # imported late for mocking\n                  convert_to_fst_object,\n              )\n      \n              source_code = str(convert_to_fst_object(symbol))\n      \n              if not source_code:\n                  raise ValueError(f\"Symbol {symbol} has no source code\")\n      \n              if self.embedding_db.contains(symbol):\n                  self.update_existing_embedding(source_code, symbol)\n              else:\n                  symbol_embedding = self.build_embedding(source_code, symbol)\n                  self.embedding_db.add(symbol_embedding)\n      \n          \n      def update_existing_embedding(self, source_code: str, symbol: Symbol):\n              \"\"\"\n              Check if the embedding for a symbol needs to be updated.\n              This is done by comparing the source code of the symbol to the source code\n      \n              Args:\n                  source_code (str): The source code of the symbol\n                  symbol (Symbol): The symbol to update\n              \"\"\"\n              existing_embedding = self.embedding_db.get(symbol)\n              if existing_embedding.embedding_source != source_code:\n                  logger.debug(\"Building a new embedding for %s\", symbol)\n                  self.embedding_db.discard(symbol)\n                  symbol_embedding = self.build_embedding(source_code, symbol)\n                  self.embedding_db.add(symbol_embedding)\n              elif existing_embedding.symbol != symbol:\n                  logger.debug(\"Updating the embedding for %s\", symbol)\n                  self.embedding_db.discard(symbol)\n                  existing_embedding.symbol = symbol\n                  self.embedding_db.add(existing_embedding)\n              else:\n                  logger.debug(\"Passing for %s\", symbol)\n                  pass\n      \n          \n  Building context for related symbols -\n  \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler\n    \n        The `SymbolDocEmbeddingHandler` class is responsible for generating, storing, and managing document embeddings for symbols in an AutomataDocs project. It relies on the `VectorDatabaseProvider`, `EmbeddingProvider` classes, and uses methods like `build_symbol_doc_embedding`, `update_embedding`, `get_embedding`, `get_doc`, and `get_summary` for managing symbol document embeddings and their summaries. The class utilizes various other components like `SymbolGraph`, `SymbolSimilarity`, and `SymbolRankConfig` to search, rank, and generate context for symbol embeddings. However, it has limitations concerning the embedding models and algorithms used and can sometimes produce suboptimal context or examples. Improving the underlying components can potentially enhance the embedding quality.\n        \n        Example usage:\n        \n        ```python\n        from automata.core.embedding.doc_embedding import SymbolDocEmbeddingHandler\n        from automata.core.database.vector import JSONVectorDatabase, VectorDatabaseProvider\n        from automata.core.embedding.embedding_types import OpenAIEmbedding, EmbeddingProvider\n        from automata.core.symbol.symbol_types import Symbol\n        \n        # Initialize the database provider and embedding provider\n        db_provider = VectorDatabaseProvider(JSONVectorDatabase(\"path/to/symbol_doc_embedding.json\"))\n        embedding_provider = EmbeddingProvider(OpenAIEmbedding())\n        \n        # Create an instance of SymbolDocEmbeddingHandler\n        embedding_handler = SymbolDocEmbeddingHandler(db_provider, embedding_provider)\n        \n        # Example symbol and source code\n        symbol = Symbol.from_string(\"symbol-uri-as-string\")\n        source_code = \"def example_function():\\n    pass\"\n        \n        # Build the symbol document embedding\n        symbol_doc_embedding = embedding_handler.build_symbol_doc_embedding(source_code, symbol)\n        ```\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n                code_embedding_handler: SymbolCodeEmbeddingHandler,\n                embedding_db_l2: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                A constructor for SymbolDocEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (EmbeddingProvider): The provider to get the embeddings from\n                    code_embedding_handler (SymbolCodeEmbeddingHandler): The code embedding handler\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n                from automata.core.embedding.symbol_similarity import SymbolSimilarity\n                from automata.core.symbol.search.rank import SymbolRankConfig\n                from automata.core.symbol.search.symbol_search import SymbolSearch\n        \n                graph = SymbolGraph()\n                subgraph = graph.get_rankable_symbol_subgraph()\n                symbol_similarity = SymbolSimilarity(code_embedding_handler)\n                self.graph = graph\n                self.symbol_search = SymbolSearch(\n                    graph, symbol_similarity, symbol_rank_config=SymbolRankConfig(), code_subgraph=subgraph\n                )\n                self.embedding_db_l2 = embedding_db_l2\n        \n            \n        build_symbol_doc_embedding(self, source_code: str, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_doc(prompt: str) -> str\n        \n        get_embedding(self, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_summary(input_doc: str) -> str\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n    automata.core.symbol.symbol_types.SymbolCodeEmbedding\n    \n        `SymbolCodeEmbedding` is a class extending the `SymbolEmbedding` base class, used to store code embeddings for a given symbol, the symbol object, source code, and the embedding vector. It primarily serves as a container for these embeddings and does not include functionality for generating or handling them; `SymbolCodeEmbeddingHandler` should be used for those purposes.\n        \n        Here's an example of creating a `SymbolCodeEmbedding` instance:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def example_function():\\n    pass\"\n        vector = np.random.random((300,))\n        \n        embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Embedding for symbol code\n        \n      Methods:\n        def __init__(self, symbol: Symbol, source_code: str, vector: np.array):\n                super().__init__(symbol, source_code, vector)\n        \n        \n        \n    automata.core.embedding.embedding_types.SymbolEmbeddingHandler\n    \n        `SymbolEmbeddingHandler` is an abstract class that manages symbol embeddings by fetching and updating the vector embeddings related to various kinds of symbols. It must be subclassed by other classes that provide implementations of the defined abstract methods, such as `get_embedding()` and `update_embedding()`. The performance of these methods may depend on the chosen embedding provider and database used for storing the embeddings.\n        \n        Here is an example of how to subclass `SymbolEmbeddingHandler` and implement the abstract methods:\n        \n        ```python\n        from automata.core.embedding.embedding_types import SymbolEmbeddingHandler\n        from automata.core.symbol.symbol_types import Symbol\n        \n        class CustomSymbolEmbeddingHandler(SymbolEmbeddingHandler):\n            def __init__(self, embedding_db, embedding_provider):\n                super().__init__(embedding_db, embedding_provider)\n        \n            def get_embedding(self, symbol: Symbol):\n                # Implement logic to get the embedding for a custom symbol\n                pass\n        \n            def update_embedding(self, symbol: Symbol):\n                # Implement logic to update the embedding for a custom symbol\n                pass\n        \n        # Example usage:\n        custom_handler = CustomSymbolEmbeddingHandler(embedding_db, embedding_provider)\n        custom_embedding = custom_handler.get_embedding(custom_symbol)\n        ```\n        \n      Class Docstring:\n        An abstract class to handle the embedding of symbols\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"An abstract constructor for SymbolEmbeddingHandler\"\"\"\n                self.embedding_db = embedding_db\n                self.embedding_provider = embedding_provider\n        \n            \n        get_embedding(self, symbol: Symbol) -> Any\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n    automata.core.symbol.symbol_types.SymbolEmbedding\n    \n        SymbolEmbedding is an abstract base class used to represent various symbol embeddings, such as SymbolCodeEmbedding and SymbolDocEmbedding. It provides a basic structure for initializing and managing these embeddings, taking into account their source and their vector representation in the feature space. SymbolEmbedding is utilized by different embedding handlers like SymbolCodeEmbeddingHandler and SymbolDocEmbeddingHandler. As a base class, its functionality is limited and should be extended by classes with specific embedding types. An example of creating a SymbolCodeEmbedding instance is shown below:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def __init__(self, message): pass\"\n        vector = np.array([0.1, 0.2, 0.3])\n        \n        symbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Abstract base class for different types of embeddings\n        \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n    automata.tests.unit.conftest.get_sem\n    \n        def get_sem(monkeypatch, temp_output_filename):\n            monkeypatch.setattr(\n                \"automata.core.symbol.symbol_utils.convert_to_fst_object\",\n                lambda args: \"symbol_source\",\n            )\n            return SymbolCodeEmbeddingHandler(temp_output_filename)\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.SymbolDocEmbedding\n    \n        `SymbolDocEmbedding` is a class representing the embedding for symbol documents, extending the `SymbolEmbedding` class with added metadata such as source code, summary, and context. This class is utilized alongside `SymbolDocEmbeddingHandler` to manage and access these embeddings for tasks like search and similarity comparison. However, it relies on external handler classes and assumes embeddings are provided as NumPy arrays, potentially limiting usage for other embedding types.\n        \n        ```python\n        import numpy as np\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.symbol.symbol_types import SymbolDocEmbedding\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        symbol = Symbol.from_string(symbol_str)\n        \n        document = \"This is a sample document\"\n        vector = np.array([0.1, 0.2, 0.3])\n        source_code = \"class ActionIndicator(Enum): ...\"\n        summary = \"This class represents an enum for action indicators.\"\n        context = \"The ActionIndicator enum is used to describe the current state...\"\n        \n        embedding = SymbolDocEmbedding(symbol, document, vector, source_code=source_code, summary=summary, context=context)\n        ```\n        \n      Class Docstring:\n        Embedding for symbol documents\n        \n      Methods:\n        def __init__(\n                self,\n                symbol: Symbol,\n                document: str,\n                vector: np.array,\n                source_code: Optional[str] = None,\n                summary: Optional[str] = None,\n                context: Optional[str] = None,\n            ):\n                super().__init__(symbol, document, vector)\n                # begin additional meta data\n                self.source_code = source_code\n                self.summary = summary\n                self.context = context\n        \n    automata.core.embedding.embedding_types.EmbeddingProvider\n    \n        `EmbeddingProvider` is an abstract base class that serves as an interface for obtaining mathematical representations called embeddings for symbols, used in tasks such as similarity search, ranking, and other natural language processing-related work. Its single abstract method, `build_embedding`, should be implemented by all subclasses to provide specific embedding implementations. Users must create their own classes that inherit from `EmbeddingProvider` and implement these methods, which might be a limitation for those unfamiliar with custom classes and abstract methods.\n        \n        Here is an example of using the `OpenAIEmbedding` class, a concrete implementation of `EmbeddingProvider`:\n        \n        ```python\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        import numpy as np\n        \n        symbol_source = \"This is an example of a Python function.\"\n        embedding_provider = OpenAIEmbedding() \n        embedding = embedding_provider.build_embedding(symbol_source)\n        \n        # Check if the generated embedding is a numpy array\n        assert isinstance(embedding, np.ndarray)\n        ```\n        Performance and accuracy of embeddings depend on the specific model and approach used in the concrete implementation of `EmbeddingProvider`.\n        \n      Class Docstring:\n        A class to provide embeddings for symbols\n        \n      Methods:\n        build_embedding(self, symbol_source: str) -> np.ndarray\n        \n    automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler.__init__\n    \n      Class Docstring:\n        A constructor for SymbolDocEmbeddingHandler\n        \n        Args:\n        embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n        embedding_provider (EmbeddingProvider): The provider to get the embeddings from\n        code_embedding_handler (SymbolCodeEmbeddingHandler): The code embedding handler\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n                code_embedding_handler: SymbolCodeEmbeddingHandler,\n                embedding_db_l2: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                A constructor for SymbolDocEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (EmbeddingProvider): The provider to get the embeddings from\n                    code_embedding_handler (SymbolCodeEmbeddingHandler): The code embedding handler\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n                from automata.core.embedding.symbol_similarity import SymbolSimilarity\n                from automata.core.symbol.search.rank import SymbolRankConfig\n                from automata.core.symbol.search.symbol_search import SymbolSearch\n        \n                graph = SymbolGraph()\n                subgraph = graph.get_rankable_symbol_subgraph()\n                symbol_similarity = SymbolSimilarity(code_embedding_handler)\n                self.graph = graph\n                self.symbol_search = SymbolSearch(\n                    graph, symbol_similarity, symbol_rank_config=SymbolRankConfig(), code_subgraph=subgraph\n                )\n                self.embedding_db_l2 = embedding_db_l2\n        \n            \n    automata.core.embedding.symbol_similarity.SymbolSimilarity\n    \n        `SymbolSimilarity` is a class that computes similarity scores between query texts and symbols using embeddings, and allows users to retrieve the most similar symbols for a specific query and create a dictionary mapping the similarity scores to each symbol. Users can set the available symbols for the calculation, and the similarity scores depend on the quality of the supplied pre-trained embeddings and selected norm type. The class uses a `SymbolCodeEmbeddingHandler` for handling embeddings, which affects the accuracy of the results.\n        \n        Example usage of `SymbolSimilarity`:\n        ```python\n        import numpy as np\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        from automata.core.embedding.embedding_types import EmbeddingProvider, NormType\n        from automata.core.embedding.symbol_similarity import SymbolSimilarity\n        \n        embedding_handler = SymbolCodeEmbeddingHandler(embedding_db=embedding_db, embedding_provider=embedding_provider)\n        symbol_similarity = SymbolSimilarity(symbol_embedding_manager=embedding_handler, norm_type=NormType.L2)\n        symbol_similarity.set_available_symbols(available_symbols)\n        nearest_entries = symbol_similarity.get_nearest_entries_for_query(\"example query\", k=5)\n        query_similarity_dict = symbol_similarity.get_query_similarity_dict(\"example query\")\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                symbol_embedding_manager: SymbolCodeEmbeddingHandler,\n                norm_type: NormType = NormType.L2,\n            ):\n                \"\"\"\n                Initialize SymbolSimilarity\n        \n                Args:\n                    symbol_embedding_manager: A CodeEmbeddingManager\n                    norm_type (NormType): The norm type to use for calculating similarity\n        \n                Returns:\n                    An instance of SymbolSimilarity\n                \"\"\"\n                self.embedding_handler: SymbolCodeEmbeddingHandler = symbol_embedding_manager\n                self.embedding_provider: EmbeddingProvider = symbol_embedding_manager.embedding_provider\n                self.norm_type = norm_type\n                supported_symbols = self.embedding_handler.get_all_supported_symbols()\n                self.index_to_symbol = {i: symbol for i, symbol in enumerate(supported_symbols)}\n                self.symbol_to_index = {symbol: i for i, symbol in enumerate(supported_symbols)}\n                self.available_symbols: Optional[Set[Symbol]] = None\n        \n            \n        get_available_symbols(self) -> List[Symbol]\n        \n        get_nearest_entries_for_query(self, query_text: str, k: int = 10) -> Dict[Symbol, float]\n        \n        get_query_similarity_dict(self, query_text: str) -> Dict[Symbol, float]\n        \n        set_available_symbols(self, available_symbols: Set[Symbol]) -> None\n        \n  Building context for dependencies -\n  \n    automata.core.database.provider.SymbolDatabaseProvider.discard\n    \n      Class Docstring:\n        Abstract method to discard a specific embedding.\n        \n      Methods:\n        discard(self, symbol: Symbol) -> None\n        \n    automata.core.database.vector.VectorDatabaseProvider\n    \n        `VectorDatabaseProvider` is an abstract base class designed for implementing custom vector database providers. It provides a basic structure for a vector storage system and requires subclasses to implement the `calculate_similarity()` and `get_all_symbols()` abstract methods. The former computes the similarity between a given vector and all stored vectors, while the latter retrieves a list of all symbols in the database. However, the base class does not offer built-in functionality for adding, updating, or removing symbols and their embeddings, requiring implementers to handle these operations themselves. A basic example implementation of the `VectorDatabaseProvider` class can be seen in the provided code snippet.\n        \n      Class Docstring:\n        Abstract base class for different types of vector database providers.\n        \n      Methods:\n        calculate_similarity(self, embedding: SymbolEmbedding) -> List[Dict[Symbol, float]]\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n    automata.core.database.provider.SymbolDatabaseProvider.add\n    \n      Class Docstring:\n        Abstract method to add an embedding to the database.\n        \n      Methods:\n        add(self, embedding: SymbolEmbedding) -> None\n        \n    automata.core.embedding.embedding_types.EmbeddingProvider.build_embedding\n    \n      Methods:\n        build_embedding(self, symbol_source: str) -> np.ndarray\n        \n    automata.core.database.provider.SymbolDatabaseProvider.get\n    \n      Class Docstring:\n        Abstract method to get a specific embedding.\n        \n      Methods:\n        get(self, symbol: Symbol) -> Any\n        \n    automata.core.database.provider.SymbolDatabaseProvider.contains\n    \n      Class Docstring:\n        Abstract method to check if a specific embedding is present.\n        \n      Methods:\n        contains(self, symbol: Symbol) -> bool\n        \n    automata.core.symbol.symbol_types.Symbol.dotpath\n    \n      Class Docstring:\n        Returns the dotpath of the symbol\n        \n      Methods:\n        dotpath(self) -> str\n        \n    automata.core.symbol.symbol_utils.convert_to_fst_object\n    \n      Class Docstring:\n        Converts a specified symbol into a red baron FST object\n        \n        Args:\n        symbol (str): The symbol which corresponds to a module, class, or method.\n        module_map (Optional[LazyModuleTreeMap]): The module tree mapping to use. If None, the default\n        \n        Returns:\n        Union[ClassNode, DefNode]: The RedBaron FST object for the class or method, or None if not found\n        \n        Raises:\n        ValueError: If the symbol is not found\n        \n        Note:\n        The optional argument is to allow us to run this function in mulitprocessing in the future,\n        because module map is not picklable (because redbaron objects are not picklable)\n        So the indexer would have to be created and destroyed in each process.\n        \n      Methods:\n        convert_to_fst_object(symbol: Symbol, module_map: Optional[LazyModuleTreeMap] = None) -> RedBaron\n        \n    automata.core.embedding.embedding_types.SymbolEmbeddingHandler.__init__\n    \n      Class Docstring:\n        An abstract constructor for SymbolEmbeddingHandler\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"An abstract constructor for SymbolEmbeddingHandler\"\"\"\n                self.embedding_db = embedding_db\n                self.embedding_provider = embedding_provider\n        \n            \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.embedding.doc_embedding`/SymbolDocEmbeddingHandler#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.embedding.doc_embedding", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolDocEmbeddingHandler", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolDocEmbeddingHandler\n\n`SymbolDocEmbeddingHandler` is a class responsible for generating, storing, and managing document embeddings for symbols in the context of an AutomataDocs project. It is used for creating, updating, and retrieving symbol document embeddings, interacting with the `VectorDatabaseProvider` and `EmbeddingProvider` classes, and building symbol objects based on generated document embeddings.\n\n## Overview\n\n`SymbolDocEmbeddingHandler` class is initialized with an instance of `VectorDatabaseProvider`, an instance of `EmbeddingProvider`, and an optional path string for storing the code embedding. The main methods of this class are `build_symbol_doc_embedding`, `update_embedding`, `get_embedding`, `get_doc`, and `get_summary`. These methods are used to manage symbol document embeddings as well as generate their summaries.\n\nThe class also contains a `SymbolGraph` object and utilizes `SymbolSimilarity`, `SymbolRankConfig`, and `SymbolSearch` for searching and ranking symbols and generating related context when building the symbol document embeddings.\n\n## Related Symbols\n\n- `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n- `automata.core.symbol.symbol_types.SymbolDocEmbedding`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.embedding.embedding_types.SymbolEmbeddingHandler`\n- `automata.core.embedding.symbol_similarity.SymbolSimilarity`\n- `automata.core.symbol.search.rank.SymbolRankConfig`\n- `automata.core.symbol.search.symbol_search.SymbolSearch`\n- `automata.core.symbol.graph.SymbolGraph`\n\n## Example\n\nThe following example demonstrates how to create an instance of `SymbolDocEmbeddingHandler` and build a symbol document embedding.\n\n```python\nfrom automata.core.embedding.doc_embedding import SymbolDocEmbeddingHandler\nfrom automata.core.database.vector import JSONVectorDatabase, VectorDatabaseProvider\nfrom automata.core.embedding.embedding_types import OpenAIEmbedding, EmbeddingProvider\nfrom automata.core.symbol.symbol_types import Symbol\n\n# Initialize the database provider and embedding provider\ndb_provider = VectorDatabaseProvider(JSONVectorDatabase(\"path/to/symbol_doc_embedding.json\"))\nembedding_provider = EmbeddingProvider(OpenAIEmbedding())\n\n# Create an instance of SymbolDocEmbeddingHandler\nembedding_handler = SymbolDocEmbeddingHandler(db_provider, embedding_provider)\n\n# Example symbol and source code\nsymbol = Symbol.from_string(\"symbol-uri-as-string\")\nsource_code = \"def example_function():\\n    pass\"\n\n# Build the symbol document embedding\nsymbol_doc_embedding = embedding_handler.build_symbol_doc_embedding(source_code, symbol)\n```\n\n## Limitations\n\nThe `SymbolDocEmbeddingHandler` relies on the `OpenAIEmbedding` class for generating embeddings, which may have limitations in terms of the models and algorithms used. Furthermore, it depends on the data structures provided by the `SymbolGraph` for generating context, which may impose constraints on the flexibility of the embeddings generated.\n\nIn addition, when generating the context and documentation for a symbol, the current implementation might not always prioritize the best examples for documentation or might fail to retrieve certain documentation. Through, improvements in the `Symbol", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "AAAAQPfmo78AAACglVBRPwAAAKAydn6/AAAAQCYykL8AAACgFoh2vwAAAGDpzZk/AAAAANHfWz8AAABAw1eNPwAAAMCDFYa/AAAAQMy9mL8AAADAvBN/vwAAAAAJkZO/AAAAYLukdr8AAAAAWOyYPwAAAIDHm4U/AAAAYJ1yjD8AAABgpbZePwAAAGBfwYQ/AAAA4Ej1cT8AAADAy06CvwAAAMCTnXo/AAAAwEdCjb8AAAAAy06gvwAAAIBKhoG/AAAA4FyfN78AAADAbbhpPwAAAACxz5I/AAAAAIc3pb8AAADgyAqOvwAAAKBmBSU/AAAAACMQYb8AAACAFxmkvwAAAMBHQn2/AAAAYNEBU78AAACAx5uFvwAAAEDB6HI/AAAAwJ8Djj8AAACAaCegvwAAACDUcJ8/AAAAIJpQLT8AAADg/JmEPwAAAGDCxn+/AAAAwJe/i78AAACg6e9wvwAAAOBxaxa/AAAA4LRgmD8AAAAAq2mfvwAAAACDFZS/AAAA4HL8cz8AAABgu6SGPwAAAABldIU/AAAAgCgypj8AAADAR0ItPwAAACCHyJC/AAAAAAFNcT8AAAAgFhmQPwAAACA/j5Q/AAAAoFZ9kD8AAABA2COMvwAAAGCq+pi/AAAA4Kj6dD8AAABg3Wd2PwAAAGASRI6/AAAAQLTxgb8AAACAGhl8vwAAAOBMF6O/AAAAwIMVVj8AAACAz9+nPwAAAIB80ZU/AAAAIJpQnT8AAAAA29akPwAAAMCMe6E/AAAAAD/+OL8AAABgc2tqPwAAAGDRAYM/AAAAAKhpl78AAADATaiQvwAAACDvEWa/AAAAAKyLiD8AAABgyb2AvwAAAEA1mGu/AAAAoPVVlL8AAABACJFxPwAAAIAjf5c/AAAAIJpQjT8AAACg2EUjPwAAAEA5uky/AAAA4GHjoT8AAAAgcvyRvwAAAKABvIc/AAAAQIIVoj8AAABgYsF8PwAAAIDyxDA/AAAAwJ8DTj8AAACgtWCaPwAAAMA0uqA/AAAAwERCdT8AAADgRrGfPwAAAGCODJE/AAAAAGmWlr8AAABgwsaPvwAAAEC7E4s/AAAAAAmRo78AAAAAwVd3vwAAAICBFaC/AAAA4ETTcL8AAABgQrGDvwAAAGDJvVC/AAAAAGh0jT8AAABAXzCJPwAAAAB9QJy/AAAAQPPEkj8AAAAgi+qhvwAAAKDozae/AAAAIBo7kT8AAAAgekAkvwAAAEB1jZU/AAAAgHBrkr8AAADgXJ93vwAAAEBlBZG/AAAAQPPEgj8AAAAgA7yrPwAAAIB3Hoe/AAAAwBTVj78AAABAFYhyPwAAACBL9Ze/AAAAoKocYD8AAABAkOp/vwAAAEBTypW/AAAAYHlAgr8AAAAgrxycvwAAAIBruIM/AAAAAIMVlD8AAACAlb+FvwAAAOAvB4K/AAAAQBDVoz8AAAAAPP6gvwAAAEDDV30/AAAAQHFrRD8AAACg1COSvwAAAOD8mZQ/AAAAwKAllz8AAABALMObvwAAAMB5Ho0/AAAAgLoTqb8AAACgkwyPPwAAAKAs5XI/AAAAwEdCjT8AAACA5TyUPwAAAECIpn2/AAAAwBvMoD8AAABA5jx2vwAAAKAAmp6/AAAAoAkAer8AAACg2EVzPwAAAOC4gok/AAAAQMHogr8AAABgU1uRvwAAAOB+Yne/AAAA4OarnL8AAABgXp+bPwAAAKD5d5U/AAAAQN74g78AAABAJRA3PwAAACCL6pE/AAAAIGwnmj8AAADAvTWIvwAAAIBaDoa/AAAAILiCl78AAAAgdh5zvwAAAEDUAYu/AAAAIKj6cr8AAABAOCmfvwAAAOAxdny/AAAA4Ckymr8AAAAgPm1rPwAAAAD75n0/AAAAgOD4Wb8AAAAg+3eZvwAAAMCkR5i/AAAAgMgskz8AAACALXaAvwAAAOCYcpA/AAAAgPLEoD8AAAAAoyWNvwAAAKAGAJK/AAAAYBeIiL8AAACgAt5AvwAAAEBkdJM/AAAAwDOYh78AAADgMgeKPwAAACAif5M/AAAAQB3MhD8AAADgDURyvwAAAEDvouG/AAAA4LFgcL8AAADgwnlivwAAAKDGCqi/AAAAgJnhhr8AAAAgh8igvwAAAMBZDpS/AAAA4L3Gc78AAAAgHl2ivwAAAMDjGqk/AAAAoCShkL8AAABA0N95vwAAAODRcIm/AAAAYK8+oz8AAADg3dZ8PwAAAIBhMJ+/AAAA4JhygD8AAADgTxebvwAAAAAY936/AAAAIMwsjT8AAADAy05yvwAAACD8mYI/AAAAQCR/qb8AAACAOdxzvwAAAKBEsZk/AAAA4A1Egj8AAADgbUmVvwAAAGDiq5A/AAAAgPoIoz8AAACAgRWQPwAAAOAr5aC/AAAAABX3lj8AAACAwlebPwAAAACwrZm/AAAAwEAgpD8AAADgO22FPwAAAACPe4e/AAAAICJ/oz8AAABAmwOCPwAAAKD0M6s/AAAAwFkOpL8AAACgAJqevwAAAADANY6/AAAAAPTEhL8AAAAAO9x3PwAAAED+CI0/AAAAwBTVnz8AAADAi1loPwAAAGDXkn4/AAAAYJIugr8AAACADrN4PwAAACDr74Q/AAAAIIKEhj8AAACgKjKcPwAAAEAw5Xw/AAAAYLZgbL8AAABAKTKYPwAAAMC8E5+/AAAAYKr6mD8AAAAAqYuAvwAAAGD7mZA/AAAA4AUAoD8AAACgmFB5PwAAAADoXpG/AAAAwP0qgj8AAABAmwOCPwAAAKDxM4O/AAAA4OarjD8AAAAgUDmCvwAAAICNe4O/AAAAgBcZhD8AAADgIe6XPwAAAGCuHHq/AAAA4IKEmD8AAADgNimbPwAAAOARZqM/AAAAgIOEmj8AAABAuBOjvwAAAKAORFQ/AAAAgLnxnz8AAABAJH+ZPwAAAGBPOXC/AAAAIG7aoL8AAABgH8xKvwAAAIArw4k/AAAAAEMgSj8AAABg7hGUvwAAAMDLTpI/AAAAgGEwb78AAACAMZiRvwAAACCGpoc/AAAAQEpkmj8AAAAA5DygvwAAAODFCqa/AAAAwKFHkD8AAABAOCmPPwAAAKDatH0/AAAAIPyZYr8AAADAiFmAvwAAAIC+NUq/AAAAoF2fib8AAABgBwCUvwAAAAAnMpK/AAAAIE8XiT8AAAAAEdWVPwAAAACkR2Y/AAAAwM9wo78AAACA7YCWPwAAAOBu2gK/AAAA4GgFe78AAACg44ldvwAAAOCn2Iu/AAAAAN/4dT8AAABAyJuHPwAAAOB/hIC/AAAAwERCpb8AAABAiKatPwAAAGCn+pA/AAAAYHUeYT8AAADgbtqCvwAAACAif5O/AAAAYHeNi78AAACATYaJvwAAAOA7bYW/AAAAINRwf78AAACgtWCKPwAAAMAMkY2/AAAAwOQ8kr8AAABA0N+ZvwAAAODiiXs/AAAAYDEHhj8AAAAg582TvwAAAACFhI4/AAAAoPhVXL8AAABA6l6HPwAAAMDR340/AAAAIIvqoT8AAABgv8aHvwAAAABwuG+/AAAAIMToaj8AAABgrz6TPwAAAGAxB4Y/AAAAgDB2iD8AAADAuROXvwAAACCGpqe/AAAAQAZNn78AAACAYTBPPwAAACDjq4K/AAAAoFE5Vr8AAADAk516vwAAAGA5S2g/AAAAgIg3GT8AAADg0yNgvwAAAOADvJ0/AAAA4Akikb8AAADgq/qcvwAAAAD8CIe/AAAAgEEgdj8AAABgzd9xvwAAAABhUpS/AAAAQE6Gez8AAADgPm2dPwAAAGC6gp2/AAAAAF0wkz8AAADgbUmlvwAAAICBFXC/AAAAQPPEcr8AAABAYFKiPwAAAGCq+ni/AAAAAKmLoL8AAADA0d+dvwAAAODTI5A/AAAA4BiIjD8AAABA4GeePwAAAIA0mIk/AAAA4Ev1+T4AAAAgo7Z4PwAAACDzM4c/AAAAwHONkT8AAAAgDyKPvwAAAOBYfXa/AAAAgGJSmL8AAAAgi+pRPwAAAMDR352/AAAAoB2qnz8AAACgUTl2vwAAAMBkUp4/AAAA4C7liL8AAAAAqYugPwAAACD3VYg/AAAAwKVpgb8AAADgp9ibPwAAAICc4Z6/AAAAAN1Fnz8AAABA8qIpvwAAAEA/IKA/AAAAwDvcib8AAADg0yOAPwAAAOCbclg/AAAAoPhVnD8AAABA4fibPwAAAECQ6l+/AAAA4OOrhL8AAADgA7x9vwAAAOBdwYA/AAAA4C7lmL8AAACAf2JpvwAAAKChtmS/AAAAwOQ8kj8AAACgKMOBPwAAAOAMIpk/AAAAgEqGoT8AAAAAq2mPvwAAAIDLvYY/AAAAQC52gr8AAADgXcGQPwAAAODGm4M/AAAAwGRSfj8AAACAdvxtvwAAAADrXok/AAAAIM7fk78AAACgnZRjPwAAAOCwPnc/AAAAQOk8jj8AAACAzE6UPwAAAOADvJ0/AAAAILiClz8AAADgW31+PwAAAEDugDi/AAAA4KTYo78AAADgUDlUPwAAAIAmf48/AAAAoBJmhb8AAAAA+OaFvwAAAIC58Z8/AAAAIBYZoD8AAADgi+pjPwAAAIBhMH8/AAAA4LWCkT8AAADgmHJwvwAAAAAtw42/AAAAQDrchT8AAADgp9h7PwAAAIBRqJq/AAAAgIU3cT8AAABAlr+XvwAAAKAC3qA/AAAAoNxnhL8AAAAgBN6UPwAAAKCTDF+/AAAAIE8Xmb8AAADgYMFoPwAAAECfJZM/AAAAIJYufD8AAABA5jx2vwAAAECuiy6/AAAAAC3D7b4AAADgIe53PwAAAGB3jYs/AAAAQMkslT8AAABABk2fPwAAAAA73Ie/AAAAYCcQnT8AAACAmeGGPwAAAOD3VZo/AAAAwIMVVj8AAADA5DxivwAAAIBeMIe/AAAAAC3Dnb8AAACg8TNzPwAAAGAdXWC/AAAAQM1Olr8AAADggoSYvwAAAIAeO32/AAAA4EOxpz8AAADgwnmSvwAAAACgJZU/AAAAADOYlT8AAAAA4xqXPwAAAMCsi5o/AAAAYF/BlL8AAADAf/OkvwAAAECa4Zg/AAAAYPUzjT8AAADgjupLvwAAAMDjGnk/AAAAYB/Mir8AAADABW+EPwAAAEBgUmK/AAAA4HBJnT8AAACATqhSPwAAAIACTaU/AAAAAJCdgD8AAAAgmlBNPwAAAODICo4/AAAAAAArmD8AAAAgwMaZPwAAAOAmoVa/AAAAILRglr8AAABAMOWcPwAAAKCTDI8/AAAAgIQVeD8AAACA2LSHvwAAAOAJIoE/AAAAQI1ZrD8AAAAgEERoPwAAAEBfMHk/AAAA4J+Uib8AAACANbqivwAAACAcqou/AAAAAOMah78AAADAoCVnPwAAAIDd+KG/AAAAwFjsij8AAAAAEdV1vwAAAMCxz5Q/AAAAgGN0gb8AAADgRNOQPwAAAECfJYM/AAAAAOyAoj8AAACg7RGSvwAAAEAMs3K/AAAA4Bo7g78AAADgvcaDPwAAAMC8E68/AAAAoL2kjD8AAACg44mdvwAAAGAHAHS/AAAAQDrcRT8AAAAgEESIPwAAAEBtSZO/AAAA4I1Znr8AAAAgGIiaPwAAAKAVZm0/AAAAIEv1p78AAADgJqGWvwAAAEDZtFm/AAAA4OwRoD8AAAAgOkuaPwAAAIDg+Jk/AAAAwEAghL8AAAAA7ICCvwAAAKBi45M/AAAAQBWIor8AAADgtYKBvwAAAACUv5G/AAAAgM69jr8AAAAAwDVuvwAAAGAbqpk/AAAAIOarmr8AAADgjupLPwAAACDzM5c/AAAAoGYFdT8AAABgCyKlvwAAAIBwa5I/AAAAoALeoD8AAAAgdh6TPwAAAOCXUKc/AAAAAKhph78AAACA5TyUPwAAAMBtuJk/AAAAYEr1lT8AAAAguIKHPwAAAKARRIw/AAAAQIUVmj8AAAAgl1CVPwAAAGAt5WS/AAAAwARNmz8AAACAcGtiPwAAAOD7d2s/AAAAQHxAmr8AAAAA+OaVvwAAAIBwa4K/AAAAIIamhz8AAABAMOV8vwAAAGA+j4I/AAAAwNOSlL8AAACA3fhRPwAAAGASRJ4/AAAAIN+JYT8AAADAR0KNPwAAAGDD6Ii/AAAAQNm0eT8AAADgxpujvwAAAGCvPqO/AAAAIOfNk78AAADANLqQPwAAAEAsw5u/AAAAANHfWz8AAACAWg6GPwAAAKCVUIG/AAAAQJDqjz8AAAAATIZ1PwAAAAANs4Q/AAAAgPnmaT8AAABAilmEvwAAAEADTVe/AAAAQK+th78AAABABG+APwAAAKCl2IW/AAAAgDzci78AAADAqGl5vwAAACDO32M/AAAA4OfNlb8AAABglS56vwAAAADNvZq/AAAAINRwn78AAAAAIV2avwAAAGAfzIq/AAAAYAoAjD8AAAAgStN+PwAAAECjR3S/AAAA4F3BcL8AAAAg+3eJPwAAAID9CJs/AAAAwPCilT8AAAAgfK9evwAAAEBKZGq/AAAAAGFSlD8AAACgSNOKPwAAACAeXZI/AAAAAFTKlz8AAADAO9yJvwAAAOCL6qO/AAAAAO+Aij8AAAAACG9qPwAAAKCULng/AAAAQIimbT8AAADAbbiZPwAAAKDGCpi/AAAAAH/zUr8AAABgEkSePwAAAIAmf3+/AAAAQFgOYL8AAABA8qKJvwAAAGDN35E/AAAAQKIle78AAACA9KJ/vwAAAGBOF4c/AAAAAOheUb8AAAAgoLaQvwAAAEDFCnS/AAAAwPkIgb8AAADgHl2EvwAAACDUcI+/AAAAgBzMYr8AAACA8sRwPwAAAGCdcow/AAAAoJMMfz8AAADAnAOWPwAAAEDIm4c/AAAAQAyzgr8AAADAVMqJvwAAAEDIm2e/AAAAgEQgjj8AAADgHl1UPwAAAKAmEHu/AAAAYJEMGb8AAACANJiZPwAAAIBwa4K/AAAAwIhZoL8AAACAVcqLvwAAAKAJAIq/AAAAYB1dkD8AAABA3viTvwAAAIB0jXO/AAAAgOlehb8AAAAg9FWQvwAAAODXRaG/AAAAoHhAoL8AAADgNZiNvwAAAECfJaM/AAAAINRwfz8AAAAgVFuTPwAAAKBl42u/AAAAILdgjr8AAAAg6+90vwAAAADb1pS/AAAA4CUQiT8AAADgPm09PwAAAKCYUIk/AAAAgGeWoj8AAACAc/yVPwAAAOARZpM/AAAAIOarqj8AAABgnpSVvwAAAGAD3pI/AAAAgN34kT8AAAAACG+KPwAAAGA5S4g/AAAAQOpehz8AAABAcNqGvwAAAOCk2JO/AAAAYCPui78AAACgO0s+vwAAAIArw2k/AAAAIN+Jgb8AAACA4RqTvwAAAEAooYo/AAAAwPfEjj8AAADAd6+CPwAAAOBGsX+/AAAAoKocgL8AAAAAcLivvwAAAMA73Im/AAAAwPfEnj8AAACA5TyUvwAAAKCccpo/AAAAAHHaqL8AAABgEkR+vwAAAMBhUnY/AAAAIDttU78AAAAgt2COPwAAAMBIZJY/AAAAoJMMjz8AAACAVuyEPwAAAABkUjy/AAAAYLukZr8AAADg7xFoPwAAAEAMs0I/AAAA4MUKZj8AAACAxnl8vwAAAEDh+Iu/AAAAII7qiT8AAACgbSeOPwAAAOD7d4s/AAAAgLcTUT8AAABg+5lQvwAAAOB6QDY/AAAAAK2tkT8AAAAgZ+OPPwAAAEDRcIe/AAAAoE0XpT8AAADgisiKvwAAACAif6O/AAAAwKRHqL8AAADgea+ovwAAAAD0xKS/AAAAYOWriL8AAABAE9WbPwAAACCflGc/AAAAQNa0kT8AAADg0gGHPwAAAKCo2J2/AAAAgH9iab8AAADgsWBwvwAAAGBOF6c/AAAA4Nm0W78AAABgUjmIPwAAAIBKhqE/AAAAQCpUgT8AAABAmb+fvwAAACDWI3Y/AAAAINIBhT8AAACAufF/vwAAAKASZqU/AAAAoHhAoD8AAACAxnk8vwAAACA+bYs/AAAA4H5ilz8AAABgZwWXvwAAAMAAK2o/AAAAYHUeob8AAACgYuOjPwAAAGCacpQ/AAAAID5ti78AAADAJzKEvwAAAEC9xpE/AAAAQLTxcb8AAAAgi+qBPwAAAICmaZO/AAAAgDGYkT8AAAAA7IByPwAAAODWI4i/AAAAAAFNkb8AAAAgS/VnvwAAAGBbn5M/AAAAINtnoD8AAADgS/V5vwAAAIDQcDW/AAAAwAFNo78AAACgBgCSvwAAAOB6QHa/AAAAQMR5Zr8AAACg0AGRPwAAAEA5uhy/AAAAIAO8e78AAAAAhzeVvwAAAEDDV50/AAAAoAXeeL8AAACgWp+RvwAAAICMWYq/AAAAAJCdgL8AAACA2dagPwAAAMCwrau/AAAAAIWEnr8AAABAq4uGPwAAAMAzmDc/AAAAYIWmhT8AAACg/ZlmPwAAAIAaGZy/AAAAgCZ/j78AAADg9FWSvwAAACDAxhk/AAAAQEpkij8AAAAAVMp3PwAAAKC9pHw/AAAAQKuLdr8AAAAgisg4vwAAACDvEYY/AAAAQOBnTr8AAACA9cR4vwAAAGBrJ4g/AAAA4CDMnr8AAAAgPm2bvwAAAKDjiT0/AAAAQKNHlD8AAACgQI+IPwAAAMDFeWo/AAAAgCxUh78AAABAkp2GPwAAAIB3Hqc/AAAAoJVQcT8AAACgtWB6vwAAAOAZqpU/AAAAgPLEoD8AAAAAz3CRvwAAACCSDIu/AAAAoNxnlL8AAABgmnKUvwAAAGDCxo8/AAAAgJ4lgb8AAADgcWuGvwAAAGDLLFu/AAAAQMNXnb8AAABA4hqlPwAAAKAAmo4/AAAAgAqRZ78AAADA+OaHPwAAAKDOTmq/AAAAQA1EkD8AAABAdPyXvwAAAICurZW/AAAAgBoZnD8AAABgpbZevwAAAGDuEYS/AAAAQCpUcT8AAADg4omLPwAAAICc4V4/AAAAgGgnYD8AAACAAk2VvwAAACAPIn8/AAAAIEOxpb8AAADgUzmMvwAAAADwooM/AAAAAP0qkL8AAABg3WeWvwAAAIAP1WE/AAAA4DIHmr8AAADgHcxWPwAAAEBz2o6/AAAAgM/flz8AAACAUah6PwAAAID0oo+/AAAAgJoDcL8AAADAb2tQvwAAAEAqVJE/AAAAgMQKgj8AAABA4GeevwAAAGDCxo+/AAAAwOMaeT8AAABAmb9/vwAAAEDh+Ju/AAAAIPdVeD8AAADAcdpqvwAAAGDHCoo/AAAAIFyflT8AAADgjwylvwAAAIAGb4a/AAAAYGLBnL8AAADggfOqvwAAAMBAIIS/AAAAoH7Ri78AAACgmFBZvwAAAOBquKE/AAAAACV/mz8AAACgxgqIPwAAAMApoZ4/AAAAQNgjjL8AAACgUBetPwAAAICiR5K/AAAAoJAMlz8AAAAgUDmSPwAAAKC6pFQ/AAAAIJpQjb8AAACA9KKPPwAAACDbZ5C/AAAAgOEaQ78AAACgMnZ+vwAAAEAPs5o/AAAAYC3llL8AAABg+nenPwAAAKBmBaW/AAAAoDAHlL8AAADgq/qMvwAAAMDsgGS/AAAAoC/lij8AAAAgfK+OPwAAAMB70XM/AAAAoKCUiz8AAACAapZavwAAACBTOWq/AAAAQMHogr8AAAAgh8hwvwAAAODKvZS/AAAAwCcylD8AAAAAIxCRvwAAAOCo+pQ/AAAAAMFXh78AAABAt/F5PwAAAKCuPoG/AAAAQKIli78AAADAXTClPwAAAKChtoS/AAAAwJe/m78AAAAg6++UPwAAAECzz5g/AAAA4DttlT8AAABAjnuVvwAAACBXW4s/AAAAIAfejL8AAACgqfqWvwAAACC4gme/AAAAAAAraD8AAADArIt6PwAAAMD8CJm/AAAAwLHPpD8AAADAk52avwAAAICc4T6/AAAAoJxyij8AAADgRNOQvwAAAGCm2Ke/AAAAYEbThD8AAADghRWcvwAAAGBafZq/AAAAQCpUgT8AAABAZ3SLvwAAAABAIFI/AAAAYCF/kb8AAABAo0d0vwAAACBYfYS/AAAAQJfhcD8AAADgcWuWPwAAAIBBIJa/AAAAoA0ii78AAACgDkRkvwAAAGAG3oq/AAAAoCoynD8AAAAgn5SXvwAAACCr+oq/AAAAgM/fxz8AAACAOdyTvwAAAKCLyIw/AAAAwJjhlD8AAADgbCdsPwAAAOADvI2/AAAAQOuAUL8AAADgBQBwPwAAAEAEb6C/AAAAgEEghr8AAACAdI2TPwAAAODNTog/AAAAwPCipb8AAACAeK+EPwAAAABtuJc/AAAAIKC2oL8AAACgpdilvwAAAACb4Zq/AAAAAC92pL8AAAAg9FVwvwAAAKCTDI8/AAAAoOL4n78AAAAg8hGOvwAAAOBmlqC/AAAAYP+7kT8AAACAYlJYPwAAAOCxYKC/AAAAgLnxjz8AAABg5s2hPwAAAKD5d6U/AAAAYOrvcr8AAAAAz3BxvwAAAKABvJc/AAAAoAYAkr8AAABgW59zPwAAAODNTpi/AAAAQGBSgr8AAAAA3UV/PwAAAODnzXU/AAAAIGDBhj8AAADgvcZTPwAAAIB2/J2/AAAAIIrIeL8AAACg0AGRvwAAAKBBsaE/AAAAoO0Rgj8AAACAFveKvwAAAKBBsYG/AAAA4GUFI78AAAAAe9GRPwAAAGDpzZm/AAAAIPdVeD8AAABAuBOjPwAAAADR33s/AAAAoOnvkL8AAADgky6WvwAAAMBkUn4/AAAAwE2ogD8AAABAiTdrvwAAAADvgIq/AAAAgE6okr8AAAAgh8hgvwAAAIDhGoM/AAAAIPRVgD8AAABAtPGBvwAAAGAhf3E/AAAAQBgZdr8AAAAAnAOUPwAAAIAeO22/AAAAAGV0hT8AAADA616LvwAAAEC9xpG/AAAAIBo7kb8AAAAg5quavwAAAEC4E3O/AAAAQFbKjb8AAADgIe53PwAAAKBROWY/AAAAAKmLgD8AAACARCCePwAAACCvHIy/AAAAAJ8DjL8AAADAz3CDvwAAAKC1YFo/AAAAQBsZfr8AAABArouOvwAAAKCAhJI/AAAAQJF7fb8AAADAAU1TPwAAAODr73Y/AAAAYIWmhb8AAADgZQWDvwAAAOCjtnq/AAAA4Gq4kT8AAADgW31+vwAAAACcA4Q/AAAAoBJmlT8AAABA4hpVvwAAAEAViGK/AAAAwOyAlL8AAAAAYVKkvwAAAAAhXao/AAAAAFkOkj8AAADgR9OIvwAAAGCm2Je/AAAAgBiqoT8AAABAfvOgvwAAAOCGppm/AAAAILdgnr8AAADgGIh8vwAAAMBRyoE/AAAAAJwDpL8AAABAvcaBPwAAAOBquKE/AAAAgD3+dL8AAADgMgdqPwAAACBUW6M/AAAA4HYedb8AAADAbbiJPwAAAGCSLnI/AAAAQA1EoL8AAADgRNNwPwAAAEAqVGE/AAAAoCjDoT8AAADgXJ+XvwAAAACxz2K/AAAAoLaCo78AAABA3vgTPwAAACCHyHC/AAAAICTujb8AAACg20WbPwAAAODJLJe/AAAAwGmWeD8AAACgFWZdvwAAAMBAIGQ/AAAAoOnvoL8AAAAAlL+BvwAAAOBdwYC/AAAAwIc3h78AAADAKaGOPwAAAMCHN4c/AAAAIF+fXT8AAACg7RGCPwAAAIBiUog/AAAAoKCUaz8AAACg8TOTvwAAAIAXGYQ/AAAAIAO8mz8AAAAgaAV5PwAAAMBRyqG/AAAAoB2qj78AAABg+5mAPwAAACDWI4Y/AAAAYK8+o78AAABgOUuYvwAAAIDLvaa/AAAAIMabgb8AAAAApEeWvwAAAEA63JW/AAAAwIx7kb8AAAAAj3unvwAAAOAFAIC/AAAAgPXEaL8AAACAcGtyvwAAAADANY6/AAAAAKtpf78AAADgGarFvwAAACBy/IE/AAAAgCDukz8AAACA0wGpvwAAAIDA6JA/AAAAAGFShL8AAAAAP/6YPwAAAEDugJi/AAAAgJB7i78AAAAg9FWgvwAAAGAxB5Y/AAAAIDdLcr8AAAAA1QGdvwAAAACkR6a/AAAAAJvhmj8AAADgHcyGPwAAACAaO4G/AAAAQAiRob8AAADgweikPwAAACBn458/AAAA4GwnjD8AAACAapaqvwAAAABhUoQ/AAAA4J+UmT8AAAAAuPGbvwAAAMC9NZg/AAAAoL2kjL8AAABAQ0KBvwAAAKAqMow/AAAAoMXofr8AAAAA/SqAPwAAAKBan3G/AAAAIKKUbz8AAADgfmJ3PwAAAOCKyCq/AAAAoBVmbT8AAAAAhYSePwAAAMApoX6/AAAAQAdviL8AAAAgTxeJvwAAAED65ns/AAAAwKyLej8AAABgH8yavwAAAMAf7oG/AAAAICrDhT8AAAAAWOyIPwAAAOBdwXA/AAAA4Nm0m78AAABAGBl2PwAAAIDg+Jm/AAAA4HiNjz8AAAAA5zx4vwAAAEC9xoE/AAAAYC9UTz8AAAAgKsOVPwAAAOBQOZS/AAAAoOSrdr8AAABgmnKUPwAAAEB8QIo/AAAAwCMQk78AAAAAm+GKPwAAAMBHQp2/AAAAYC9Uj78AAABAVsqdvwAAAOB5r5g/AAAA4HBJnb8AAADgwMarvwAAACDjq3I/AAAAgEVCl78AAACAGKqRvwAAAEBolqS/AAAA4BYZoj8AAAAgYMGWvwAAAOBmlqA/AAAAgJGddD8AAADAR0KdPwAAACAu5RY/AAAA4Ivqcz8AAADgJRCJPwAAAAAQs5y/AAAAQGR0k78AAAAA7ICiPwAAAODWI4i/AAAAgCQQlb8AAABAr613PwAAAABZDmK/AAAAgNSSdr8AAACgvsalvwAAAODwM4G/AAAAIBo7cT8AAADgea84vwAAAOB5r5i/AAAAoJQueL8AAABAENWDPwAAAGC7pIa/AAAAgF9SkD8AAAAghqaHPwAAAEDd1oq/AAAAgCZ/f78AAADAra2TvwAAAOBcn4c/AAAAQJ4Dij8AAADgVFulvwAAAIBqloq/AAAAwOyAZL8AAAAAra2RPwAAAGA+j6K/AAAAwEMgbD8AAABg5s2hPwAAAAAQs4y/AAAAoLJggr8AAABgz05sPwAAAIB2/J0/AAAAAKAldT8AAADABW+EvwAAAKDkq6Y/AAAAYEr1db8AAACA/QhLPwAAAECbA4I/AAAAQIimjT8AAADg4omrPwAAAKCM6mW/AAAAIKO2mL8AAAAAIxCRPwAAAICeJZG/AAAA4HBJjb8AAABg/7uxvwAAAEC7E2s/AAAAgA/VUT8AAAAgky5kvwAAAODAxpu/AAAAACcykr8AAACg6M2XvwAAAOBpJ2S/AAAAwMtOkr8AAABgYsE8vwAAAKD1VZS/AAAAQMR5pr8AAADAG8ygvwAAAGA+j5K/AAAA4OarjD8AAABAXDBRPwAAACB8rz6/AAAAYGLBjD8AAAAA3UWPvwAAAEDLm58/AAAAIKC2UL8AAABAt/F5PwAAAODJLIc/AAAAoFZ9kL8AAAAAEdV1vwAAAOBI9YE/AAAAgHP8hb8AAABACJFRPwAAAOC+V2E/AAAAQFgOoD8AAABALVSZPwAAAMC18XU/AAAAAFTKdz8AAAAgMgeIvwAAAEB1jZW/AAAA4D+Pdr8AAAAgrxx8PwAAAKD9mZa/AAAAgHP8pT8AAABAbLiFvwAAAACY4WI/AAAAgC12kL8AAADgMymDPwAAAGBOFze/AAAAICrDlb8AAABgtmCMvwAAACD7d3m/AAAAgLcTgT8AAADAH+6RPwAAAOD4d5O/AAAAAM29qr8AAAAg4ol5vwAAAEC9xqG/AAAAAEyGhb8AAACgvsaVPwAAAEBxa4Q/AAAAgKJHcj8AAABAWw6IPwAAAOAaO2O/AAAAoDJ2fj8AAAAgtGCWvwAAAKA8bWc/AAAAwCMQg78AAAAAoyWNvwAAAODB6JQ/AAAAgCgyNr8AAABgTfWNvwAAAECjR4Q/AAAAgA6zaD8AAACgZgWFvwAAAIC28Ze/AAAAwOMaiT8AAABgEkR+vwAAAMChR4A/AAAAQNgjnD8AAABAIF2YPwAAAOBy/IM/AAAAQJ8lY78AAABg4qtwPwAAAIB2/I2/AAAAoBJmdT8AAABAGapjvwAAAKDjiX0/AAAAgCQQhb8AAAAgFGaJPwAAAKD1VXQ/AAAAALTPir8AAACgfGKRPwAAAECfJZM/AAAAgF9SoL8AAABg9TM9vwAAAECa4Vi/AAAAgDzcmz8AAACgtoKTvwAAAIB7QIi/AAAAwPCidT8AAADgweh0PwAAACAH3pw/AAAAQIUVej8AAABAJRCXPwAAAAD45qW/AAAAQCzDe78AAABg5s2xvwAAACBXW5s/AAAA4AUAUL8AAAAAXTCTvwAAAEBOhos/AAAA4LWCob8AAABgBwB0vwAAAODfiZM/AAAA4IammT8AAAAAQCCSPwAAAEDzxGI/AAAAoOOJfb8AAABAObqcPwAAAECmR4w/AAAAINpFl78AAADA9MSWvwAAAEDh+Ks/AAAAQL3Gkb8AAADgEESqPwAAAGAhf6E/AAAAoDtLnr8AAADAN7qYPwAAAOCWLk4/AAAAgNSSpj8AAABgJxCdvwAAAKCVUJG/AAAAQDm6jD8AAABAw1edPwAAAGDxEYy/AAAA4MDGW78AAABALMNrPwAAAGDN36G/AAAAQAZNj78AAACg+XelPwAAAMAvdqY/AAAAoILzfL8AAABAcNqWPwAAAAD75l0/AAAAgLbxpz8AAACAeK+kPwAAAIAS1Zm/AAAA4Gq4ob8AAABgXp+LPwAAAADVAZ2/AAAAgAZvhr8AAACgftF7PwAAAABhUpS/AAAAYAK8ib8AAABAySyVPwAAAIDlPIQ/AAAAoIzqlT8AAACAnQN4vwAAAIBW7HS/AAAAgDi6mr8AAADgLweCPwAAAGCN6oe/AAAAAF0wkz8AAAAgGIiKPwAAAECB84g/AAAAwM9wg78AAABAfECKPwAAAIB0jZM/AAAAgCvDaT8AAACASWR4vwAAAADb1pQ/AAAAQPPEgr8AAABgG6qpvwAAACDr7zQ/AAAAgG/ahD8AAACg0AFhvwAAACBK056/AAAAAC3DfT8AAADAqYuSvwAAAOCk2EM/AAAAIIfIkL8AAAAgtGCGvwAAAMDDClA/AAAA4LA+hz8AAACgqhyQvwAAACAWGZA/AAAAoL2kjD8AAAAgrBykvwAAAIDECpI/AAAA4O8RmD8AAADg8zOpPwAAAECCFZI/AAAAAMtOgL8AAABAQf5+vwAAAGCvPpM/AAAAIN+Job8AAABAV+xmvwAAACDnzZM/AAAAAKhplz8AAABgqxyCPwAAAABHQos/AAAAoIo3n78AAABgPo+CvwAAAEA2uoQ/AAAAQFfspj8AAAAgn5R3vwAAAGCn+pA/AAAAQAZNfz8AAAAgp9hpvwAAAODaRXm/AAAA4JMulr8AAACAc/yVPwAAAECSnZa/AAAAYGoFbz8AAAAgpNiBPwAAAKBl41s/AAAAIEwXcT8AAACAaCegvwAAAIDxoqe/AAAAQBPVaz8AAABgnpSVvwAAAGCODHG/AAAAoBJmdT8AAACgqhyQvwAAACDzM4e/AAAAoJEuoD8AAABg9lWWvwAAAIDpXoW/AAAA4BRmqz8AAAAgJqGUPwAAACCWLow/AAAAYP13Dz8AAAAAgxV0PwAAAEAqVIG/AAAAYD1tmT8AAAAAIxCBvwAAAEAQ1ZO/AAAAwEdCfb8AAADgFhmivwAAAEBDQpG/AAAAoOvNfz8AAACgLOWSvwAAAIA0mJm/AAAA4LRgiD8AAADAT4Z/PwAAAGBWW7k/AAAAgHcelz8AAABA88SSPwAAAIBiUog/AAAAYH1io78AAABgrz6TPwAAAMDoXpM/AAAAwCcyhD8AAABgw+hoPwAAAMChR4C/AAAAYPUzjb8AAADA74CcvwAAAMDjGpm/AAAAAKhpd78AAABgp/qgvwAAAEBCIHg/AAAA4HFrlr8AAACAmeGWPwAAAIBmdJk/AAAAoNABkT8AAADAjHuhPwAAACCKyIg/AAAAwIc3pz8AAAAAuROFPwAAACDzM1e/AAAAgN34cT8AAAAA5DygPwAAAAB70ZG/AAAAYHeNi78AAAAAk52YvwAAAABDIHq/AAAAQIk3mz8AAADgm3KovwAAAEAMs5K/AAAAQLw1VL8AAADAz3BjvwAAAED+CG2/AAAAYD6PYj8AAABgtmCcPwAAAOA1mI0/AAAAAMA1fr8AAACALFSHPwAAAMCXvzu/AAAAQFgOoL8AAACgdo15vwAAAKBya5g/AAAAAA2zlL8AAACAuzWCvwAAAEC4E6O/"}]}]}, "source_code": "class SymbolDocEmbeddingHandler(SymbolEmbeddingHandler):\n    def __init__(\n        self,\n        embedding_db: VectorDatabaseProvider,\n        embedding_provider: EmbeddingProvider,\n        code_embedding_handler: SymbolCodeEmbeddingHandler,\n        embedding_db_l2: Optional[VectorDatabaseProvider] = None,\n    ):\n        \"\"\"\n        A constructor for SymbolDocEmbeddingHandler\n\n        Args:\n            embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n            embedding_provider (EmbeddingProvider): The provider to get the embeddings from\n            code_embedding_handler (SymbolCodeEmbeddingHandler): The code embedding handler\n        \"\"\"\n        super().__init__(embedding_db, embedding_provider)\n\n        from automata.core.embedding.symbol_similarity import SymbolSimilarity\n        from automata.core.symbol.search.rank import SymbolRankConfig\n        from automata.core.symbol.search.symbol_search import SymbolSearch\n\n        graph = SymbolGraph()\n        subgraph = graph.get_rankable_symbol_subgraph()\n        symbol_similarity = SymbolSimilarity(code_embedding_handler)\n        self.graph = graph\n        self.symbol_search = SymbolSearch(\n            graph, symbol_similarity, symbol_rank_config=SymbolRankConfig(), code_subgraph=subgraph\n        )\n        self.embedding_db_l2 = embedding_db_l2\n\n    def get_embedding(self, symbol: Symbol) -> SymbolDocEmbedding:\n        \"\"\"\n        Get the embedding of a symbol.\n        Args:\n            symbol (Symbol): Symbol to get the embedding for\n        Returns:\n            SymbolDocEmbedding: The embedding of the symbol documentation\n        \"\"\"\n        return self.embedding_db.get(symbol)\n\n    def update_embedding(self, symbol: Symbol):\n        \"\"\"\n        Concrete method to update the embedding for a symbol.\n\n        Args:\n            symbols_to_update (List[Symbol]): List of symbols to update\n\n        Raises:\n            ValueError: If the symbol has no source code\n\n        NOTE: This method always updates the embedding and associated documentation\n            We should add some logic to check if the documentation needs updating\n            This is non-trivial because of how dependencies interact\n        \"\"\"\n        from automata.core.symbol.symbol_utils import (  # imported late for mocking\n            convert_to_fst_object,\n        )\n\n        source_code = str(convert_to_fst_object(symbol))\n\n        if not source_code:\n            raise ValueError(f\"Symbol {symbol} has no source code\")\n\n        if self.embedding_db.contains(symbol):\n            self.embedding_db.discard(symbol)\n\n        symbol_embedding = self.build_symbol_doc_embedding(source_code, symbol)\n        self.embedding_db.add(symbol_embedding)\n\n    def build_symbol_doc_embedding(self, source_code: str, symbol: Symbol) -> SymbolDocEmbedding:\n        \"\"\"\n        Build the embedding for a symbol's documentation\n\n        Args:\n            source_code (str): The source code of the symbol\n            symbol (Symbol): The symbol to build the embedding for\n\n        Returns:\n            SymbolDocEmbedding: The embedding for the symbol's documentation\n        \"\"\"\n        abbreviated_selected_symbol = symbol.uri.split(\"/\")[1].split(\"#\")[0]\n\n        def get_doc(prompt: str) -> str:\n            \"\"\"\n            Get the documentation for a symbol\n\n            Args:\n                prompt (str): The prompt to use to generate the documentation\n\n            Returns:\n                str: The completed documentation for the symbol\n            \"\"\"\n            completion = openai.ChatCompletion.create(\n                model=\"gpt-4\",\n                messages=[\n                    {\n                        \"role\": \"user\",\n                        \"content\": prompt,\n                    }\n                ],\n            )\n            if not completion.choices:\n                return \"Error: No completion found\"\n\n            return completion.choices[0][\"message\"][\"content\"]\n\n        def get_summary(input_doc: str) -> str:\n            \"\"\"\n            Get a summary for a symbol's documentation\n\n            Args:\n                prompt (str): The prompt to use to generate the documentation\n\n            Returns:\n                str: The completed documentation for the symbol\n            \"\"\"\n\n            completion = openai.ChatCompletion.create(\n                model=\"gpt-4\",\n                messages=[\n                    {\n                        \"role\": \"user\",\n                        \"content\": f\"Condense the documentation below down to one to two concise paragraphs:\\n {input_doc}\\nIf there is an example, include that in full in the output.\",\n                    }\n                ],\n            )\n            if not completion.choices:\n                return \"Error: No completion found\"\n\n            return completion.choices[0][\"message\"][\"content\"]\n\n        # Splice the search results on the symbol\n        # with the search results biased on tests\n        # this is to get bias towards specific examples for the documentation\n        search_results_0 = self.symbol_search.symbol_rank_search(f\"{abbreviated_selected_symbol}\")\n        search_results_1 = self.symbol_search.symbol_rank_search(\n            f\"{abbreviated_selected_symbol} tests or conftest\"\n        )\n\n        search_list: List[Symbol] = []\n        for i in range(len(search_results_0)):\n            set_list = set(search_list)\n            if search_results_0[i] not in set_list:\n                search_list.append(search_results_0[i][0])\n            elif search_results_1[i] not in set_list:\n                search_list.append(search_results_1[i][0])\n\n        retriever = PyContextRetriever(self.graph, doc_embedding_db=self.embedding_db_l2)\n        retriever.process_symbol(symbol, search_list)\n\n        prompt = Template(DEFAULT_DOC_GENERATION_PROMPT).render(\n            symbol_dotpath=abbreviated_selected_symbol,\n            symbol_context=retriever.get_context_buffer(),\n        )\n\n        document = get_doc(prompt)\n        summary = get_summary(document)\n        embedding = self.embedding_provider.build_embedding(document)\n\n        # print(f\"Symbol Context = {retriever.get_context_buffer()}\")\n        print(\"Symbol = \", symbol)\n        import tiktoken\n\n        encoding = tiktoken.encoding_for_model(\"gpt-4\")\n        print(\"Len of context = \", len(encoding.encode(retriever.get_context_buffer())))\n        return SymbolDocEmbedding(\n            symbol,\n            vector=embedding,\n            source_code=source_code,\n            document=document,\n            summary=summary,\n            context=prompt,\n        )\n", "summary": "The `SymbolDocEmbeddingHandler` class is responsible for managing document embeddings for symbols in an AutomataDocs project. It interacts with the `VectorDatabaseProvider` and `EmbeddingProvider` classes and builds symbol objects based on generated document embeddings. The main methods, such as `build_symbol_doc_embedding`, `update_embedding`, `get_embedding`, `get_doc`, and `get_summary`, handle creating, updating, and retrieving symbol document embeddings and their summaries. The class contains a `SymbolGraph` object and employs `SymbolSimilarity`, `SymbolRankConfig`, and `SymbolSearch` for searching, ranking symbols, and generating related context during document embedding creation. However, there are limitations with the `OpenAIEmbedding` class and `SymbolGraph` data structures, which may affect the flexibility and context generation of the embeddings.\n\nExample usage:\n\n```python\nfrom automata.core.embedding.doc_embedding import SymbolDocEmbeddingHandler\nfrom automata.core.database.vector import JSONVectorDatabase, VectorDatabaseProvider\nfrom automata.core.embedding.embedding_types import OpenAIEmbedding, EmbeddingProvider\nfrom automata.core.symbol.symbol_types import Symbol\n\n# Initialize the database provider and embedding provider\ndb_provider = VectorDatabaseProvider(JSONVectorDatabase(\"path/to/symbol_doc_embedding.json\"))\nembedding_provider = EmbeddingProvider(OpenAIEmbedding())\n\n# Create an instance of SymbolDocEmbeddingHandler\nembedding_handler = SymbolDocEmbeddingHandler(db_provider, embedding_provider)\n\n# Example symbol and source code\nsymbol = Symbol.from_string(\"symbol-uri-as-string\")\nsource_code = \"def example_function():\\n    pass\"\n\n# Build the symbol document embedding\nsymbol_doc_embedding = embedding_handler.build_symbol_doc_embedding(source_code, symbol)\n```\n", "context": "\n    Generate the documentation for SymbolDocEmbeddingHandler using the context shown below -\n  Building context for primary symbol - automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler -\n  \n    Import Statements:\n      import logging\n      import os\n      import openai\n      import tiktoken\n      from typing import List, Optional\n      from jinja2 import Template\n      from automata.config.config_enums import ConfigCategory\n      from automata.config.prompt.docs import DEFAULT_DOC_GENERATION_PROMPT\n      from automata.core.context.py_context.retriever import PyContextRetriever\n      from automata.core.database.vector import JSONVectorDatabase, VectorDatabaseProvider\n      from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n      from automata.core.symbol.graph import SymbolGraph\n      from automata.core.symbol.symbol_types import Symbol, SymbolDocEmbedding\n      from automata.core.utils import config_fpath\n      from .embedding_types import EmbeddingProvider, OpenAIEmbedding, SymbolEmbeddingHandler\n      from automata.core.embedding.symbol_similarity import SymbolSimilarity\n      from automata.core.symbol.search.rank import SymbolRankConfig\n      from automata.core.symbol.search.symbol_search import SymbolSearch\n      from automata.core.symbol.symbol_utils import (  # imported late for mocking\n                  convert_to_fst_object,\n              )\n      \n      # SymbolDocEmbeddingHandler\n      \n      `SymbolDocEmbeddingHandler` is a class responsible for generating, storing, and managing document embeddings for symbols in the context of an AutomataDocs project. It is used for creating, updating, and retrieving symbol document embeddings, interacting with the `VectorDatabaseProvider` and `EmbeddingProvider` classes, and building symbol objects based on generated document embeddings. \n      \n      ## Overview\n      \n      `SymbolDocEmbeddingHandler` class is initialized with an instance of `VectorDatabaseProvider`, an instance of `EmbeddingProvider`, and an optional path string for storing the code embedding. The main methods of this class are `build_symbol_doc_embedding`, `update_embedding`, `get_embedding`, `get_doc`, and `get_summary`. These methods are used to manage symbol document embeddings as well as generate their summaries.\n      \n      The class also contains a `SymbolGraph` object and utilizes `SymbolSimilarity`, `SymbolRankConfig`, and `SymbolSearch` for searching and ranking symbols and generating related context when building the symbol document embeddings.\n      \n      ## Related Symbols\n      \n      - `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n      - `automata.core.symbol.symbol_types.SymbolDocEmbedding`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.embedding.embedding_types.SymbolEmbeddingHandler`\n      - `automata.core.embedding.symbol_similarity.SymbolSimilarity`\n      - `automata.core.symbol.search.rank.SymbolRankConfig`\n      - `automata.core.symbol.search.symbol_search.SymbolSearch`\n      - `automata.core.symbol.graph.SymbolGraph`\n      \n      ## Example\n      \n      The following example demonstrates how to create an instance of `SymbolDocEmbeddingHandler` and build a symbol document embedding.\n      \n      ```python\n      from automata.core.embedding.doc_embedding import SymbolDocEmbeddingHandler\n      from automata.core.database.vector import JSONVectorDatabase, VectorDatabaseProvider\n      from automata.core.embedding.embedding_types import OpenAIEmbedding, EmbeddingProvider\n      from automata.core.symbol.symbol_types import Symbol\n      \n      # Initialize the database provider and embedding provider\n      db_provider = VectorDatabaseProvider(JSONVectorDatabase(\"path/to/symbol_doc_embedding.json\"))\n      embedding_provider = EmbeddingProvider(OpenAIEmbedding())\n      \n      # Create an instance of SymbolDocEmbeddingHandler\n      embedding_handler = SymbolDocEmbeddingHandler(db_provider, embedding_provider)\n      \n      # Example symbol and source code\n      symbol = Symbol.from_string(\"symbol-uri-as-string\")\n      source_code = \"def example_function():\\n    pass\"\n      \n      # Build the symbol document embedding\n      symbol_doc_embedding = embedding_handler.build_symbol_doc_embedding(source_code, symbol)\n      ```\n      \n      ## Limitations\n      \n      The `SymbolDocEmbeddingHandler` relies on the `OpenAIEmbedding` class for generating embeddings, which may have limitations in terms of the models and algorithms used. Furthermore, it depends on the data structures provided by the `SymbolGraph` for generating context, which may impose constraints on the flexibility of the embeddings generated.\n      \n      In addition, when generating the context and documentation for a symbol, the current implementation might not always prioritize the best examples for documentation or might fail to retrieve certain documentation. Through, improvements in the `SymbolSimilarity` and `SymbolRankConfig` components can potentially enhance the quality of generated symbol document embeddings.\n      \n      ## Follow-up Questions:\n      \n      - Can other embedding techniques/models be integrated easily with the `SymbolDocEmbeddingHandler` class?\n      - Is there any way to improve the quality of context generation or example selection for symbol document embeddings?\n      \n      \n    Methods:\n      def __init__(\n              self,\n              embedding_db: VectorDatabaseProvider,\n              embedding_provider: EmbeddingProvider,\n              code_embedding_handler: SymbolCodeEmbeddingHandler,\n              embedding_db_l2: Optional[VectorDatabaseProvider] = None,\n          ):\n              \"\"\"\n              A constructor for SymbolDocEmbeddingHandler\n      \n              Args:\n                  embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                  embedding_provider (EmbeddingProvider): The provider to get the embeddings from\n                  code_embedding_handler (SymbolCodeEmbeddingHandler): The code embedding handler\n              \"\"\"\n              super().__init__(embedding_db, embedding_provider)\n      \n              from automata.core.embedding.symbol_similarity import SymbolSimilarity\n              from automata.core.symbol.search.rank import SymbolRankConfig\n              from automata.core.symbol.search.symbol_search import SymbolSearch\n      \n              graph = SymbolGraph()\n              subgraph = graph.get_rankable_symbol_subgraph()\n              symbol_similarity = SymbolSimilarity(code_embedding_handler)\n              self.graph = graph\n              self.symbol_search = SymbolSearch(\n                  graph, symbol_similarity, symbol_rank_config=SymbolRankConfig(), code_subgraph=subgraph\n              )\n              self.embedding_db_l2 = embedding_db_l2\n      \n          \n      def build_symbol_doc_embedding(self, source_code: str, symbol: Symbol) -> SymbolDocEmbedding:\n              \"\"\"\n              Build the embedding for a symbol's documentation\n      \n              Args:\n                  source_code (str): The source code of the symbol\n                  symbol (Symbol): The symbol to build the embedding for\n      \n              Returns:\n                  SymbolDocEmbedding: The embedding for the symbol's documentation\n              \"\"\"\n              abbreviated_selected_symbol = symbol.uri.split(\"/\")[1].split(\"#\")[0]\n      \n              def get_doc(prompt: str) -> str:\n                  \"\"\"\n                  Get the documentation for a symbol\n      \n                  Args:\n                      prompt (str): The prompt to use to generate the documentation\n      \n                  Returns:\n                      str: The completed documentation for the symbol\n                  \"\"\"\n                  completion = openai.ChatCompletion.create(\n                      model=\"gpt-4\",\n                      messages=[\n                          {\n                              \"role\": \"user\",\n                              \"content\": prompt,\n                          }\n                      ],\n                  )\n                  if not completion.choices:\n                      return \"Error: No completion found\"\n      \n                  return completion.choices[0][\"message\"][\"content\"]\n      \n              def get_summary(input_doc: str) -> str:\n                  \"\"\"\n                  Get a summary for a symbol's documentation\n      \n                  Args:\n                      prompt (str): The prompt to use to generate the documentation\n      \n                  Returns:\n                      str: The completed documentation for the symbol\n                  \"\"\"\n      \n                  completion = openai.ChatCompletion.create(\n                      model=\"gpt-4\",\n                      messages=[\n                          {\n                              \"role\": \"user\",\n                              \"content\": f\"Condense the documentation below down to one to two concise paragraphs:\\n {input_doc}\\nIf there is an example, include that in full in the output.\",\n                          }\n                      ],\n                  )\n                  if not completion.choices:\n                      return \"Error: No completion found\"\n      \n                  return completion.choices[0][\"message\"][\"content\"]\n      \n              # Splice the search results on the symbol\n              # with the search results biased on tests\n              # this is to get bias towards specific examples for the documentation\n              search_results_0 = self.symbol_search.symbol_rank_search(f\"{abbreviated_selected_symbol}\")\n              search_results_1 = self.symbol_search.symbol_rank_search(\n                  f\"{abbreviated_selected_symbol} tests or conftest\"\n              )\n      \n              search_list: List[Symbol] = []\n              for i in range(len(search_results_0)):\n                  set_list = set(search_list)\n                  if search_results_0[i] not in set_list:\n                      search_list.append(search_results_0[i][0])\n                  elif search_results_1[i] not in set_list:\n                      search_list.append(search_results_1[i][0])\n      \n              retriever = PyContextRetriever(self.graph, doc_embedding_db=self.embedding_db_l2)\n              retriever.process_symbol(symbol, search_list)\n      \n              prompt = Template(DEFAULT_DOC_GENERATION_PROMPT).render(\n                  symbol_dotpath=abbreviated_selected_symbol,\n                  symbol_context=retriever.get_context_buffer(),\n              )\n      \n              document = get_doc(prompt)\n              summary = get_summary(document)\n              embedding = self.embedding_provider.build_embedding(document)\n      \n              # print(f\"Symbol Context = {retriever.get_context_buffer()}\")\n              print(\"Symbol = \", symbol)\n              import tiktoken\n      \n              encoding = tiktoken.encoding_for_model(\"gpt-4\")\n              print(\"Len of context = \", len(encoding.encode(retriever.get_context_buffer())))\n              return SymbolDocEmbedding(\n                  symbol,\n                  vector=embedding,\n                  source_code=source_code,\n                  document=document,\n                  summary=summary,\n                  context=prompt,\n              )\n      \n      def get_doc(prompt: str) -> str:\n                  \"\"\"\n                  Get the documentation for a symbol\n      \n                  Args:\n                      prompt (str): The prompt to use to generate the documentation\n      \n                  Returns:\n                      str: The completed documentation for the symbol\n                  \"\"\"\n                  completion = openai.ChatCompletion.create(\n                      model=\"gpt-4\",\n                      messages=[\n                          {\n                              \"role\": \"user\",\n                              \"content\": prompt,\n                          }\n                      ],\n                  )\n                  if not completion.choices:\n                      return \"Error: No completion found\"\n      \n                  return completion.choices[0][\"message\"][\"content\"]\n      \n              \n      def get_embedding(self, symbol: Symbol) -> SymbolDocEmbedding:\n              \"\"\"\n              Get the embedding of a symbol.\n              Args:\n                  symbol (Symbol): Symbol to get the embedding for\n              Returns:\n                  SymbolDocEmbedding: The embedding of the symbol documentation\n              \"\"\"\n              return self.embedding_db.get(symbol)\n      \n          \n      def get_summary(input_doc: str) -> str:\n                  \"\"\"\n                  Get a summary for a symbol's documentation\n      \n                  Args:\n                      prompt (str): The prompt to use to generate the documentation\n      \n                  Returns:\n                      str: The completed documentation for the symbol\n                  \"\"\"\n      \n                  completion = openai.ChatCompletion.create(\n                      model=\"gpt-4\",\n                      messages=[\n                          {\n                              \"role\": \"user\",\n                              \"content\": f\"Condense the documentation below down to one to two concise paragraphs:\\n {input_doc}\\nIf there is an example, include that in full in the output.\",\n                          }\n                      ],\n                  )\n                  if not completion.choices:\n                      return \"Error: No completion found\"\n      \n                  return completion.choices[0][\"message\"][\"content\"]\n      \n              # Splice the search results on the symbol\n              # with the search results biased on tests\n              # this is to get bias towards specific examples for the documentation\n              \n      def update_embedding(self, symbol: Symbol):\n              \"\"\"\n              Concrete method to update the embedding for a symbol.\n      \n              Args:\n                  symbols_to_update (List[Symbol]): List of symbols to update\n      \n              Raises:\n                  ValueError: If the symbol has no source code\n      \n              NOTE: This method always updates the embedding and associated documentation\n                  We should add some logic to check if the documentation needs updating\n                  This is non-trivial because of how dependencies interact\n              \"\"\"\n              from automata.core.symbol.symbol_utils import (  # imported late for mocking\n                  convert_to_fst_object,\n              )\n      \n              source_code = str(convert_to_fst_object(symbol))\n      \n              if not source_code:\n                  raise ValueError(f\"Symbol {symbol} has no source code\")\n      \n              if self.embedding_db.contains(symbol):\n                  self.embedding_db.discard(symbol)\n      \n              symbol_embedding = self.build_symbol_doc_embedding(source_code, symbol)\n              self.embedding_db.add(symbol_embedding)\n      \n          \n  Building context for related symbols -\n  \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.core.symbol.symbol_types.SymbolDocEmbedding\n    \n        `SymbolDocEmbedding` is a class representing the embedding for symbol documents, extending the `SymbolEmbedding` class with added metadata such as source code, summary, and context. This class is utilized alongside `SymbolDocEmbeddingHandler` to manage and access these embeddings for tasks like search and similarity comparison. However, it relies on external handler classes and assumes embeddings are provided as NumPy arrays, potentially limiting usage for other embedding types.\n        \n        ```python\n        import numpy as np\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.symbol.symbol_types import SymbolDocEmbedding\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        symbol = Symbol.from_string(symbol_str)\n        \n        document = \"This is a sample document\"\n        vector = np.array([0.1, 0.2, 0.3])\n        source_code = \"class ActionIndicator(Enum): ...\"\n        summary = \"This class represents an enum for action indicators.\"\n        context = \"The ActionIndicator enum is used to describe the current state...\"\n        \n        embedding = SymbolDocEmbedding(symbol, document, vector, source_code=source_code, summary=summary, context=context)\n        ```\n        \n      Class Docstring:\n        Embedding for symbol documents\n        \n      Methods:\n        def __init__(\n                self,\n                symbol: Symbol,\n                document: str,\n                vector: np.array,\n                source_code: Optional[str] = None,\n                summary: Optional[str] = None,\n                context: Optional[str] = None,\n            ):\n                super().__init__(symbol, document, vector)\n                # begin additional meta data\n                self.source_code = source_code\n                self.summary = summary\n                self.context = context\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.embedding.embedding_types.SymbolEmbeddingHandler\n    \n        `SymbolEmbeddingHandler` is an abstract class that manages symbol embeddings by fetching and updating the vector embeddings related to various kinds of symbols. It must be subclassed by other classes that provide implementations of the defined abstract methods, such as `get_embedding()` and `update_embedding()`. The performance of these methods may depend on the chosen embedding provider and database used for storing the embeddings.\n        \n        Here is an example of how to subclass `SymbolEmbeddingHandler` and implement the abstract methods:\n        \n        ```python\n        from automata.core.embedding.embedding_types import SymbolEmbeddingHandler\n        from automata.core.symbol.symbol_types import Symbol\n        \n        class CustomSymbolEmbeddingHandler(SymbolEmbeddingHandler):\n            def __init__(self, embedding_db, embedding_provider):\n                super().__init__(embedding_db, embedding_provider)\n        \n            def get_embedding(self, symbol: Symbol):\n                # Implement logic to get the embedding for a custom symbol\n                pass\n        \n            def update_embedding(self, symbol: Symbol):\n                # Implement logic to update the embedding for a custom symbol\n                pass\n        \n        # Example usage:\n        custom_handler = CustomSymbolEmbeddingHandler(embedding_db, embedding_provider)\n        custom_embedding = custom_handler.get_embedding(custom_symbol)\n        ```\n        \n      Class Docstring:\n        An abstract class to handle the embedding of symbols\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"An abstract constructor for SymbolEmbeddingHandler\"\"\"\n                self.embedding_db = embedding_db\n                self.embedding_provider = embedding_provider\n        \n            \n        get_embedding(self, symbol: Symbol) -> Any\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n    automata.tests.unit.conftest.get_sem\n    \n        def get_sem(monkeypatch, temp_output_filename):\n            monkeypatch.setattr(\n                \"automata.core.symbol.symbol_utils.convert_to_fst_object\",\n                lambda args: \"symbol_source\",\n            )\n            return SymbolCodeEmbeddingHandler(temp_output_filename)\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.SymbolEmbedding\n    \n        SymbolEmbedding is an abstract base class used to represent various symbol embeddings, such as SymbolCodeEmbedding and SymbolDocEmbedding. It provides a basic structure for initializing and managing these embeddings, taking into account their source and their vector representation in the feature space. SymbolEmbedding is utilized by different embedding handlers like SymbolCodeEmbeddingHandler and SymbolDocEmbeddingHandler. As a base class, its functionality is limited and should be extended by classes with specific embedding types. An example of creating a SymbolCodeEmbedding instance is shown below:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def __init__(self, message): pass\"\n        vector = np.array([0.1, 0.2, 0.3])\n        \n        symbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Abstract base class for different types of embeddings\n        \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n    automata.tests.unit.sample_modules.sample.OuterClass.InnerClass\n    \n        class InnerClass:\n                \"\"\"Inner doc strings\"\"\"\n        \n                def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.core.embedding.embedding_types.EmbeddingProvider\n    \n        `EmbeddingProvider` is an abstract base class that serves as an interface for obtaining mathematical representations called embeddings for symbols, used in tasks such as similarity search, ranking, and other natural language processing-related work. Its single abstract method, `build_embedding`, should be implemented by all subclasses to provide specific embedding implementations. Users must create their own classes that inherit from `EmbeddingProvider` and implement these methods, which might be a limitation for those unfamiliar with custom classes and abstract methods.\n        \n        Here is an example of using the `OpenAIEmbedding` class, a concrete implementation of `EmbeddingProvider`:\n        \n        ```python\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        import numpy as np\n        \n        symbol_source = \"This is an example of a Python function.\"\n        embedding_provider = OpenAIEmbedding() \n        embedding = embedding_provider.build_embedding(symbol_source)\n        \n        # Check if the generated embedding is a numpy array\n        assert isinstance(embedding, np.ndarray)\n        ```\n        Performance and accuracy of embeddings depend on the specific model and approach used in the concrete implementation of `EmbeddingProvider`.\n        \n      Class Docstring:\n        A class to provide embeddings for symbols\n        \n      Methods:\n        build_embedding(self, symbol_source: str) -> np.ndarray\n        \n    automata.tests.unit.sample_modules.sample.OuterClass\n    \n        class OuterClass:\n            class InnerClass:\n                \"\"\"Inner doc strings\"\"\"\n        \n                def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.core.symbol.symbol_types.SymbolCodeEmbedding\n    \n        `SymbolCodeEmbedding` is a class extending the `SymbolEmbedding` base class, used to store code embeddings for a given symbol, the symbol object, source code, and the embedding vector. It primarily serves as a container for these embeddings and does not include functionality for generating or handling them; `SymbolCodeEmbeddingHandler` should be used for those purposes.\n        \n        Here's an example of creating a `SymbolCodeEmbedding` instance:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def example_function():\\n    pass\"\n        vector = np.random.random((300,))\n        \n        embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Embedding for symbol code\n        \n      Methods:\n        def __init__(self, symbol: Symbol, source_code: str, vector: np.array):\n                super().__init__(symbol, source_code, vector)\n        \n        \n        \n  Building context for dependencies -\n  \n    automata.core.symbol.search.symbol_search.SymbolSearch.symbol_rank_search\n    \n      Class Docstring:\n        Fetches the list of the SymbolRank similar symbols ordered by rank\n        \n        Args:\n        query (str): The query to search for\n        \n        Returns:\n        A list of tuples of the form (symbol_uri, rank)\n        \n      Methods:\n        symbol_rank_search(self, query: str) -> SymbolRankResult\n        \n    automata.core.database.provider.SymbolDatabaseProvider.add\n    \n      Class Docstring:\n        Abstract method to add an embedding to the database.\n        \n      Methods:\n        add(self, embedding: SymbolEmbedding) -> None\n        \n    automata.core.symbol.symbol_utils.convert_to_fst_object\n    \n      Class Docstring:\n        Converts a specified symbol into a red baron FST object\n        \n        Args:\n        symbol (str): The symbol which corresponds to a module, class, or method.\n        module_map (Optional[LazyModuleTreeMap]): The module tree mapping to use. If None, the default\n        \n        Returns:\n        Union[ClassNode, DefNode]: The RedBaron FST object for the class or method, or None if not found\n        \n        Raises:\n        ValueError: If the symbol is not found\n        \n        Note:\n        The optional argument is to allow us to run this function in mulitprocessing in the future,\n        because module map is not picklable (because redbaron objects are not picklable)\n        So the indexer would have to be created and destroyed in each process.\n        \n      Methods:\n        convert_to_fst_object(symbol: Symbol, module_map: Optional[LazyModuleTreeMap] = None) -> RedBaron\n        \n    automata.core.context.py_context.retriever.PyContextRetriever.get_context_buffer\n    \n      Class Docstring:\n        Get the context buffer\n        \n        Returns:\n        str: The context buffer\n        \n      Methods:\n        get_context_buffer(self) -> str\n        \n    automata.core.embedding.embedding_types.SymbolEmbeddingHandler.__init__\n    \n      Class Docstring:\n        An abstract constructor for SymbolEmbeddingHandler\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"An abstract constructor for SymbolEmbeddingHandler\"\"\"\n                self.embedding_db = embedding_db\n                self.embedding_provider = embedding_provider\n        \n            \n    automata.core.symbol.graph.SymbolGraph\n    \n        The `SymbolGraph` class represents a symbol graph that captures relationships between symbols found in source code files and is built from an index protobuf file. Utilizing NetworkX's MultiDiGraph, `SymbolGraph` represents relationships as a directed graph and includes methods for querying relationships, obtaining all available symbols and files, and filtering to subgraphs of rankable symbols. A navigator interface, _SymbolGraphNavigator, is required for getting reachable objects in the symbol subgraph.\n        \n        Example usage:\n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        \n        # Replace with your own file path\n        index_path = \"path/to/index.scip\"\n        symbol_graph = SymbolGraph(index_path)\n        all_symbols = symbol_graph.get_all_available_symbols()\n        ```\n        \n        Limitations include only being built from index protobuf files and the `get_potential_symbol_callers` method requiring downstream filtering to remove non-call statements. Future improvements may address these limitations and better handle edge cases in the symbol graph building process.\n        \n      Methods:\n        def __init__(\n                self, index_path: str = DEFAULT_SCIP_PATH, build_caller_relationships: bool = False\n            ):\n                \"\"\"\n                Initializes SymbolGraph with the path of an index protobuf file.\n        \n                Args:\n                    index_path (str): Path to index protobuf file\n                Returns:\n                    SymbolGraph instance\n                \"\"\"\n                index = self._load_index_protobuf(index_path)\n                builder = GraphBuilder(index, build_caller_relationships)\n                self._graph = builder.build_graph()\n                self.navigator = _SymbolGraphNavigator(self._graph)\n        \n            \n        get_all_available_symbols(self) -> List[Symbol]\n        \n        get_all_files(self) -> List[SymbolFile]\n        \n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n        get_rankable_symbol_subgraph(self, flow_rank=\"bidirectional\", path_filter: Optional[str] = None) -> SubGraph\n        \n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.embedding.embedding_types`/EmbeddingProvider#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.embedding.embedding_types", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "EmbeddingProvider", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# EmbeddingProvider\n\n`EmbeddingProvider` is an abstract base class that provides an interface for obtaining embeddings for symbols. Embeddings are mathematical representations of symbols that can be used for various tasks such as similarity search, ranking, and other natural language processing related work. The class contains a single abstract method, `build_embedding`, which should be implemented by all subclasses to provide the specific embedding implementation.\n\n## Related Symbols\n\n- `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n- `automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler`\n- `automata.core.embedding.embedding_types.SymbolEmbeddingHandler`\n- `automata.core.embedding.embedding_types.OpenAIEmbedding`\n- `automata.core.symbol.symbol_types.SymbolEmbedding`\n- `automata.core.symbol.symbol_types.SymbolDocEmbedding`\n- `automata.core.database.vector.JSONVectorDatabase`\n- `automata.core.symbol.symbol_types.Symbol`\n\n## Example\n\nThe following is an example of how to use the `OpenAIEmbedding` class, which is a concrete implementation of `EmbeddingProvider`.\n\n```python\nfrom automata.core.embedding.embedding_types import OpenAIEmbedding\nimport numpy as np\n\nsymbol_source = \"This is an example of a Python function.\"\nembedding_provider = OpenAIEmbedding() \nembedding = embedding_provider.build_embedding(symbol_source)\n\n# Check if the generated embedding is a numpy array\nassert isinstance(embedding, np.ndarray)\n```\n\n## Limitations\n\nAs `EmbeddingProvider` is an abstract base class, it cannot be instantiated directly. Users must create their own classes that inherit from `EmbeddingProvider` and implement the necessary methods. This can be a limitation for users who are not familiar with creating custom classes and implementing abstract methods.\n\nAdditionally, the specific embedding approach and model used by a concrete implementation of `EmbeddingProvider` may limit the overall performance and accuracy of the embeddings.\n\n## Follow-up Questions:\n\n- How can we efficiently implement new embedding providers for different types of models?\n- What are the best practices for selecting an optimal embedding provider for a given task?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class EmbeddingProvider(abc.ABC):\n    \"\"\"A class to provide embeddings for symbols\"\"\"\n\n    @abc.abstractmethod\n    def build_embedding(self, symbol_source: str) -> np.ndarray:\n        pass\n\n\n", "summary": "The `EmbeddingProvider` is an abstract base class that offers an interface for obtaining mathematical representations (embeddings) of symbols, which can be used for similarity search, ranking, and other natural language processing tasks. Users must create custom classes that inherit from `EmbeddingProvider` and implement the required methods. The example below demonstrates using the `OpenAIEmbedding`, a concrete implementation of `EmbeddingProvider`:\n\n```python\nfrom automata.core.embedding.embedding_types import OpenAIEmbedding\nimport numpy as np\n\nsymbol_source = \"This is an example of a Python function.\"\nembedding_provider = OpenAIEmbedding() \nembedding = embedding_provider.build_embedding(symbol_source)\n\n# Check if the generated embedding is a numpy array\nassert isinstance(embedding, np.ndarray)\n```\n\nThe performance and accuracy of the system may be limited by the embedding approach and model used by a specific implementation of `EmbeddingProvider`. Users should consider the efficiency of new embedding providers and best practices for selecting an optimal provider for a given task.", "context": "\n    Generate the documentation for EmbeddingProvider using the context shown below -\n  Building context for primary symbol - automata.core.embedding.embedding_types.EmbeddingProvider -\n  \n    Import Statements:\n      import abc\n      import logging\n      import numpy as np\n      import openai\n      from enum import Enum\n      from typing import Any, Dict\n      from automata.core.database.vector import VectorDatabaseProvider\n      from automata.core.symbol.symbol_types import Symbol\n      from config import OPENAI_API_KEY\n      from openai.embeddings_utils import get_embedding\n      \n      # EmbeddingProvider\n      \n      `EmbeddingProvider` is an abstract base class that provides an interface for obtaining embeddings for symbols. Embeddings are mathematical representations of symbols that can be used for various tasks such as similarity search, ranking, and other natural language processing related work. The class contains a single abstract method, `build_embedding`, which should be implemented by all subclasses to provide the specific embedding implementation.\n      \n      ## Related Symbols\n      \n      - `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n      - `automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler`\n      - `automata.core.embedding.embedding_types.SymbolEmbeddingHandler`\n      - `automata.core.embedding.embedding_types.OpenAIEmbedding`\n      - `automata.core.symbol.symbol_types.SymbolEmbedding`\n      - `automata.core.symbol.symbol_types.SymbolDocEmbedding`\n      - `automata.core.database.vector.JSONVectorDatabase`\n      - `automata.core.symbol.symbol_types.Symbol`\n      \n      ## Example\n      \n      The following is an example of how to use the `OpenAIEmbedding` class, which is a concrete implementation of `EmbeddingProvider`.\n      \n      ```python\n      from automata.core.embedding.embedding_types import OpenAIEmbedding\n      import numpy as np\n      \n      symbol_source = \"This is an example of a Python function.\"\n      embedding_provider = OpenAIEmbedding() \n      embedding = embedding_provider.build_embedding(symbol_source)\n      \n      # Check if the generated embedding is a numpy array\n      assert isinstance(embedding, np.ndarray)\n      ```\n      \n      ## Limitations\n      \n      As `EmbeddingProvider` is an abstract base class, it cannot be instantiated directly. Users must create their own classes that inherit from `EmbeddingProvider` and implement the necessary methods. This can be a limitation for users who are not familiar with creating custom classes and implementing abstract methods.\n      \n      Additionally, the specific embedding approach and model used by a concrete implementation of `EmbeddingProvider` may limit the overall performance and accuracy of the embeddings.\n      \n      ## Follow-up Questions:\n      \n      - How can we efficiently implement new embedding providers for different types of models?\n      - What are the best practices for selecting an optimal embedding provider for a given task?\n      \n    Class Docstring:\n      A class to provide embeddings for symbols\n      \n    Methods:\n      @abc.abstractmethod\n          def build_embedding(self, symbol_source: str) -> np.ndarray:\n              pass\n      \n      \n      \n  Building context for related symbols -\n  \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler\n    \n        The `SymbolDocEmbeddingHandler` class is responsible for generating, storing, and managing document embeddings for symbols in an AutomataDocs project. It relies on the `VectorDatabaseProvider`, `EmbeddingProvider` classes, and uses methods like `build_symbol_doc_embedding`, `update_embedding`, `get_embedding`, `get_doc`, and `get_summary` for managing symbol document embeddings and their summaries. The class utilizes various other components like `SymbolGraph`, `SymbolSimilarity`, and `SymbolRankConfig` to search, rank, and generate context for symbol embeddings. However, it has limitations concerning the embedding models and algorithms used and can sometimes produce suboptimal context or examples. Improving the underlying components can potentially enhance the embedding quality.\n        \n        Example usage:\n        \n        ```python\n        from automata.core.embedding.doc_embedding import SymbolDocEmbeddingHandler\n        from automata.core.database.vector import JSONVectorDatabase, VectorDatabaseProvider\n        from automata.core.embedding.embedding_types import OpenAIEmbedding, EmbeddingProvider\n        from automata.core.symbol.symbol_types import Symbol\n        \n        # Initialize the database provider and embedding provider\n        db_provider = VectorDatabaseProvider(JSONVectorDatabase(\"path/to/symbol_doc_embedding.json\"))\n        embedding_provider = EmbeddingProvider(OpenAIEmbedding())\n        \n        # Create an instance of SymbolDocEmbeddingHandler\n        embedding_handler = SymbolDocEmbeddingHandler(db_provider, embedding_provider)\n        \n        # Example symbol and source code\n        symbol = Symbol.from_string(\"symbol-uri-as-string\")\n        source_code = \"def example_function():\\n    pass\"\n        \n        # Build the symbol document embedding\n        symbol_doc_embedding = embedding_handler.build_symbol_doc_embedding(source_code, symbol)\n        ```\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n                code_embedding_handler: SymbolCodeEmbeddingHandler,\n                embedding_db_l2: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                A constructor for SymbolDocEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (EmbeddingProvider): The provider to get the embeddings from\n                    code_embedding_handler (SymbolCodeEmbeddingHandler): The code embedding handler\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n                from automata.core.embedding.symbol_similarity import SymbolSimilarity\n                from automata.core.symbol.search.rank import SymbolRankConfig\n                from automata.core.symbol.search.symbol_search import SymbolSearch\n        \n                graph = SymbolGraph()\n                subgraph = graph.get_rankable_symbol_subgraph()\n                symbol_similarity = SymbolSimilarity(code_embedding_handler)\n                self.graph = graph\n                self.symbol_search = SymbolSearch(\n                    graph, symbol_similarity, symbol_rank_config=SymbolRankConfig(), code_subgraph=subgraph\n                )\n                self.embedding_db_l2 = embedding_db_l2\n        \n            \n        build_symbol_doc_embedding(self, source_code: str, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_doc(prompt: str) -> str\n        \n        get_embedding(self, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_summary(input_doc: str) -> str\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n    automata.tests.unit.test_symbol_embedding.test_get_embedding\n    \n        def test_get_embedding(\n            monkeypatch,\n            mock_embedding,\n            mock_simple_method_symbols,\n        ):\n            # Mock EmbeddingProvider methods\n            mock_provider = Mock(EmbeddingProvider)\n            mock_provider.build_embedding.return_value = mock_embedding\n        \n            # Mock JSONVectorDatabase methods\n            mock_db = MagicMock(JSONVectorDatabase)\n            mock_db.get.return_value = SymbolCodeEmbedding(\n                mock_simple_method_symbols[0], \"symbol_source\", mock_embedding\n            )\n        \n            # Create an instance of the class\n            cem = SymbolCodeEmbeddingHandler(embedding_provider=mock_provider, embedding_db=mock_db)\n        \n            # Call the method\n            embedding = cem.get_embedding(mock_simple_method_symbols[0])\n        \n            # Verify the results\n            assert embedding.vector.all() == mock_embedding.all()\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.SymbolEmbedding\n    \n        SymbolEmbedding is an abstract base class used to represent various symbol embeddings, such as SymbolCodeEmbedding and SymbolDocEmbedding. It provides a basic structure for initializing and managing these embeddings, taking into account their source and their vector representation in the feature space. SymbolEmbedding is utilized by different embedding handlers like SymbolCodeEmbeddingHandler and SymbolDocEmbeddingHandler. As a base class, its functionality is limited and should be extended by classes with specific embedding types. An example of creating a SymbolCodeEmbedding instance is shown below:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def __init__(self, message): pass\"\n        vector = np.array([0.1, 0.2, 0.3])\n        \n        symbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Abstract base class for different types of embeddings\n        \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n    automata.core.embedding.embedding_types.SymbolEmbeddingHandler\n    \n        `SymbolEmbeddingHandler` is an abstract class that manages symbol embeddings by fetching and updating the vector embeddings related to various kinds of symbols. It must be subclassed by other classes that provide implementations of the defined abstract methods, such as `get_embedding()` and `update_embedding()`. The performance of these methods may depend on the chosen embedding provider and database used for storing the embeddings.\n        \n        Here is an example of how to subclass `SymbolEmbeddingHandler` and implement the abstract methods:\n        \n        ```python\n        from automata.core.embedding.embedding_types import SymbolEmbeddingHandler\n        from automata.core.symbol.symbol_types import Symbol\n        \n        class CustomSymbolEmbeddingHandler(SymbolEmbeddingHandler):\n            def __init__(self, embedding_db, embedding_provider):\n                super().__init__(embedding_db, embedding_provider)\n        \n            def get_embedding(self, symbol: Symbol):\n                # Implement logic to get the embedding for a custom symbol\n                pass\n        \n            def update_embedding(self, symbol: Symbol):\n                # Implement logic to update the embedding for a custom symbol\n                pass\n        \n        # Example usage:\n        custom_handler = CustomSymbolEmbeddingHandler(embedding_db, embedding_provider)\n        custom_embedding = custom_handler.get_embedding(custom_symbol)\n        ```\n        \n      Class Docstring:\n        An abstract class to handle the embedding of symbols\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"An abstract constructor for SymbolEmbeddingHandler\"\"\"\n                self.embedding_db = embedding_db\n                self.embedding_provider = embedding_provider\n        \n            \n        get_embedding(self, symbol: Symbol) -> Any\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n    automata.core.embedding.embedding_types.OpenAIEmbedding\n    \n        `OpenAIEmbedding` is a class for obtaining embeddings for symbols using the OpenAI API. It inherits from the `EmbeddingProvider` abstract class and allows the construction of embeddings for source code via API calls to OpenAI. By default, it uses the \"text-embedding-ada-002\" engine, but users can specify a different engine if desired. The primary limitation of this class is its reliance on external API calls, requiring an internet connection and a valid API key. Consequently, speed and availability depend on the performance and restrictions imposed by OpenAI. Here's an example of its usage:\n        \n        ```python\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        \n        # Initialize OpenAIEmbedding instance\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create an example source code\n        symbol_source = \"def greet(name):\\n    return f\\\"Hello {name}!\\\"\"\n        \n        # Get the embedding for the symbol\n        embedding_array = embedding_provider.build_embedding(symbol_source)\n        \n        print(embedding_array.shape)\n        ```\n        \n      Class Docstring:\n        A class to provide embeddings for symbols\n        \n      Methods:\n        def __init__(self, engine: str = \"text-embedding-ada-002\"):\n                if not openai.api_key:\n                    from config import OPENAI_API_KEY\n        \n                    openai.api_key = OPENAI_API_KEY\n                self.engine = engine\n        \n            \n        build_embedding(self, symbol_source: str) -> np.ndarray\n        \n    automata.core.database.provider.SymbolDatabaseProvider\n    \n        The SymbolDatabaseProvider is an abstract base class designed for handling symbol embedding storage and retrieval in databases. It offers a generic interface for managing database operations related to symbol embeddings, allowing customization and flexibility in storage methods. Subclasses can implement various storage mechanisms optimized for specific needs, while users interact with the database consistently. Since SymbolDatabaseProvider is an abstract base class, users need to subclass it and implement its abstract methods to provide their database implementation using specific storage mechanisms. This customization may require a deeper understanding of the underlying storage methods. An example implementation using a JSON file for storage can be found in the original documentation.\n        \n      Class Docstring:\n        Abstract base class for different types of database providers.\n        \n      Methods:\n        add(self, embedding: SymbolEmbedding) -> None\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> Any\n        \n        load(self) -> Any\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.core.symbol.symbol_types.SymbolDocEmbedding\n    \n        `SymbolDocEmbedding` is a class representing the embedding for symbol documents, extending the `SymbolEmbedding` class with added metadata such as source code, summary, and context. This class is utilized alongside `SymbolDocEmbeddingHandler` to manage and access these embeddings for tasks like search and similarity comparison. However, it relies on external handler classes and assumes embeddings are provided as NumPy arrays, potentially limiting usage for other embedding types.\n        \n        ```python\n        import numpy as np\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.symbol.symbol_types import SymbolDocEmbedding\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        symbol = Symbol.from_string(symbol_str)\n        \n        document = \"This is a sample document\"\n        vector = np.array([0.1, 0.2, 0.3])\n        source_code = \"class ActionIndicator(Enum): ...\"\n        summary = \"This class represents an enum for action indicators.\"\n        context = \"The ActionIndicator enum is used to describe the current state...\"\n        \n        embedding = SymbolDocEmbedding(symbol, document, vector, source_code=source_code, summary=summary, context=context)\n        ```\n        \n      Class Docstring:\n        Embedding for symbol documents\n        \n      Methods:\n        def __init__(\n                self,\n                symbol: Symbol,\n                document: str,\n                vector: np.array,\n                source_code: Optional[str] = None,\n                summary: Optional[str] = None,\n                context: Optional[str] = None,\n            ):\n                super().__init__(symbol, document, vector)\n                # begin additional meta data\n                self.source_code = source_code\n                self.summary = summary\n                self.context = context\n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.embedding.embedding_types`/EmbeddingSimilarity#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.embedding.embedding_types", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "EmbeddingSimilarity", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# EmbeddingSimilarity\n\n`EmbeddingSimilarity` is an abstract base class that provides an interface for finding the most similar symbols to a given query text in a codebase. It relies on embeddings, which are numerical representations of text data. Given a query, EmbeddingSimilarity computes the similarity between this query and the existing symbols in the codebase and returns the results. The primary methods in this class are `get_nearest_entries_for_query` and `get_query_similarity_dict`. Implementations of this class provide the functionality for different types of similarity calculations \n\n## Related Symbols\n\n- `automata.core.embedding.symbol_similarity.SymbolSimilarity`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n- `automata.core.symbol.symbol_types.SymbolEmbedding`\n- `automata.core.database.vector.JSONVectorDatabase`\n- `automata.core.database.vector.VectorDatabaseProvider.calculate_similarity`\n- `automata.core.embedding.embedding_types.EmbeddingProvider`\n\n## Example\n\nBelow is an example demonstrating how to create a custom implementation of `EmbeddingSimilarity`:\n\n```python\nimport numpy as np\nfrom automata.core.embedding.embedding_types import EmbeddingSimilarity\n\nclass CustomEmbeddingSimilarity(EmbeddingSimilarity):\n\n    def __init__(self, embedding_handler):\n        self.embedding_handler = embedding_handler\n\n    def get_nearest_entries_for_query(self, query_text: str, k_nearest: int) -> Dict[Symbol, float]:\n        # Implement custom logic to find k nearest entries\n        pass\n\n    def get_query_similarity_dict(self, query_text: str) -> Dict[Symbol, float]:\n        # Implement custom logic to compute similarity between query and symbols\n        pass\n\n# Create an instance\nembedding_handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\ncustom_similarity = CustomEmbeddingSimilarity(embedding_handler)\n```\n\n## Limitations\n\nThe `EmbeddingSimilarity` class itself serves as an interface for the specific implementations, which allows for different approaches to calculate similarity. The primary issue here is that those implementations can handle different types of embeddings and similarity calculations, so choosing or creating the correct one is crucial for achieving accurate results. Also, depending on the chosen embedding provider, the quality and speed of retrieving embeddings could vary. As it is an abstract class, it cannot be instantiated directly and requires implementation of its methods.\n\n## Follow-up Questions:\n\n- How can we optimize the performance of similarity calculations for large codebases?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class EmbeddingSimilarity(abc.ABC):\n    @abc.abstractmethod\n    def get_query_similarity_dict(self, query_text: str) -> Dict[Any, float]:\n        \"\"\"An abstract method to get the similarity between a query and all symbols\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get_nearest_entries_for_query(self, query_text: str, k_nearest: int) -> Dict[Any, float]:\n        \"\"\"An abstract method to get the k nearest symbols to a query\"\"\"\n        pass\n", "summary": "`EmbeddingSimilarity` is an abstract base class for finding the most similar symbols to a given query text in a codebase using embeddings, which are numerical representations of text data. The class contains primary methods `get_nearest_entries_for_query` and `get_query_similarity_dict` that need to be implemented in a custom subclass to provide functionality for different types of similarity calculations. When working with large codebases, it is crucial to choose or create the correct implementation for accurate results. The quality and speed of retrieving embeddings may vary depending on the selected embedding provider.\n\nExample:\n\n```python\nimport numpy as np\nfrom automata.core.embedding.embedding_types import EmbeddingSimilarity\n\nclass CustomEmbeddingSimilarity(EmbeddingSimilarity):\n\n    def __init__(self, embedding_handler):\n        self.embedding_handler = embedding_handler\n\n    def get_nearest_entries_for_query(self, query_text: str, k_nearest: int) -> Dict[Symbol, float]:\n        # Implement custom logic to find k nearest entries\n        pass\n\n    def get_query_similarity_dict(self, query_text: str) -> Dict[Symbol, float]:\n        # Implement custom logic to compute similarity between query and symbols\n        pass\n\n# Create an instance\nembedding_handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\ncustom_similarity = CustomEmbeddingSimilarity(embedding_handler)\n```", "context": "\n    Generate the documentation for EmbeddingSimilarity using the context shown below -\n  Building context for primary symbol - automata.core.embedding.embedding_types.EmbeddingSimilarity -\n  \n    Import Statements:\n      import abc\n      import logging\n      import numpy as np\n      import openai\n      from enum import Enum\n      from typing import Any, Dict\n      from automata.core.database.vector import VectorDatabaseProvider\n      from automata.core.symbol.symbol_types import Symbol\n      from config import OPENAI_API_KEY\n      from openai.embeddings_utils import get_embedding\n      \n      # EmbeddingSimilarity\n      \n      `EmbeddingSimilarity` is an abstract base class that provides an interface for finding the most similar symbols to a given query text in a codebase. It relies on embeddings, which are numerical representations of text data. Given a query, EmbeddingSimilarity computes the similarity between this query and the existing symbols in the codebase and returns the results. The primary methods in this class are `get_nearest_entries_for_query` and `get_query_similarity_dict`. Implementations of this class provide the functionality for different types of similarity calculations and embedding providers.\n      \n      ## Related Symbols\n      \n      - `automata.core.embedding.symbol_similarity.SymbolSimilarity`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n      - `automata.core.symbol.symbol_types.SymbolEmbedding`\n      - `automata.core.database.vector.JSONVectorDatabase`\n      - `automata.core.database.vector.VectorDatabaseProvider.calculate_similarity`\n      - `automata.core.embedding.embedding_types.EmbeddingProvider`\n      \n      ## Example\n      \n      Below is an example demonstrating how to create a custom implementation of `EmbeddingSimilarity`:\n      \n      ```python\n      import numpy as np\n      from automata.core.embedding.embedding_types import EmbeddingSimilarity\n      \n      class CustomEmbeddingSimilarity(EmbeddingSimilarity):\n          \n          def __init__(self, embedding_handler):\n              self.embedding_handler = embedding_handler\n          \n          def get_nearest_entries_for_query(self, query_text: str, k_nearest: int) -> Dict[Symbol, float]:\n              # Implement custom logic to find k nearest entries\n              pass\n              \n          def get_query_similarity_dict(self, query_text: str) -> Dict[Symbol, float]:\n              # Implement custom logic to compute similarity between query and symbols\n              pass\n      \n      # Create an instance\n      embedding_handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n      custom_similarity = CustomEmbeddingSimilarity(embedding_handler)\n      ```\n      \n      ## Limitations\n      \n      The `EmbeddingSimilarity` class itself serves as an interface for the specific implementations, which allows for different approaches to calculate similarity. The primary issue here is that those implementations can handle different types of embeddings and similarity calculations, so choosing or creating the correct one is crucial for achieving accurate results. Also, depending on the chosen embedding provider, the quality and speed of retrieving embeddings could vary. As it is an abstract class, it cannot be instantiated directly and requires implementation of its methods.\n      \n      ## Follow-up Questions:\n      \n      - How can we optimize the performance of similarity calculations for large codebases?\n      \n    Methods:\n      @abc.abstractmethod\n          def get_nearest_entries_for_query(self, query_text: str, k_nearest: int) -> Dict[Any, float]:\n              \"\"\"An abstract method to get the k nearest symbols to a query\"\"\"\n              pass\n      \n      @abc.abstractmethod\n          def get_query_similarity_dict(self, query_text: str) -> Dict[Any, float]:\n              \"\"\"An abstract method to get the similarity between a query and all symbols\"\"\"\n              pass\n      \n          \n  Building context for related symbols -\n  \n    automata.core.embedding.symbol_similarity.SymbolSimilarity\n    \n        `SymbolSimilarity` is a class that computes similarity scores between query texts and symbols using embeddings, and allows users to retrieve the most similar symbols for a specific query and create a dictionary mapping the similarity scores to each symbol. Users can set the available symbols for the calculation, and the similarity scores depend on the quality of the supplied pre-trained embeddings and selected norm type. The class uses a `SymbolCodeEmbeddingHandler` for handling embeddings, which affects the accuracy of the results.\n        \n        Example usage of `SymbolSimilarity`:\n        ```python\n        import numpy as np\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        from automata.core.embedding.embedding_types import EmbeddingProvider, NormType\n        from automata.core.embedding.symbol_similarity import SymbolSimilarity\n        \n        embedding_handler = SymbolCodeEmbeddingHandler(embedding_db=embedding_db, embedding_provider=embedding_provider)\n        symbol_similarity = SymbolSimilarity(symbol_embedding_manager=embedding_handler, norm_type=NormType.L2)\n        symbol_similarity.set_available_symbols(available_symbols)\n        nearest_entries = symbol_similarity.get_nearest_entries_for_query(\"example query\", k=5)\n        query_similarity_dict = symbol_similarity.get_query_similarity_dict(\"example query\")\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                symbol_embedding_manager: SymbolCodeEmbeddingHandler,\n                norm_type: NormType = NormType.L2,\n            ):\n                \"\"\"\n                Initialize SymbolSimilarity\n        \n                Args:\n                    symbol_embedding_manager: A CodeEmbeddingManager\n                    norm_type (NormType): The norm type to use for calculating similarity\n        \n                Returns:\n                    An instance of SymbolSimilarity\n                \"\"\"\n                self.embedding_handler: SymbolCodeEmbeddingHandler = symbol_embedding_manager\n                self.embedding_provider: EmbeddingProvider = symbol_embedding_manager.embedding_provider\n                self.norm_type = norm_type\n                supported_symbols = self.embedding_handler.get_all_supported_symbols()\n                self.index_to_symbol = {i: symbol for i, symbol in enumerate(supported_symbols)}\n                self.symbol_to_index = {symbol: i for i, symbol in enumerate(supported_symbols)}\n                self.available_symbols: Optional[Set[Symbol]] = None\n        \n            \n        get_available_symbols(self) -> List[Symbol]\n        \n        get_nearest_entries_for_query(self, query_text: str, k: int = 10) -> Dict[Symbol, float]\n        \n        get_query_similarity_dict(self, query_text: str) -> Dict[Symbol, float]\n        \n        set_available_symbols(self, available_symbols: Set[Symbol]) -> None\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.core.symbol.symbol_types.SymbolEmbedding\n    \n        SymbolEmbedding is an abstract base class used to represent various symbol embeddings, such as SymbolCodeEmbedding and SymbolDocEmbedding. It provides a basic structure for initializing and managing these embeddings, taking into account their source and their vector representation in the feature space. SymbolEmbedding is utilized by different embedding handlers like SymbolCodeEmbeddingHandler and SymbolDocEmbeddingHandler. As a base class, its functionality is limited and should be extended by classes with specific embedding types. An example of creating a SymbolCodeEmbedding instance is shown below:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def __init__(self, message): pass\"\n        vector = np.array([0.1, 0.2, 0.3])\n        \n        symbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Abstract base class for different types of embeddings\n        \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.core.database.vector.VectorDatabaseProvider.calculate_similarity\n    \n      Class Docstring:\n        Abstract method to calculate the similarity between the given vector and vectors in the database.\n        \n      Methods:\n        calculate_similarity(self, embedding: SymbolEmbedding) -> List[Dict[Symbol, float]]\n        \n    automata.core.embedding.embedding_types.EmbeddingProvider\n    \n        `EmbeddingProvider` is an abstract base class that serves as an interface for obtaining mathematical representations called embeddings for symbols, used in tasks such as similarity search, ranking, and other natural language processing-related work. Its single abstract method, `build_embedding`, should be implemented by all subclasses to provide specific embedding implementations. Users must create their own classes that inherit from `EmbeddingProvider` and implement these methods, which might be a limitation for those unfamiliar with custom classes and abstract methods.\n        \n        Here is an example of using the `OpenAIEmbedding` class, a concrete implementation of `EmbeddingProvider`:\n        \n        ```python\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        import numpy as np\n        \n        symbol_source = \"This is an example of a Python function.\"\n        embedding_provider = OpenAIEmbedding() \n        embedding = embedding_provider.build_embedding(symbol_source)\n        \n        # Check if the generated embedding is a numpy array\n        assert isinstance(embedding, np.ndarray)\n        ```\n        Performance and accuracy of embeddings depend on the specific model and approach used in the concrete implementation of `EmbeddingProvider`.\n        \n      Class Docstring:\n        A class to provide embeddings for symbols\n        \n      Methods:\n        build_embedding(self, symbol_source: str) -> np.ndarray\n        \n    automata.tests.unit.conftest.patch_get_embedding\n    \n        def patch_get_embedding(monkeypatch, mock_embedding):\n            # Define the behavior of the mock build_embedding function\n            mock_get_embedding = Mock(return_value=mock_embedding)\n            monkeypatch.setattr(\"openai.embeddings_utils.get_embedding\", mock_get_embedding)\n        \n        \n        \n        \n    automata.tests.unit.test_symbol_similarity.test_get_nearest_symbols_for_query\n    \n        def test_get_nearest_symbols_for_query(\n            monkeypatch, mock_embedding, mock_simple_method_symbols, temp_output_filename\n        ):\n            # Mocking symbols and their embeddings\n            symbol1 = mock_simple_method_symbols[0]\n            symbol2 = mock_simple_method_symbols[1]\n            symbol3 = mock_simple_method_symbols[2]\n        \n            embedding1 = SymbolCodeEmbedding(\n                symbol=symbol1, vector=np.array([1, 0, 0, 0]), source_code=\"symbol1\"\n            )\n            embedding2 = SymbolCodeEmbedding(\n                symbol=symbol2, vector=np.array([0, 1, 0, 0]), source_code=\"symbol2\"\n            )\n            embedding3 = SymbolCodeEmbedding(\n                symbol=symbol3, vector=np.array([0, 0, 1, 0]), source_code=\"symbol3\"\n            )\n        \n            # Mock JSONVectorDatabase methods\n            embedding_db = JSONVectorDatabase(temp_output_filename)\n            embedding_db.add(embedding1)\n            embedding_db.add(embedding2)\n            embedding_db.add(embedding3)\n        \n            # Create an instance of the class\n            mock_provider = MagicMock(EmbeddingProvider)\n            cem = SymbolCodeEmbeddingHandler(embedding_db=embedding_db, embedding_provider=mock_provider)\n        \n            symbol_similarity = SymbolSimilarity(cem)\n        \n            # Test with query_text that is most similar to symbol1\n            cem.embedding_provider.build_embedding.return_value = np.array([1, 0, 0, 0])\n            result = symbol_similarity.get_nearest_entries_for_query(\"symbol1\", k=1)\n            assert list(result.keys()) == [symbol1]\n        \n            # Test with query_text that is most similar to symbol2\n            cem.embedding_provider.build_embedding.return_value = np.array([0, 1, 0, 0])\n            result = symbol_similarity.get_nearest_entries_for_query(\"symbol2\", k=1)\n            assert list(result.keys()) == [symbol2]\n        \n            # Test with query_text that is most similar to symbol3\n            cem.embedding_provider.build_embedding.return_value = np.array([0, 0, 1, 0])\n            result = symbol_similarity.get_nearest_entries_for_query(\"symbol3\", k=1)\n            assert list(result.keys()) == [symbol3]\n        \n        \n    automata.core.symbol.symbol_types.SymbolCodeEmbedding\n    \n        `SymbolCodeEmbedding` is a class extending the `SymbolEmbedding` base class, used to store code embeddings for a given symbol, the symbol object, source code, and the embedding vector. It primarily serves as a container for these embeddings and does not include functionality for generating or handling them; `SymbolCodeEmbeddingHandler` should be used for those purposes.\n        \n        Here's an example of creating a `SymbolCodeEmbedding` instance:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def example_function():\\n    pass\"\n        vector = np.random.random((300,))\n        \n        embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Embedding for symbol code\n        \n      Methods:\n        def __init__(self, symbol: Symbol, source_code: str, vector: np.array):\n                super().__init__(symbol, source_code, vector)\n        \n        \n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.embedding.embedding_types`/NormType#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.embedding.embedding_types", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "NormType", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# NormType\n\n`NormType` is an enumeration class representing the different normalization techniques available for use while calculating similarity in a `SymbolSimilarity` object. It offers three options, L1, L2, and softmax for normalization, which can be utilized by the `SymbolSimilarity` class while computing similarities between symbols in a related codebase.\n\n## Related Symbols\n\n- `automata.core.embedding.symbol_similarity.SymbolSimilarity`\n- `automata.core.symbol.symbol_types.Symbol`\n\n## Example\n\nThe following example demonstrates how to create a `SymbolSimilarity` instance using a custom `NormType`.\n\n```python\nfrom automata.core.embedding.symbol_similarity import SymbolSimilarity\nfrom automata.core.embedding.embedding_types import NormType\nfrom automata.core.embedding.manager.code_embedding_manager import SymbolCodeEmbeddingHandler\n\nsymbol_embedding_manager = SymbolCodeEmbeddingHandler()\ncustom_norm_type = NormType.L1\n\nsymbol_similarity = SymbolSimilarity(symbol_embedding_manager, custom_norm_type)\n```\n\n## Limitations\n\nOne potential limitation of using different normalization techniques within `SymbolSimilarity` is the possibility of differences in the interpretation of similarity results. While some techniques like L2 (Euclidean) are more commonly used and understood, others like L1 or softmax might be less familiar. Additionally, the choice of normalization technique can impact the efficiency of the similarity calculation algorithm.\n\n## Follow-up Questions:\n\n- Are there other normalization techniques that could be added to the `NormType` class?\n- How do different normalization techniques impact the performance and interpretation of similarity calculations?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class NormType(Enum):\n    L1 = \"l1\"\n    L2 = \"l2\"\n    SOFTMAX = \"softmax\"\n\n\n", "summary": "`NormType` is an enumeration class representing different normalization techniques (L1, L2, and softmax) available for calculating similarity in a `SymbolSimilarity` object. Users can create a `SymbolSimilarity` instance with a custom `NormType` as shown in the example below:\n\n```python\nfrom automata.core.embedding.symbol_similarity import SymbolSimilarity\nfrom automata.core.embedding.embedding_types import NormType\nfrom automata.core.embedding.manager.code_embedding_manager import SymbolCodeEmbeddingHandler\n\nsymbol_embedding_manager = SymbolCodeEmbeddingHandler()\ncustom_norm_type = NormType.L1\n\nsymbol_similarity = SymbolSimilarity(symbol_embedding_manager, custom_norm_type)\n```\n\nHowever, using different normalization techniques may lead to differences in the interpretation of similarity results and impact the efficiency of the algorithm.", "context": "\n    Generate the documentation for NormType using the context shown below -\n  Building context for primary symbol - automata.core.embedding.embedding_types.NormType -\n  \n    Import Statements:\n      import abc\n      import logging\n      import numpy as np\n      import openai\n      from enum import Enum\n      from typing import Any, Dict\n      from automata.core.database.vector import VectorDatabaseProvider\n      from automata.core.symbol.symbol_types import Symbol\n      from config import OPENAI_API_KEY\n      from openai.embeddings_utils import get_embedding\n      \n      # NormType\n      \n      `NormType` is an enumeration class representing the different normalization techniques available for use while calculating similarity in a `SymbolSimilarity` object. It offers three options, L1, L2, and softmax for normalization, which can be utilized by the `SymbolSimilarity` class while computing similarities between symbols in a related codebase.\n      \n      ## Related Symbols\n      \n      - `automata.core.embedding.symbol_similarity.SymbolSimilarity`\n      - `automata.core.symbol.symbol_types.Symbol`\n      \n      ## Example\n      \n      The following example demonstrates how to create a `SymbolSimilarity` instance using a custom `NormType`.\n      \n      ```python\n      from automata.core.embedding.symbol_similarity import SymbolSimilarity\n      from automata.core.embedding.embedding_types import NormType\n      from automata.core.embedding.manager.code_embedding_manager import SymbolCodeEmbeddingHandler\n      \n      symbol_embedding_manager = SymbolCodeEmbeddingHandler()\n      custom_norm_type = NormType.L1\n      \n      symbol_similarity = SymbolSimilarity(symbol_embedding_manager, custom_norm_type)\n      ```\n      \n      ## Limitations\n      \n      One potential limitation of using different normalization techniques within `SymbolSimilarity` is the possibility of differences in the interpretation of similarity results. While some techniques like L2 (Euclidean) are more commonly used and understood, others like L1 or softmax might be less familiar. Additionally, the choice of normalization technique can impact the efficiency of the similarity calculation algorithm.\n      \n      ## Follow-up Questions:\n      \n      - Are there other normalization techniques that could be added to the `NormType` class?\n      - How do different normalization techniques impact the performance and interpretation of similarity calculations?\n      \n  Building context for related symbols -\n  \n    automata.core.embedding.symbol_similarity.SymbolSimilarity\n    \n        `SymbolSimilarity` is a class that computes similarity scores between query texts and symbols using embeddings, and allows users to retrieve the most similar symbols for a specific query and create a dictionary mapping the similarity scores to each symbol. Users can set the available symbols for the calculation, and the similarity scores depend on the quality of the supplied pre-trained embeddings and selected norm type. The class uses a `SymbolCodeEmbeddingHandler` for handling embeddings, which affects the accuracy of the results.\n        \n        Example usage of `SymbolSimilarity`:\n        ```python\n        import numpy as np\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        from automata.core.embedding.embedding_types import EmbeddingProvider, NormType\n        from automata.core.embedding.symbol_similarity import SymbolSimilarity\n        \n        embedding_handler = SymbolCodeEmbeddingHandler(embedding_db=embedding_db, embedding_provider=embedding_provider)\n        symbol_similarity = SymbolSimilarity(symbol_embedding_manager=embedding_handler, norm_type=NormType.L2)\n        symbol_similarity.set_available_symbols(available_symbols)\n        nearest_entries = symbol_similarity.get_nearest_entries_for_query(\"example query\", k=5)\n        query_similarity_dict = symbol_similarity.get_query_similarity_dict(\"example query\")\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                symbol_embedding_manager: SymbolCodeEmbeddingHandler,\n                norm_type: NormType = NormType.L2,\n            ):\n                \"\"\"\n                Initialize SymbolSimilarity\n        \n                Args:\n                    symbol_embedding_manager: A CodeEmbeddingManager\n                    norm_type (NormType): The norm type to use for calculating similarity\n        \n                Returns:\n                    An instance of SymbolSimilarity\n                \"\"\"\n                self.embedding_handler: SymbolCodeEmbeddingHandler = symbol_embedding_manager\n                self.embedding_provider: EmbeddingProvider = symbol_embedding_manager.embedding_provider\n                self.norm_type = norm_type\n                supported_symbols = self.embedding_handler.get_all_supported_symbols()\n                self.index_to_symbol = {i: symbol for i, symbol in enumerate(supported_symbols)}\n                self.symbol_to_index = {symbol: i for i, symbol in enumerate(supported_symbols)}\n                self.available_symbols: Optional[Set[Symbol]] = None\n        \n            \n        get_available_symbols(self) -> List[Symbol]\n        \n        get_nearest_entries_for_query(self, query_text: str, k: int = 10) -> Dict[Symbol, float]\n        \n        get_query_similarity_dict(self, query_text: str) -> Dict[Symbol, float]\n        \n        set_available_symbols(self, available_symbols: Set[Symbol]) -> None\n        \n    automata.core.embedding.symbol_similarity.SymbolSimilarity._normalize_embeddings\n    \n      Class Docstring:\n        Normalize the embeddings.\n        Args:\n        embeddings (np.ndarray): The embeddings\n        norm_type (NormType): The type of normalization (L1, L2, or softmax)\n        Returns:\n        The normalized embeddings\n        \n      Methods:\n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl\n    \n        class ObNMl:\n            \"\"\"zFsdXovhQSBlqDNpXSvl\"\"\"\n        \n            def __init__(self):\n                pass\n        \n            def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample.EmptyClass\n    \n        class EmptyClass:\n            pass\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.SymbolDescriptor.PyKind\n    \n        `SymbolDescriptor` is a Python object representing the descriptor component of a URI within the `automata.core.symbol` framework. It serves as a building block for creating and parsing symbols and provides methods to work with descriptor components. For example, to create a `SymbolDescriptor` instance:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolDescriptor\n        from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n        \n        descriptor = SymbolDescriptor(\n            name=\"ActionIndicator\",\n            suffix=DescriptorProto.TYPE,\n        )\n        ```\n        \n        It is closely tied to the `automata.core.symbol` framework and may require updates if the underlying descriptor format or parser implementation changes.\n        \n    automata.core.embedding.symbol_similarity.SymbolSimilarity.__init__\n    \n      Class Docstring:\n        Initialize SymbolSimilarity\n        \n        Args:\n        symbol_embedding_manager: A CodeEmbeddingManager\n        norm_type (NormType): The norm type to use for calculating similarity\n        \n        Returns:\n        An instance of SymbolSimilarity\n        \n      Methods:\n        def __init__(\n                self,\n                symbol_embedding_manager: SymbolCodeEmbeddingHandler,\n                norm_type: NormType = NormType.L2,\n            ):\n                \"\"\"\n                Initialize SymbolSimilarity\n        \n                Args:\n                    symbol_embedding_manager: A CodeEmbeddingManager\n                    norm_type (NormType): The norm type to use for calculating similarity\n        \n                Returns:\n                    An instance of SymbolSimilarity\n                \"\"\"\n                self.embedding_handler: SymbolCodeEmbeddingHandler = symbol_embedding_manager\n                self.embedding_provider: EmbeddingProvider = symbol_embedding_manager.embedding_provider\n                self.norm_type = norm_type\n                supported_symbols = self.embedding_handler.get_all_supported_symbols()\n                self.index_to_symbol = {i: symbol for i, symbol in enumerate(supported_symbols)}\n                self.symbol_to_index = {symbol: i for i, symbol in enumerate(supported_symbols)}\n                self.available_symbols: Optional[Set[Symbol]] = None\n        \n            \n    automata.tests.unit.sample_modules.sample.OuterClass\n    \n        class OuterClass:\n            class InnerClass:\n                \"\"\"Inner doc strings\"\"\"\n        \n                def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl.method\n    \n        def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl.__init__\n    \n        def __init__(self):\n                pass\n        \n            \n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.embedding.embedding_types`/OpenAIEmbedding#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.embedding.embedding_types", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "OpenAIEmbedding", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# OpenAIEmbedding\n\n`OpenAIEmbedding` is a class that provides embeddings for symbols using OpenAI API. It allows you to build and return embeddings for a given source code by making API calls to OpenAI service. Inherits from the `EmbeddingProvider` abstract class.\n\n## Overview\n\n`OpenAIEmbedding` takes an optional engine parameter to define the text embedding model to be used from OpenAI API. By default, it uses the \"text-embedding-ada-002\" engine. The main method of this class is `build_embedding`, which receives a symbol source code as input and returns the corresponding numpy array representing the embedding.\n\n## Import Statements\n\n```python\nimport numpy as np\nimport openai\nfrom config import OPENAI_API_KEY\nfrom openai.embeddings_utils import get_embedding\n```\n\n## Related Symbols\n\n- `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n- `automata.core.embedding.embedding_types.EmbeddingProvider`\n- `automata.core.symbol.symbol_types.SymbolEmbedding`\n- `config.OPENAI_API_KEY`\n\n## Example\n\nHere's an example of how to initialize and use `OpenAIEmbedding` to build embeddings for a symbol source.\n\n```python\nfrom automata.core.embedding.embedding_types import OpenAIEmbedding\n\n# Initialize OpenAIEmbedding instance\nembedding_provider = OpenAIEmbedding()\n\n# Create an example source code\nsymbol_source = \"def greet(name):\\n    return f\\\"Hello {name}!\\\"\"\n\n# Get the embedding for the symbol\nembedding_array = embedding_provider.build_embedding(symbol_source)\n\nprint(embedding_array.shape)\n```\n\n## Limitations\n\nThe primary limitation of `OpenAIEmbedding` is that it relies on external API calls to the OpenAI service, requiring an internet connection and a valid API key to work. As a result, the speed and availability of building embeddings depend on the OpenAI service's performance and any restrictions imposed by OpenAI, such as rate limits.\n\n## Follow-up Questions:\n\n- How can the user choose different OpenAI text embedding models?\n- Are there any specific feature differences across various OpenAI text embedding models?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class OpenAIEmbedding(EmbeddingProvider):\n    \"\"\"A class to provide embeddings for symbols\"\"\"\n\n    def __init__(self, engine: str = \"text-embedding-ada-002\"):\n        if not openai.api_key:\n            from config import OPENAI_API_KEY\n\n            openai.api_key = OPENAI_API_KEY\n        self.engine = engine\n\n    def build_embedding(self, symbol_source: str) -> np.ndarray:\n        \"\"\"\n        Get the embedding for a symbol.\n        Args:\n            symbol_source (str): The source code of the symbol\n        Returns:\n            A numpy array representing the embedding\n        \"\"\"\n        # wait to import build_embedding to allow easy mocking of the function in tests.\n        from openai.embeddings_utils import get_embedding\n\n        return np.array(get_embedding(symbol_source, engine=self.engine))\n\n\n", "summary": "`OpenAIEmbedding` is a class that provides embeddings for symbols using OpenAI API, inheriting from the `EmbeddingProvider` abstract class. By default, the class uses the \"text-embedding-ada-002\" engine, but users can specify other engines if desired. The main method, `build_embedding`, takes source code as input and returns a numpy array representing the corresponding embedding. To use `OpenAIEmbedding`, an internet connection and a valid API key are required, as the class relies on external API calls to the OpenAI service. Consequently, the speed and availability of building embeddings depend on the OpenAI service's performance and any restrictions imposed, such as rate limits.\n\nExample usage:\n```python\nfrom automata.core.embedding.embedding_types import OpenAIEmbedding\n\n# Initialize OpenAIEmbedding instance\nembedding_provider = OpenAIEmbedding()\n\n# Create an example source code\nsymbol_source = \"def greet(name):\\n    return f\\\"Hello {name}!\\\"\"\n\n# Get the embedding for the symbol\nembedding_array = embedding_provider.build_embedding(symbol_source)\n\nprint(embedding_array.shape)\n```\n", "context": "\n    Generate the documentation for OpenAIEmbedding using the context shown below -\n  Building context for primary symbol - automata.core.embedding.embedding_types.OpenAIEmbedding -\n  \n    Import Statements:\n      import abc\n      import logging\n      import numpy as np\n      import openai\n      from enum import Enum\n      from typing import Any, Dict\n      from automata.core.database.vector import VectorDatabaseProvider\n      from automata.core.symbol.symbol_types import Symbol\n      from config import OPENAI_API_KEY\n      from openai.embeddings_utils import get_embedding\n      \n      # OpenAIEmbedding\n      \n      `OpenAIEmbedding` is a class that provides embeddings for symbols using OpenAI API. It allows you to build and return embeddings for a given source code by making API calls to OpenAI service. Inherits from the `EmbeddingProvider` abstract class.\n      \n      ## Overview\n      \n      `OpenAIEmbedding` takes an optional engine parameter to define the text embedding model to be used from OpenAI API. By default, it uses the \"text-embedding-ada-002\" engine. The main method of this class is `build_embedding`, which receives a symbol source code as input and returns the corresponding numpy array representing the embedding.\n      \n      ## Import Statements\n      \n      ```python\n      import numpy as np\n      import openai\n      from automata.core.embedding.embedding_types import EmbeddingProvider\n      from config import OPENAI_API_KEY\n      from openai.embeddings_utils import get_embedding\n      ```\n      \n      ## Related Symbols\n      \n      - `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n      - `automata.core.embedding.embedding_types.EmbeddingProvider`\n      - `automata.core.symbol.symbol_types.SymbolEmbedding`\n      - `config.OPENAI_API_KEY`\n      \n      ## Example\n      \n      Here's an example of how to initialize and use `OpenAIEmbedding` to build embeddings for a symbol source.\n      \n      ```python\n      from automata.core.embedding.embedding_types import OpenAIEmbedding\n      \n      # Initialize OpenAIEmbedding instance\n      embedding_provider = OpenAIEmbedding()\n      \n      # Create an example source code\n      symbol_source = \"def greet(name):\\n    return f\\\"Hello {name}!\\\"\"\n      \n      # Get the embedding for the symbol\n      embedding_array = embedding_provider.build_embedding(symbol_source)\n      \n      print(embedding_array.shape)\n      ```\n      \n      ## Limitations\n      \n      The primary limitation of `OpenAIEmbedding` is that it relies on external API calls to the OpenAI service, requiring an internet connection and a valid API key to work. As a result, the speed and availability of building embeddings depend on the OpenAI service's performance and any restrictions imposed by OpenAI, such as rate limits.\n      \n      ## Follow-up Questions:\n      \n      - How can the user choose different OpenAI text embedding models?\n      - Are there any specific feature differences across various OpenAI text embedding models?\n      \n    Class Docstring:\n      A class to provide embeddings for symbols\n      \n    Methods:\n      def __init__(self, engine: str = \"text-embedding-ada-002\"):\n              if not openai.api_key:\n                  from config import OPENAI_API_KEY\n      \n                  openai.api_key = OPENAI_API_KEY\n              self.engine = engine\n      \n          \n      def build_embedding(self, symbol_source: str) -> np.ndarray:\n              \"\"\"\n              Get the embedding for a symbol.\n              Args:\n                  symbol_source (str): The source code of the symbol\n              Returns:\n                  A numpy array representing the embedding\n              \"\"\"\n              # wait to import build_embedding to allow easy mocking of the function in tests.\n              from openai.embeddings_utils import get_embedding\n      \n              return np.array(get_embedding(symbol_source, engine=self.engine))\n      \n      \n      \n  Building context for related symbols -\n  \n    automata.tests.unit.conftest.patch_get_embedding\n    \n        def patch_get_embedding(monkeypatch, mock_embedding):\n            # Define the behavior of the mock build_embedding function\n            mock_get_embedding = Mock(return_value=mock_embedding)\n            monkeypatch.setattr(\"openai.embeddings_utils.get_embedding\", mock_get_embedding)\n        \n        \n        \n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.core.symbol.symbol_types.SymbolEmbedding\n    \n        SymbolEmbedding is an abstract base class used to represent various symbol embeddings, such as SymbolCodeEmbedding and SymbolDocEmbedding. It provides a basic structure for initializing and managing these embeddings, taking into account their source and their vector representation in the feature space. SymbolEmbedding is utilized by different embedding handlers like SymbolCodeEmbeddingHandler and SymbolDocEmbeddingHandler. As a base class, its functionality is limited and should be extended by classes with specific embedding types. An example of creating a SymbolCodeEmbedding instance is shown below:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def __init__(self, message): pass\"\n        vector = np.array([0.1, 0.2, 0.3])\n        \n        symbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Abstract base class for different types of embeddings\n        \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n    automata.core.embedding.embedding_types.EmbeddingProvider\n    \n        `EmbeddingProvider` is an abstract base class that serves as an interface for obtaining mathematical representations called embeddings for symbols, used in tasks such as similarity search, ranking, and other natural language processing-related work. Its single abstract method, `build_embedding`, should be implemented by all subclasses to provide specific embedding implementations. Users must create their own classes that inherit from `EmbeddingProvider` and implement these methods, which might be a limitation for those unfamiliar with custom classes and abstract methods.\n        \n        Here is an example of using the `OpenAIEmbedding` class, a concrete implementation of `EmbeddingProvider`:\n        \n        ```python\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        import numpy as np\n        \n        symbol_source = \"This is an example of a Python function.\"\n        embedding_provider = OpenAIEmbedding() \n        embedding = embedding_provider.build_embedding(symbol_source)\n        \n        # Check if the generated embedding is a numpy array\n        assert isinstance(embedding, np.ndarray)\n        ```\n        Performance and accuracy of embeddings depend on the specific model and approach used in the concrete implementation of `EmbeddingProvider`.\n        \n      Class Docstring:\n        A class to provide embeddings for symbols\n        \n      Methods:\n        build_embedding(self, symbol_source: str) -> np.ndarray\n        \n    automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler\n    \n        The `SymbolDocEmbeddingHandler` class is responsible for generating, storing, and managing document embeddings for symbols in an AutomataDocs project. It relies on the `VectorDatabaseProvider`, `EmbeddingProvider` classes, and uses methods like `build_symbol_doc_embedding`, `update_embedding`, `get_embedding`, `get_doc`, and `get_summary` for managing symbol document embeddings and their summaries. The class utilizes various other components like `SymbolGraph`, `SymbolSimilarity`, and `SymbolRankConfig` to search, rank, and generate context for symbol embeddings. However, it has limitations concerning the embedding models and algorithms used and can sometimes produce suboptimal context or examples. Improving the underlying components can potentially enhance the embedding quality.\n        \n        Example usage:\n        \n        ```python\n        from automata.core.embedding.doc_embedding import SymbolDocEmbeddingHandler\n        from automata.core.database.vector import JSONVectorDatabase, VectorDatabaseProvider\n        from automata.core.embedding.embedding_types import OpenAIEmbedding, EmbeddingProvider\n        from automata.core.symbol.symbol_types import Symbol\n        \n        # Initialize the database provider and embedding provider\n        db_provider = VectorDatabaseProvider(JSONVectorDatabase(\"path/to/symbol_doc_embedding.json\"))\n        embedding_provider = EmbeddingProvider(OpenAIEmbedding())\n        \n        # Create an instance of SymbolDocEmbeddingHandler\n        embedding_handler = SymbolDocEmbeddingHandler(db_provider, embedding_provider)\n        \n        # Example symbol and source code\n        symbol = Symbol.from_string(\"symbol-uri-as-string\")\n        source_code = \"def example_function():\\n    pass\"\n        \n        # Build the symbol document embedding\n        symbol_doc_embedding = embedding_handler.build_symbol_doc_embedding(source_code, symbol)\n        ```\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n                code_embedding_handler: SymbolCodeEmbeddingHandler,\n                embedding_db_l2: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                A constructor for SymbolDocEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (EmbeddingProvider): The provider to get the embeddings from\n                    code_embedding_handler (SymbolCodeEmbeddingHandler): The code embedding handler\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n                from automata.core.embedding.symbol_similarity import SymbolSimilarity\n                from automata.core.symbol.search.rank import SymbolRankConfig\n                from automata.core.symbol.search.symbol_search import SymbolSearch\n        \n                graph = SymbolGraph()\n                subgraph = graph.get_rankable_symbol_subgraph()\n                symbol_similarity = SymbolSimilarity(code_embedding_handler)\n                self.graph = graph\n                self.symbol_search = SymbolSearch(\n                    graph, symbol_similarity, symbol_rank_config=SymbolRankConfig(), code_subgraph=subgraph\n                )\n                self.embedding_db_l2 = embedding_db_l2\n        \n            \n        build_symbol_doc_embedding(self, source_code: str, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_doc(prompt: str) -> str\n        \n        get_embedding(self, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_summary(input_doc: str) -> str\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n    automata.core.symbol.symbol_types.SymbolCodeEmbedding\n    \n        `SymbolCodeEmbedding` is a class extending the `SymbolEmbedding` base class, used to store code embeddings for a given symbol, the symbol object, source code, and the embedding vector. It primarily serves as a container for these embeddings and does not include functionality for generating or handling them; `SymbolCodeEmbeddingHandler` should be used for those purposes.\n        \n        Here's an example of creating a `SymbolCodeEmbedding` instance:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def example_function():\\n    pass\"\n        vector = np.random.random((300,))\n        \n        embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Embedding for symbol code\n        \n      Methods:\n        def __init__(self, symbol: Symbol, source_code: str, vector: np.array):\n                super().__init__(symbol, source_code, vector)\n        \n        \n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.core.embedding.symbol_similarity.SymbolSimilarity\n    \n        `SymbolSimilarity` is a class that computes similarity scores between query texts and symbols using embeddings, and allows users to retrieve the most similar symbols for a specific query and create a dictionary mapping the similarity scores to each symbol. Users can set the available symbols for the calculation, and the similarity scores depend on the quality of the supplied pre-trained embeddings and selected norm type. The class uses a `SymbolCodeEmbeddingHandler` for handling embeddings, which affects the accuracy of the results.\n        \n        Example usage of `SymbolSimilarity`:\n        ```python\n        import numpy as np\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        from automata.core.embedding.embedding_types import EmbeddingProvider, NormType\n        from automata.core.embedding.symbol_similarity import SymbolSimilarity\n        \n        embedding_handler = SymbolCodeEmbeddingHandler(embedding_db=embedding_db, embedding_provider=embedding_provider)\n        symbol_similarity = SymbolSimilarity(symbol_embedding_manager=embedding_handler, norm_type=NormType.L2)\n        symbol_similarity.set_available_symbols(available_symbols)\n        nearest_entries = symbol_similarity.get_nearest_entries_for_query(\"example query\", k=5)\n        query_similarity_dict = symbol_similarity.get_query_similarity_dict(\"example query\")\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                symbol_embedding_manager: SymbolCodeEmbeddingHandler,\n                norm_type: NormType = NormType.L2,\n            ):\n                \"\"\"\n                Initialize SymbolSimilarity\n        \n                Args:\n                    symbol_embedding_manager: A CodeEmbeddingManager\n                    norm_type (NormType): The norm type to use for calculating similarity\n        \n                Returns:\n                    An instance of SymbolSimilarity\n                \"\"\"\n                self.embedding_handler: SymbolCodeEmbeddingHandler = symbol_embedding_manager\n                self.embedding_provider: EmbeddingProvider = symbol_embedding_manager.embedding_provider\n                self.norm_type = norm_type\n                supported_symbols = self.embedding_handler.get_all_supported_symbols()\n                self.index_to_symbol = {i: symbol for i, symbol in enumerate(supported_symbols)}\n                self.symbol_to_index = {symbol: i for i, symbol in enumerate(supported_symbols)}\n                self.available_symbols: Optional[Set[Symbol]] = None\n        \n            \n        get_available_symbols(self) -> List[Symbol]\n        \n        get_nearest_entries_for_query(self, query_text: str, k: int = 10) -> Dict[Symbol, float]\n        \n        get_query_similarity_dict(self, query_text: str) -> Dict[Symbol, float]\n        \n        set_available_symbols(self, available_symbols: Set[Symbol]) -> None\n        \n    automata.core.database.provider.SymbolDatabaseProvider.update\n    \n      Class Docstring:\n        Abstract method to update an existing embedding.\n        \n      Methods:\n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.embedding.embedding_types`/SymbolEmbeddingHandler#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.embedding.embedding_types", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolEmbeddingHandler", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolEmbeddingHandler\n\n`SymbolEmbeddingHandler` is an abstract class used to handle the embedding of symbols. It provides an interface for getting and updating the embeddings for symbols using different types of embeddings.\n\n## Overview\n\nThe `SymbolEmbeddingHandler` defines the basic structure and methods required for managing symbol embeddings. Its main purpose is to fetch and update the vector embeddings associated with different kinds of symbols. This class has to be extended by other classes to provide the implementation of the abstract methods defined in this class.\n\n## Related Symbols\n\n* `automata.core.embedding.embedding_types.EmbeddingProvider`\n* `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n* `automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler`\n* `automata.core.event.vector_storage.VectorDatabaseProvider`\n* `automata.core.symbol.symbol_types.Symbol`\n* `automata.core.symbol.symbol_types.SymbolEmbedding`\n\n## Example\n\nThe following example demonstrates how to subclass `SymbolEmbeddingHandler` and implement the abstract methods:\n\n```python\nfrom automata.core.embedding.embedding_types import SymbolEmbeddingHandler\nfrom automata.core.symbol.symbol_types import Symbol\n\nclass CustomSymbolEmbeddingHandler(SymbolEmbeddingHandler):\n    def __init__(self, embedding_db, embedding_provider):\n        super().__init__(embedding_db, embedding_provider)\n\n    def get_embedding(self, symbol: Symbol):\n        # Implement logic to get the embedding for a custom symbol\n        pass\n\n    def update_embedding(self, symbol: Symbol):\n        # Implement logic to update the embedding for a custom symbol\n        pass\n\n# Example usage:\ncustom_handler = CustomSymbolEmbeddingHandler(embedding_db, embedding_provider)\ncustom_embedding = custom_handler.get_embedding(custom_symbol)\n```\n\n## Limitations\n\nSince `SymbolEmbeddingHandler` is an abstract class, it cannot be instantiated directly. Instead, it must be subclassed and the abstract methods must be implemented in the derived class.\n\nThe implementation of the `get_embedding()` and `update_embedding()` methods in the derived class will depend on the context and the type of symbol embeddings used. The performance of these methods might vary based on the selected embedding provider and the database used for storing the embeddings.\n\n## Follow-up Questions:\n\n- How can we extend this class to handle other types of embeddings?\n- How can the performance of this class be improved for specific use cases?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class SymbolEmbeddingHandler(abc.ABC):\n    \"\"\"An abstract class to handle the embedding of symbols\"\"\"\n\n    def __init__(\n        self,\n        embedding_db: VectorDatabaseProvider,\n        embedding_provider: EmbeddingProvider,\n    ):\n        \"\"\"An abstract constructor for SymbolEmbeddingHandler\"\"\"\n        self.embedding_db = embedding_db\n        self.embedding_provider = embedding_provider\n\n    @abc.abstractmethod\n    def get_embedding(self, symbol: Symbol) -> Any:\n        \"\"\"An abstract method to get the embedding for a symbol\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def update_embedding(self, symbol: Symbol):\n        \"\"\"An abstract method to update the embedding for a symbol\"\"\"\n        pass\n\n\n", "summary": "`SymbolEmbeddingHandler` is an abstract class responsible for managing symbol embeddings, specifically fetching and updating vector embeddings for different kinds of symbols. To use this class, it must be subclassed, and the abstract methods `get_embedding()` and `update_embedding()` must be implemented in the derived class. The performance of these methods may vary based on the chosen embedding provider and the database that stores the embeddings. \n\nFor example, here is how to subclass `SymbolEmbeddingHandler` and implement the abstract methods:\n```python\nfrom automata.core.embedding.embedding_types import SymbolEmbeddingHandler\nfrom automata.core.symbol.symbol_types import Symbol\n\nclass CustomSymbolEmbeddingHandler(SymbolEmbeddingHandler):\n    def __init__(self, embedding_db, embedding_provider):\n        super().__init__(embedding_db, embedding_provider)\n\n    def get_embedding(self, symbol: Symbol):\n        # Implement logic to get the embedding for a custom symbol\n        pass\n\n    def update_embedding(self, symbol: Symbol):\n        # Implement logic to update the embedding for a custom symbol\n        pass\n\n# Example usage:\ncustom_handler = CustomSymbolEmbeddingHandler(embedding_db, embedding_provider)\ncustom_embedding = custom_handler.get_embedding(custom_symbol)\n```", "context": "\n    Generate the documentation for SymbolEmbeddingHandler using the context shown below -\n  Building context for primary symbol - automata.core.embedding.embedding_types.SymbolEmbeddingHandler -\n  \n    Import Statements:\n      import abc\n      import logging\n      import numpy as np\n      import openai\n      from enum import Enum\n      from typing import Any, Dict\n      from automata.core.database.vector import VectorDatabaseProvider\n      from automata.core.symbol.symbol_types import Symbol\n      from config import OPENAI_API_KEY\n      from openai.embeddings_utils import get_embedding\n      \n      # SymbolEmbeddingHandler\n      \n      `SymbolEmbeddingHandler` is an abstract class used to handle the embedding of symbols. It provides an interface for getting and updating the embeddings for symbols using different types of embeddings.\n      \n      ## Overview\n      \n      The `SymbolEmbeddingHandler` defines the basic structure and methods required for managing symbol embeddings. Its main purpose is to fetch and update the vector embeddings associated with different kinds of symbols. This class has to be extended by other classes to provide the implementation of the abstract methods defined in this class.\n      \n      ## Related Symbols\n      \n      * `automata.core.embedding.embedding_types.EmbeddingProvider`\n      * `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n      * `automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler`\n      * `automata.core.event.vector_storage.VectorDatabaseProvider`\n      * `automata.core.symbol.symbol_types.Symbol`\n      * `automata.core.symbol.symbol_types.SymbolEmbedding`\n      \n      ## Example\n      \n      The following example demonstrates how to subclass `SymbolEmbeddingHandler` and implement the abstract methods:\n      \n      ```python\n      from automata.core.embedding.embedding_types import SymbolEmbeddingHandler\n      from automata.core.symbol.symbol_types import Symbol\n      \n      class CustomSymbolEmbeddingHandler(SymbolEmbeddingHandler):\n          def __init__(self, embedding_db, embedding_provider):\n              super().__init__(embedding_db, embedding_provider)\n      \n          def get_embedding(self, symbol: Symbol):\n              # Implement logic to get the embedding for a custom symbol\n              pass\n      \n          def update_embedding(self, symbol: Symbol):\n              # Implement logic to update the embedding for a custom symbol\n              pass\n      \n      # Example usage:\n      custom_handler = CustomSymbolEmbeddingHandler(embedding_db, embedding_provider)\n      custom_embedding = custom_handler.get_embedding(custom_symbol)\n      ```\n      \n      ## Limitations\n      \n      Since `SymbolEmbeddingHandler` is an abstract class, it cannot be instantiated directly. Instead, it must be subclassed and the abstract methods must be implemented in the derived class.\n      \n      The implementation of the `get_embedding()` and `update_embedding()` methods in the derived class will depend on the context and the type of symbol embeddings used. The performance of these methods might vary based on the selected embedding provider and the database used for storing the embeddings.\n      \n      ## Follow-up Questions:\n      \n      - How can we extend this class to handle other types of embeddings?\n      - How can the performance of this class be improved for specific use cases?\n      \n    Class Docstring:\n      An abstract class to handle the embedding of symbols\n      \n    Methods:\n      def __init__(\n              self,\n              embedding_db: VectorDatabaseProvider,\n              embedding_provider: EmbeddingProvider,\n          ):\n              \"\"\"An abstract constructor for SymbolEmbeddingHandler\"\"\"\n              self.embedding_db = embedding_db\n              self.embedding_provider = embedding_provider\n      \n          \n      @abc.abstractmethod\n          def get_embedding(self, symbol: Symbol) -> Any:\n              \"\"\"An abstract method to get the embedding for a symbol\"\"\"\n              pass\n      \n          \n      @abc.abstractmethod\n          def update_embedding(self, symbol: Symbol):\n              \"\"\"An abstract method to update the embedding for a symbol\"\"\"\n              pass\n      \n      \n      \n  Building context for related symbols -\n  \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler\n    \n        The `SymbolDocEmbeddingHandler` class is responsible for generating, storing, and managing document embeddings for symbols in an AutomataDocs project. It relies on the `VectorDatabaseProvider`, `EmbeddingProvider` classes, and uses methods like `build_symbol_doc_embedding`, `update_embedding`, `get_embedding`, `get_doc`, and `get_summary` for managing symbol document embeddings and their summaries. The class utilizes various other components like `SymbolGraph`, `SymbolSimilarity`, and `SymbolRankConfig` to search, rank, and generate context for symbol embeddings. However, it has limitations concerning the embedding models and algorithms used and can sometimes produce suboptimal context or examples. Improving the underlying components can potentially enhance the embedding quality.\n        \n        Example usage:\n        \n        ```python\n        from automata.core.embedding.doc_embedding import SymbolDocEmbeddingHandler\n        from automata.core.database.vector import JSONVectorDatabase, VectorDatabaseProvider\n        from automata.core.embedding.embedding_types import OpenAIEmbedding, EmbeddingProvider\n        from automata.core.symbol.symbol_types import Symbol\n        \n        # Initialize the database provider and embedding provider\n        db_provider = VectorDatabaseProvider(JSONVectorDatabase(\"path/to/symbol_doc_embedding.json\"))\n        embedding_provider = EmbeddingProvider(OpenAIEmbedding())\n        \n        # Create an instance of SymbolDocEmbeddingHandler\n        embedding_handler = SymbolDocEmbeddingHandler(db_provider, embedding_provider)\n        \n        # Example symbol and source code\n        symbol = Symbol.from_string(\"symbol-uri-as-string\")\n        source_code = \"def example_function():\\n    pass\"\n        \n        # Build the symbol document embedding\n        symbol_doc_embedding = embedding_handler.build_symbol_doc_embedding(source_code, symbol)\n        ```\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n                code_embedding_handler: SymbolCodeEmbeddingHandler,\n                embedding_db_l2: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                A constructor for SymbolDocEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (EmbeddingProvider): The provider to get the embeddings from\n                    code_embedding_handler (SymbolCodeEmbeddingHandler): The code embedding handler\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n                from automata.core.embedding.symbol_similarity import SymbolSimilarity\n                from automata.core.symbol.search.rank import SymbolRankConfig\n                from automata.core.symbol.search.symbol_search import SymbolSearch\n        \n                graph = SymbolGraph()\n                subgraph = graph.get_rankable_symbol_subgraph()\n                symbol_similarity = SymbolSimilarity(code_embedding_handler)\n                self.graph = graph\n                self.symbol_search = SymbolSearch(\n                    graph, symbol_similarity, symbol_rank_config=SymbolRankConfig(), code_subgraph=subgraph\n                )\n                self.embedding_db_l2 = embedding_db_l2\n        \n            \n        build_symbol_doc_embedding(self, source_code: str, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_doc(prompt: str) -> str\n        \n        get_embedding(self, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_summary(input_doc: str) -> str\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.symbol.symbol_types.SymbolEmbedding\n    \n        SymbolEmbedding is an abstract base class used to represent various symbol embeddings, such as SymbolCodeEmbedding and SymbolDocEmbedding. It provides a basic structure for initializing and managing these embeddings, taking into account their source and their vector representation in the feature space. SymbolEmbedding is utilized by different embedding handlers like SymbolCodeEmbeddingHandler and SymbolDocEmbeddingHandler. As a base class, its functionality is limited and should be extended by classes with specific embedding types. An example of creating a SymbolCodeEmbedding instance is shown below:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def __init__(self, message): pass\"\n        vector = np.array([0.1, 0.2, 0.3])\n        \n        symbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Abstract base class for different types of embeddings\n        \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n    automata.core.embedding.embedding_types.EmbeddingProvider\n    \n        `EmbeddingProvider` is an abstract base class that serves as an interface for obtaining mathematical representations called embeddings for symbols, used in tasks such as similarity search, ranking, and other natural language processing-related work. Its single abstract method, `build_embedding`, should be implemented by all subclasses to provide specific embedding implementations. Users must create their own classes that inherit from `EmbeddingProvider` and implement these methods, which might be a limitation for those unfamiliar with custom classes and abstract methods.\n        \n        Here is an example of using the `OpenAIEmbedding` class, a concrete implementation of `EmbeddingProvider`:\n        \n        ```python\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        import numpy as np\n        \n        symbol_source = \"This is an example of a Python function.\"\n        embedding_provider = OpenAIEmbedding() \n        embedding = embedding_provider.build_embedding(symbol_source)\n        \n        # Check if the generated embedding is a numpy array\n        assert isinstance(embedding, np.ndarray)\n        ```\n        Performance and accuracy of embeddings depend on the specific model and approach used in the concrete implementation of `EmbeddingProvider`.\n        \n      Class Docstring:\n        A class to provide embeddings for symbols\n        \n      Methods:\n        build_embedding(self, symbol_source: str) -> np.ndarray\n        \n    automata.core.symbol.symbol_types.SymbolDocEmbedding\n    \n        `SymbolDocEmbedding` is a class representing the embedding for symbol documents, extending the `SymbolEmbedding` class with added metadata such as source code, summary, and context. This class is utilized alongside `SymbolDocEmbeddingHandler` to manage and access these embeddings for tasks like search and similarity comparison. However, it relies on external handler classes and assumes embeddings are provided as NumPy arrays, potentially limiting usage for other embedding types.\n        \n        ```python\n        import numpy as np\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.symbol.symbol_types import SymbolDocEmbedding\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        symbol = Symbol.from_string(symbol_str)\n        \n        document = \"This is a sample document\"\n        vector = np.array([0.1, 0.2, 0.3])\n        source_code = \"class ActionIndicator(Enum): ...\"\n        summary = \"This class represents an enum for action indicators.\"\n        context = \"The ActionIndicator enum is used to describe the current state...\"\n        \n        embedding = SymbolDocEmbedding(symbol, document, vector, source_code=source_code, summary=summary, context=context)\n        ```\n        \n      Class Docstring:\n        Embedding for symbol documents\n        \n      Methods:\n        def __init__(\n                self,\n                symbol: Symbol,\n                document: str,\n                vector: np.array,\n                source_code: Optional[str] = None,\n                summary: Optional[str] = None,\n                context: Optional[str] = None,\n            ):\n                super().__init__(symbol, document, vector)\n                # begin additional meta data\n                self.source_code = source_code\n                self.summary = summary\n                self.context = context\n        \n    automata.tests.unit.conftest.get_sem\n    \n        def get_sem(monkeypatch, temp_output_filename):\n            monkeypatch.setattr(\n                \"automata.core.symbol.symbol_utils.convert_to_fst_object\",\n                lambda args: \"symbol_source\",\n            )\n            return SymbolCodeEmbeddingHandler(temp_output_filename)\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.SymbolCodeEmbedding\n    \n        `SymbolCodeEmbedding` is a class extending the `SymbolEmbedding` base class, used to store code embeddings for a given symbol, the symbol object, source code, and the embedding vector. It primarily serves as a container for these embeddings and does not include functionality for generating or handling them; `SymbolCodeEmbeddingHandler` should be used for those purposes.\n        \n        Here's an example of creating a `SymbolCodeEmbedding` instance:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def example_function():\\n    pass\"\n        vector = np.random.random((300,))\n        \n        embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Embedding for symbol code\n        \n      Methods:\n        def __init__(self, symbol: Symbol, source_code: str, vector: np.array):\n                super().__init__(symbol, source_code, vector)\n        \n        \n        \n    automata.tests.unit.test_symbol_embedding.test_get_embedding\n    \n        def test_get_embedding(\n            monkeypatch,\n            mock_embedding,\n            mock_simple_method_symbols,\n        ):\n            # Mock EmbeddingProvider methods\n            mock_provider = Mock(EmbeddingProvider)\n            mock_provider.build_embedding.return_value = mock_embedding\n        \n            # Mock JSONVectorDatabase methods\n            mock_db = MagicMock(JSONVectorDatabase)\n            mock_db.get.return_value = SymbolCodeEmbedding(\n                mock_simple_method_symbols[0], \"symbol_source\", mock_embedding\n            )\n        \n            # Create an instance of the class\n            cem = SymbolCodeEmbeddingHandler(embedding_provider=mock_provider, embedding_db=mock_db)\n        \n            # Call the method\n            embedding = cem.get_embedding(mock_simple_method_symbols[0])\n        \n            # Verify the results\n            assert embedding.vector.all() == mock_embedding.all()\n        \n        \n        \n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n  Building context for dependencies -\n  \n    automata.core.database.vector.VectorDatabaseProvider\n    \n        `VectorDatabaseProvider` is an abstract base class designed for implementing custom vector database providers. It provides a basic structure for a vector storage system and requires subclasses to implement the `calculate_similarity()` and `get_all_symbols()` abstract methods. The former computes the similarity between a given vector and all stored vectors, while the latter retrieves a list of all symbols in the database. However, the base class does not offer built-in functionality for adding, updating, or removing symbols and their embeddings, requiring implementers to handle these operations themselves. A basic example implementation of the `VectorDatabaseProvider` class can be seen in the provided code snippet.\n        \n      Class Docstring:\n        Abstract base class for different types of vector database providers.\n        \n      Methods:\n        calculate_similarity(self, embedding: SymbolEmbedding) -> List[Dict[Symbol, float]]\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.embedding.symbol_similarity`/SymbolSimilarity#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.embedding.symbol_similarity", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolSimilarity", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolSimilarity\n\n`SymbolSimilarity` is a class providing functionality to compute similarity scores between given query texts and symbols using embeddings. You can retrieve the most similar symbols for a specific query and create a dictionary mapping the similarity scores to each symbol. Additionally, you have the flexibility to set the available symbols for similarity calculation.\n\n## Overview\n\nThe `SymbolSimilarity` class takes a `SymbolCodeEmbeddingHandler`, and an optional `NormType` to calculate similarity between query texts and symbols. It offers methods to get available symbols, get the nearest symbols for a query, and get the similarity dictionary for a query. The class uses embeddings and a variety of similarity metrics for determining the similarity between query texts and symbols.\n\n## Related Symbols\n\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.embedding.embedding_types.EmbeddingSimilarity`\n- `automata.core.symbol.search.symbol_search.SymbolSearch`\n- `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n- `automata.core.embedding.embedding_types.NormType`\n\n## Example\n\nThe following example demonstrates how to create an instance of `SymbolSimilarity` using a predefined `SymbolCodeEmbeddingHandler`.\n\n```python\nimport numpy as np\nfrom automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\nfrom automata.core.embedding.embedding_types import EmbeddingProvider, NormType\nfrom automata.core.embedding.symbol_similarity import SymbolSimilarity\n\n# Instance of a SymbolCodeEmbeddingHandler\nembedding_handler = SymbolCodeEmbeddingHandler(embedding_db=embedding_db, embedding_provider=embedding_provider)\n\n# Create an instance of SymbolSimilarity\nsymbol_similarity = SymbolSimilarity(symbol_embedding_manager=embedding_handler, norm_type=NormType.L2)\n\n# Set available symbols\nsymbol_similarity.set_available_symbols(available_symbols)\n\n# Get the nearest entries for a query\nnearest_entries = symbol_similarity.get_nearest_entries_for_query(\"example query\", k=5)\n\n# Get the query similarity dictionary\nquery_similarity_dict = symbol_similarity.get_query_similarity_dict(\"example query\")\n```\n\n## Limitations\n\n- The primary limitation of `SymbolSimilarity` is its reliance on pre-trained embeddings, which means the quality of the similarity scores depends on the quality of the embeddings and the selected norm type. If embeddings do not accurately represent the symbols or the norm type is not suitable for the given problem, the similarity scores might not be as accurate.\n- As `SymbolSimilarity` uses `SymbolCodeEmbeddingHandler` to handle embeddings, if `SymbolCodeEmbeddingHandler` is not properly constructed or initialized, the class may not provide the desired results.\n\n## Follow-up Questions:\n\n- How can we extend `SymbolSimilarity` for other types of embeddings or similarity measurements?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "AAAAgL37ib8AAAAgcteQvwAAAIB971O/AAAAQOgDnr8AAACg276CvwAAAMD3b4k/AAAAAL8njj8AAABAd3GPPwAAAOA2ToO/AAAAQPQZmb8AAADglUuOvwAAAOArTYa/AAAA4ASzjL8AAADgyRBxPwAAAGCbs5A/AAAAoNU/ij8AAABAIUuVPwAAAOAfN3s/AAAA4OOXmz8AAADgKSOKvwAAAIDDeoI/AAAAAHLwXr8AAABgZJalvwAAAIDzA5e/AAAAAIWakL8AAACACAltPwAAAAC7uoc/AAAAgJhzor8AAABgdS6VvwAAAABug2g/AAAAIGtDmj8AAABAvw6gvwAAAMBvrpi/AAAAgK14iD8AAABA3yyNvwAAACDqFSA/AAAAYGSWlT8AAADA5+yXvwAAAACKHKU/AAAA4K6Mkr8AAACAMLhkvwAAAMDx2HY/AAAAoBzghr8AAADgK02WvwAAAGCJHn2/AAAAgBCykT8AAAAATWiHvwAAAIDJEZW/AAAAQKSKYb8AAADAmrV4PwAAAMA/JYQ/AAAAgN7+oD8AAABArXmcvwAAACD/GmY/AAAAwDmOgT8AAABAYEKNPwAAAIB2Q5M/AAAAQLmPdz8AAABAGreOvwAAACC8zzU/AAAAIAOIfL8AAAAgGHV4vwAAAKCeClW/AAAAYExqb78AAAAAL4xQvwAAAADy16K/AAAAgASclr8AAADAwmSQPwAAAMDCZKA/AAAAwDQkpz8AAACAGIyePwAAAMDFvKg/AAAAoIJxeD8AAACAHguXPwAAAMDx2JY/AAAAIFUpdr8AAABgb5eCvwAAAODJEIE/AAAAwDMPeb8AAACgVlVaPwAAAOBKPis/AAAAQDU7nb8AAABAcMVuPwAAACCXX4g/AAAAIP3wKT8AAACAkMqNPwAAACBLPWe/AAAAIMxSpz8AAAAgrExkPwAAAODOkpW/AAAAACFMmT8AAAAgDomZPwAAAODJEIE/AAAAoN8rib8AAAAgjEaRPwAAAMAid5k/AAAAIFqrej8AAADgseSqPwAAAGC1Ops/AAAAwKo4ir8AAADglUt+vwAAAMDAUp4/AAAAoH4Eor8AAACA6AJ6vwAAAODqK6K/AAAAoGgCiD8AAADAscxwvwAAACDvl5S/AAAAoFzsjD8AAADg4oKdPwAAAGAz+KK/AAAAwJvKdj8AAADAQ5J6vwAAAABy8I6/AAAAoOWqUb8AAAAAt02BPwAAAMD4hIc/AAAAQGBCjb8AAACgN2SVvwAAAABkl3m/AAAAoBvLiD8AAADgdUWbPwAAAADxwmQ/AAAA4LMOl78AAABgr6OYPwAAAKBjgIO/AAAAgCs2gD8AAADg/QaMvwAAAIAOiJW/AAAAYJCyk78AAADgwnxqvwAAAMAy+oo/AAAAgExRkT8AAAAAImGHPwAAACBbwGi/AAAA4DZOoz8AAADAoEybvwAAACDx2n4/AAAAwBZhnj8AAABggURwvwAAAEDJEpk/AAAAQJPyoT8AAACAW7+UvwAAAICQyn0/AAAAgD8mqL8AAAAghseYPwAAAEAluIs/AAAAYB32eD8AAACgD7V9PwAAAOCTCGS/AAAAIFUplj8AAACAfNqFvwAAACB1L5m/AAAAgGtCdr8AAAAAr6R8PwAAAEBMUkU/AAAAoOoslr8AAADgnN+EPwAAAAABRpa/AAAAgPiFm78AAACgyiZjPwAAAACbtJQ/AAAAQC1hkL8AAABgOY9VvwAAACAVHYA/AAAAIPqYgT8AAAAAEt6VPwAAACBFpmQ/AAAAwFqpkr8AAAAgNSOjvwAAAMDjf5G/AAAAgKj2c78AAACgXemgvwAAAGD973W/AAAAgN0Bfb8AAADgWsGcvwAAAACUII4/AAAAAHuucT8AAACgsw+bvwAAACDvl6S/AAAAQKSKkT8AAACgqSOMPwAAAMATCZY/AAAAID4Snj8AAAAgl1+IvwAAAKAby4i/AAAA4IFbVj8AAAAAlCB+PwAAAECDb6A/AAAAYBh0hL8AAACgG8uIPwAAAICBXJo/AAAAwDmOgT8AAADAurt7vwAAAKB+BOK/AAAAQGJsib8AAADAwU9CPwAAAKAR36m/AAAAgGFWh78AAAAAPw+SvwAAACCXX5i/AAAA4O+tdr8AAACgVBKgvwAAAGDWVaw/AAAAQHDFjr8AAAAAoDaJvwAAACDT/pe/AAAAAD3llT8AAACgEd9JvwAAAADAPJy/AAAAAF8VhT8AAABgijObvwAAACDT/oe/AAAAwIBGiD8AAAAAT5KDvwAAACAUCJI/AAAAYGWro78AAADgDp97PwAAAEAmzZk/AAAAoJmIkD8AAAAAcvCOvwAAAMAICIm/AAAAgEW9mj8AAADAxbyIPwAAAMBPqKW/AAAAgOgCij8AAAAgxtOePwAAAEBn1lM/AAAAQKkMpj8AAADAeZqHvwAAACC8z0U/AAAAQBHIoz8AAAAA28B6PwAAAKC6o6E/AAAA4Bq1pr8AAACg4ECHvwAAAAAS3nU/AAAAIDUjkz8AAABgxtJ6PwAAAACvpJw/AAAAoJ8fkz8AAADAy1OLvwAAAMA0JIe/AAAAgO2Ejr8AAABgCPFSvwAAAKBm2Hs/AAAAQL4RjD8AAACgonebPwAAAAACW5Q/AAAAIMjlUD8AAACASj+fPwAAAOBBT6C/AAAAgO+WgD8AAABg4VZpPwAAAOAUHoQ/AAAAQM+paz8AAABgWZVYPwAAAGBYgJq/AAAAQBu0Yr8AAAAAljKgPwAAAGDMUYM/AAAAgEOTbr8AAACA2ZSWvwAAAICH24K/AAAAYCN1kT8AAADAtk6FPwAAAID0GFU/AAAAgAWxhD8AAABgY4GHPwAAAOAkoaU/AAAAgAOHqD8AAAAAepmTvwAAACBAJJA/AAAAgFHThT8AAADAdS2RPwAAACC2UI2/AAAA4KJ2l78AAADg6RaEvwAAACBQp5E/AAAAwAOGhL8AAACgoDSRvwAAAOBR0mE/AAAAAPzDkT8AAABAUdSJPwAAAACUII4/AAAA4E/Anz8AAADg+q6jvwAAAOCR3qe/AAAAYC15Wr8AAACAKzagPwAAAKBugZC/AAAA4EFPkL8AAACg6ix2PwAAAIATCmq/AAAA4P4bir8AAAAAAluUvwAAAKBklWE/AAAAwLq7ez8AAADgQDpCvwAAAECjdZO/AAAA4GbXl78AAABg5tidPwAAAIDCZXQ/AAAAAObBd78AAACAwn1+PwAAAADBOaC/AAAAAEJnij8AAABgF1+GPwAAAECo95c/AAAAAGkBpL8AAAAA5sGnPwAAACCudpC/AAAAgAgJjb8AAAAAQmeKvwAAAOA/PZ6/AAAAgK14iL8AAAAgGHWYvwAAAGDNZoG/AAAAAH8biL8AAACAjF1nPwAAAICMXXc/AAAAQJ4Lib8AAAAA5ayZvwAAAKCXdk4/AAAAoPDDmD8AAAAAOHt7vwAAAKD82XM/AAAAYBzhaj8AAABAaOuRPwAAACCFspo/AAAAYG6anj8AAACg4ECXvwAAAGBI/Yi/AAAAgO2EXr8AAADAhbCCvwAAACAUCHK/AAAA4JzfdD8AAAAgp+KZvwAAAEDqLZq/AAAAoJL0eb8AAACgmYhgvwAAAMCOn40/AAAAgMSPYL8AAABAQVGYvwAAAODvrZa/AAAAwBL0h78AAADA7WuAvwAAAAB98Xs/AAAAwNvWnL8AAABgpKKbvwAAAABak4A/AAAAoFzsXL8AAAAgD56HPwAAAGBvl6K/AAAA4I1xcb8AAAAAjomLPwAAAECNc6m/AAAAIDqlh78AAABAeG6TvwAAAAC/J44/AAAAYBdfdj8AAAAA+rGfPwAAAKBklWG/AAAAYKA1pb8AAABAxaWivwAAAGDQvom/AAAAID8nnD8AAACAzX6bPwAAAGCZoZ4/AAAAoNu+Er8AAADgrXd0vwAAAECjdZM/AAAAYF4XnT8AAACAOqSDvwAAAEAy44Q/AAAA4DZOg78AAAAgm8yevwAAAEAy46S/AAAAIGAqoz8AAABg+8VJPwAAAKC/JZY/AAAAAIsxc78AAADgg4WSPwAAAOA/PZ4/AAAA4GxWUD8AAABAuHpZvwAAAEBo66G/AAAA4PQXoT8AAAAg2GhyvwAAAKDkrZ0/AAAAYEWlkL8AAACgEd9pvwAAAOCXdXq/AAAAANvAej8AAABgXxShPwAAAIAkonk/AAAAIKJghT8AAADgx/5+vwAAAMCeIn+/AAAAIFvAiL8AAACgqQuCPwAAACDugna/AAAAgJZJhj8AAABAKzeUPwAAAOCR3pc/AAAA4CS5jz8AAAAAb5iWvwAAAMDG0Za/AAAAoPzZYz8AAABA8cGAPwAAAAA95YW/AAAAAGoWgj8AAADADodxPwAAAOAWSIA/AAAAoLmmjb8AAADgrXd0PwAAAMCGxZA/AAAAIM58c78AAAAAL4yQPwAAAMAeCpM/AAAAoJiLjD8AAABAxJCEvwAAAABH6X6/AAAAgOOAlb8AAACgzpOJvwAAAIDLVD+/AAAAgDu5cb8AAACgD7WNvwAAAADn1qU/AAAAgNmUhj8AAABgRaWQPwAAAGCRx3E/AAAAgJZJhj8AAAAAeYSFvwAAAMCOn52/AAAAoF3pgD8AAACAm8uKPwAAAID+BKS/AAAAQN8Ugz8AAACAkd+LvwAAAMDjf5E/AAAAAKs3hj8AAABA5auFPwAAACB3WXW/AAAAINl9gL8AAACgbYSMPwAAAMD73H8/AAAAYJ8glz8AAABg5th9PwAAAOCFyHw/AAAAQEfQcD8AAACANCV7PwAAAMDiaoM/AAAAYObYnT8AAADAIndpPwAAAEDgKYG/AAAAoEN6oD8AAADA29ZcvwAAAMA5jqE/AAAAwA6Hkb8AAABgDF6JvwAAAGA0DaG/AAAAwLvQib8AAADgJLlvPwAAAMC3Y5O/AAAAQBZKmL8AAAAgBIUwPwAAAKCqIIC/AAAAAPPsoD8AAAAg2X1wvwAAAACrN5Y/AAAAAI6Jmz8AAACAuY6TPwAAAEBibJk/AAAAIFvAmL8AAABAImCjvwAAAODpFqQ/AAAAwHUtkT8AAACgsvqMvwAAAKBT/XE/AAAAwKbLo78AAACAHgt3PwAAAICI8DA/AAAAwKbLoz8AAACgdBiTPwAAAGAJBqE/AAAAALUjhT8AAACgGrZaPwAAAIAgNYO/AAAAwOFVhT8AAADgVT+IPwAAAIB1Ro8/AAAAgKfhZT8AAAAA+rGPPwAAAGCvo5g/AAAAwItHdT8AAACAnOCYvwAAAMCJHYk/AAAAQOgDrj8AAABgKPd1vwAAAKAo9nE/AAAAwFqpkr8AAABgfxqUvwAAAOB82aG/AAAAwF4Wab8AAABgcKxgPwAAAEB4bpO/AAAAQLmPlz8AAABA6AOOPwAAAKC+EJg/AAAAoCj2gT8AAAAAImGHPwAAAOBy7YI/AAAAAKa1kT8AAABA+rCLPwAAAAAn44u/AAAAoEfndr8AAACA12qaPwAAACA6pac/AAAAgB8glT8AAABAonh/vwAAAMAICIm/AAAAwJUzhL8AAACAbFd0PwAAAEDVKJS/AAAAgCs2kL8AAAAgdkSXPwAAAMDn7Fc/AAAAwC14pr8AAADgFB6kvwAAAACgNmk/AAAAgOOAlT8AAADAcxufPwAAAGA5j3U/AAAAAD3llb8AAACgySl/vwAAAGAH3JQ/AAAAANG8kb8AAABgOY91PwAAAAD6sX+/AAAAgJ31hr8AAABghJxovwAAAMDAUn4/AAAAwNdppr8AAACg/zGcPwAAAIAkopk/AAAAQFHUaT8AAABgvyaqvwAAAECT8nG/AAAAQDLjpD8AAACgdBiDPwAAAGC0JZ0/AAAAIIbHmL8AAAAgCQelPwAAACAEhaA/AAAAwP3uoT8AAAAg3v+UPwAAAOA2TnM/AAAAYB32mD8AAABg7WyUPwAAAAD8w5E/AAAAYGWroz8AAACgQ3pgPwAAAIDT/YO/AAAAAI+eib8AAADgh/JYvwAAAIB7xZe/AAAAQPHBgD8AAADgBbCQvwAAAIBDk26/AAAAQJmJlL8AAADgFB6EvwAAAEALSYs/AAAAIJU1fL8AAABg3NSUvwAAAAC3TZG/AAAAAFP/ib8AAACAol+hvwAAAGCUH5q/AAAAoOWqkb8AAABgM/hSvwAAAEDqLZq/AAAAwHMbj78AAACgw5JsPwAAAKDKJlO/AAAAIHmcTz8AAABAvfxtvwAAAKD1LYM/AAAAYBL1iz8AAADgVlR2vwAAAEAFspg/AAAA4IOFor8AAADADXKDPwAAAMDta3C/AAAAoDZPZz8AAAAAsKFwvwAAAAAWS3y/AAAAgJzgmL8AAADg4oI9vwAAAKBc7Iy/AAAAgBiMjr8AAAAAYm2dvwAAACDCZni/AAAAYD4Rer8AAABAFkp4vwAAAIBfLGs/AAAAgDU6GT8AAADg45eLPwAAAMA4kZ0/AAAAYAxemT8AAADA29acvwAAAABpAZS/AAAAwNHSkz8AAABgWICKPwAAACBy13A/AAAAYDQNoT8AAABgTpRbvwAAAGD976W/AAAAAE+Scz8AAABgzWaRvwAAAMAOh5E/AAAAIJ3eYD8AAADAbpmaPwAAAADPqp+/AAAAIDY4gb8AAAAA28CaPwAAAODYfoS/AAAAoPQwTz8AAACgC0hHPwAAAKDsVmK/AAAAwEgUfz8AAACgIWKLPwAAAIC5jpM/AAAAYDmPNb8AAAAAuZCbvwAAACBxwoI/AAAAgHdYMb8AAABAbFiYvwAAAIDzA1c/AAAAYG6aTr8AAABg60KIPwAAAABy8D6/AAAAoFZVij8AAACA8wOHPwAAAIDklYO/AAAAAAFGhr8AAAAgDol5vwAAAKA85ok/AAAA4MkQYT8AAADAx+ZkPwAAAEDNf4+/AAAAoIfzjL8AAABgmaGePwAAAMBumXq/AAAAwLDPnL8AAADAlkiSvwAAAAB/G5i/AAAAwPLthD8AAACgjoeDvwAAACAEhZA/AAAAYF4Xfb8AAACAxI+QvwAAAABy8I6/AAAAQDC5mL8AAAAgzWeVvwAAAECT8qE/AAAAYLzOQb8AAACACR6bPwAAAOCFyEw/AAAAwMFPYr8AAADgL7qMvwAAAKCpC6K/AAAAAIWakD8AAACg3NOAPwAAAODCfHo/AAAAwGtBoj8AAADAlTOUPwAAAMAH85o/AAAAIMJmqD8AAADAkMmJvwAAAACko48/AAAAQFdrjD8AAACgyiaTPwAAAKCYi4w/AAAAYKSiiz8AAAAAWX6SvwAAAEDwrFK/AAAAwOgBlr8AAAAg+piRPwAAAADsWDo/AAAAwOtZjr8AAADgFDZuvwAAAOC9+oU/AAAAgMtUnz8AAACAMLh0vwAAAOD0F4G/AAAAIOkAkr8AAAAgVSmmvwAAAEBXa1w/AAAAIAockz8AAABATFKVvwAAAIAlt5c/AAAAgLvRrb8AAAAAN2advwAAAADz7IC/AAAAwAgIiT8AAACANTp5PwAAAIBWPZA/AAAAgI1yZT8AAABAfgU2PwAAACBwrZQ/AAAAAE1oZz8AAADAPyWUPwAAAMD+A5C/AAAAQLUigT8AAACA7oGSvwAAAOAUNo6/AAAAoFZVaj8AAADgnfQivwAAAKCfH6M/AAAAYOFWeT8AAABA8cFgPwAAAIAzEH2/AAAAIEa7kj8AAADAsM98vwAAAADLPYm/AAAAoNC9hT8AAAAAPw9SvwAAAOBhVaO/AAAAIHHCor8AAABgpbepvwAAAGAZiZK/AAAAgDQlm78AAAAgGp+kPwAAAOBWVIa/AAAAgDqkgz8AAAAAsKGAPwAAAKD6r5e/AAAAgJzgWD8AAAAg6hVwvwAAAOBn7KU/AAAAILLjlr8AAADAAnGGPwAAACAI8oY/AAAAQJPygb8AAAAAIUxZvwAAAIDYf4g/AAAA4FU/aL8AAADAeZqHvwAAACCS3aM/AAAAAE+Skz8AAACA5+2LvwAAAKA6vI0/AAAAwI6fnT8AAAAAlCCevwAAAOBgQJW/AAAAQAWyqL8AAAAg+YNjvwAAAACZipg/AAAAABZLXL8AAADASiaRvwAAAKBc7Jw/AAAAQNQTlr8AAAAAj56JPwAAACCn4pm/AAAAoHzyX78AAACgZthbvwAAAOA/PV6/AAAAoG1sgj8AAADAeZqXPwAAAADAPIw/AAAAYJuzoD8AAACgZ+15PwAAAEBFvn4/AAAAIKFLV78AAABArXmMvwAAACDhV32/AAAA4JZgbD8AAADAb66IPwAAAGBZlYg/AAAAAJqflr8AAABAqPeXvwAAAODDkag/AAAA4FHScb8AAAAA7Fh6vwAAAIAeCyc/AAAAAEn7kL8AAADgngmhPwAAAIB976O/AAAAoOBAl78AAADAOY6BvwAAAMAjjGe/AAAAIHLXUD8AAACgCjOJPwAAAIAJHou/AAAAIBQIgr8AAACAZsCRPwAAAEALMYE/AAAAQH4Fhj8AAABAYEJ9vwAAAGBI/Yg/AAAAQHzbiT8AAADAVCpaPwAAACBQp5E/AAAAYPzaZ78AAABgGYlyvwAAAAACW4S/AAAAQE1no78AAACAQVCUvwAAAODaqJC/AAAAIB8hWb8AAAAAmYqYPwAAACDx2n4/AAAAADP5dr8AAABgXxShPwAAAOBFvKY/AAAAAJUdgr8AAACgUeufPwAAAMCOn30/AAAAAEN8qD8AAABg7WykvwAAAGB0GYe/AAAAIMbTnr8AAABgI3WBvwAAAKAhSqE/AAAAoKJ3a78AAABA9kOVvwAAAMBjmG2/AAAAIESRlr8AAAAgctegPwAAAABNaJc/AAAAQNmVmr8AAADAwmSAPwAAAKBia3U/AAAAoOStbT8AAAAgOqWXvwAAAIB82pW/AAAA4HLtkj8AAADg2ZNyPwAAAOD+G4q/AAAAIJzJkj8AAADA7WuQPwAAAMC6u5s/AAAAIJdfaL8AAADgK02mvwAAAKBzA5W/AAAAIHvGq78AAAAgznyTvwAAAACwuXq/AAAAQLqkJT8AAACAHgtnvwAAAMC1OXe/AAAAQFdrnL8AAADArGJ2PwAAAADsWIq/AAAAoFHrjz8AAAAAqzeWPwAAACDx2m4/AAAAQJQHkD8AAADAtTl3PwAAAGD973U/AAAAgCSimT8AAADgp/ibvwAAACAKHKO/AAAAgKtOTD8AAABAmYmEPwAAAICteJi/AAAAgP8Zkj8AAACgqQuSPwAAAMCrTZg/AAAAQLh6eT8AAADAHgqjvwAAAKDc05C/AAAAgDC4lL8AAADgBbCgvwAAAKCOh3O/AAAA4E/An78AAADAKQtgvwAAACBmwZU/AAAAYPhtoT8AAADAm8p2vwAAAAAMX50/AAAA4JzflL8AAADgQDqSPwAAAEDfFKO/AAAAwLZOhT8AAAAgDXRLvwAAAICteIg/AAAAIPmDg78AAABgr6NoPwAAAKDVJ2C/AAAAYP3vhT8AAADAtk6FPwAAAKD6r5c/AAAAgExRkb8AAABg4EGrPwAAAMAjjJe/AAAAgHdYkb8AAABgTpR7PwAAAECT8pE/AAAAwEkRkz8AAAAg7oKGvwAAAOC3e40/AAAAQFzVdr8AAACAFB94PwAAAEDkllc/AAAAoDZPl78AAAAA8cKEvwAAACCH3Ha/AAAAwHMbnz8AAABgqzZyvwAAAEBtbZY/AAAA4Akdh78AAADgkvOFvwAAAEC4enm/AAAAgJvLKj8AAABgtCWdPwAAAACqIni/AAAAwGtBor8AAAAg6QCiPwAAACCxzni/AAAA4A+0eb8AAACgMuKgvwAAAOBWVGY/AAAAwOFVlb8AAABAFkp4vwAAAOC3e30/AAAAQKj3l78AAADgnfRivwAAAMB1LaG/AAAAgDu5oT8AAABgaAOMvwAAAKCTCUi/AAAAgB4LV78AAACgSPykvwAAAAB6mZO/AAAAQGfunT8AAACA2H+YvwAAAMC1OYe/AAAAYLzOoT8AAADgOaabvwAAAGDMUZM/AAAA4PmZlT8AAAAgkciVvwAAAEBH0HA/AAAAgBqekL8AAABAWGhgvwAAAICy4pK/AAAAgLvRfT8AAADg762GvwAAAEAiYJO/AAAA4IFbhj8AAACgBsaSvwAAAEB3cX8/AAAA4Hdvxz8AAAAglkpqvwAAAMD97pE/AAAAYEkSlz8AAABAeG5zvwAAAECTCoy/AAAAYBzher8AAACgro12vwAAAMBaqZK/AAAAgMj8lr8AAACA/xmSPwAAAMBzG48/AAAAwKo4mr8AAADgBLN8PwAAAGD4bZE/AAAAgBiMnr8AAADAwmSgvwAAAOBFvJa/AAAAAAFGhr8AAAAg3ep2PwAAAIBDk44/AAAAAJ8hi78AAACg/zGcvwAAAEDNf5+/AAAAIN3qlj8AAABgkcdxPwAAAIBx2Yi/AAAAABZLfL8AAAAAImGnPwAAAKAby5g/AAAAQNUopL8AAADg2qiQPwAAAGBzBJk/AAAAYHCscL8AAABAjF6LvwAAAODpFnS/AAAAwDL6aj8AAAAAZJdpPwAAAIDNfps/AAAAYEfomj8AAABAFkpYPwAAAADPqp+/AAAAoM6TaT8AAAAgGYqWvwAAAMD73J8/AAAAoJ8fk78AAADgGaBovwAAAABfFXU/AAAAQBzJUD8AAADAwmSgPwAAAMCbyqa/AAAAIKxMNL8AAAAA+rF/PwAAAECjdZM/AAAAoKogoL8AAACgro2WvwAAAEAUIIw/AAAAgO2Efr8AAABAqPd3PwAAAOCFyIw/AAAA4DZOk78AAACghJuUvwAAACA1I5M/AAAAALC5ir8AAACg1T+avwAAAGBVKJI/AAAAIO+XZL8AAAAgznyTPwAAAGDd6XK/AAAAAANwUj8AAADAx+aUvwAAAECieH+/AAAAwLDPnL8AAADgg4WSvwAAAMAOh4E/AAAAYIAvcr8AAADgKSOaPwAAAKCICEs/AAAA4Lh4cT8AAABgU/6VPwAAAOCFyGw/AAAAYISceL8AAABAnfZqPwAAAOBrWZw/AAAA4MFnHD8AAABAXv+SvwAAAGDAO2g/AAAAYGoteL8AAAAge8Z7PwAAAECYdHY/AAAAoDZPZ78AAACg6ix2PwAAAOBH5mK/AAAAoFzsfD8AAABgPhGKPwAAAIAQslE/AAAAYFmVqD8AAAAA/MOBPwAAAAC2OIO/AAAAoKkLgr8AAAAAOHubvwAAAICI8LA/AAAA4BUzkj8AAADgx/5+PwAAAECo94e/AAAAIA+ehz8AAADgsvmIvwAAAIA0JYu/AAAAoOtBlL8AAACAkMp9PwAAAKCujXY/AAAAQBzJkL8AAACAlkmGPwAAACD4ho8/AAAAIBMLfr8AAADgdUV7PwAAAOB1RZs/AAAAQLQNYz8AAABgai14vwAAAGD974U/AAAAgOSVo78AAABAR9BwPwAAAACEnXy/AAAAQMSQlD8AAAAglTWcvwAAAACZili/AAAAwIbFoL8AAACA8wOHPwAAAOAmy5G/AAAAQGfunb8AAABgvM6hPwAAAACLMaO/AAAAgGtChj8AAACgpKGHPwAAAADRvJE/AAAAQDU7nb8AAACgyiaTvwAAAKA6vI2/AAAAYAJyaj8AAAAA4lSBPwAAAGA3ZZk/AAAAADLkaL8AAABAqiGUvwAAAAB/Gxi/AAAAgCW3h78AAADgW9aavwAAAMDiapO/AAAAoDvRmz8AAAAAtjhjPwAAAEAat56/AAAAIEkTO78AAAAg6hVQvwAAAKBtbII/AAAAIAkHpb8AAAAgveRzvwAAAECS9Z2/AAAAQPQZmb8AAACg5K2dvwAAAODOkoW/AAAAABzibr8AAABg59WhvwAAAGCBRJC/AAAAIHdZRb8AAACAFTRWvwAAAIBrQna/AAAAAMooa78AAACg+8TFvwAAAEC9/G2/AAAAIHvGiz8AAACgj5yhvwAAAKBCZYK/AAAAgN7+YL8AAADgG8p0PwAAAMCrTZi/AAAAIKJglb8AAABAR9CQvwAAAIDEj5A/AAAAANG8YT8AAABALEySvwAAAEAhS6W/AAAAAOE/Qz8AAAAgccKSPwAAAGBfFHE/AAAA4Ooror8AAAAgl1+YPwAAAGD975U/AAAAQBu0kj8AAADga1msvwAAAOArTZY/AAAAgHzapT8AAADAlkhyPwAAAABDfIg/AAAAoNqplL8AAADgescvPwAAAKCfH6M/AAAAYJmhjr8AAACgNk+HPwAAAMDFvHi/AAAAgJHfe78AAAAAyigrPwAAAAAjdmW/AAAA4E/Ajz8AAAAge8aLPwAAAIDvlpC/AAAAAGJtfb8AAADgonZnPwAAAIDn7Ys/AAAA4N0AiT8AAABAIDaXvwAAACCRyHW/AAAAYMbSir8AAABgvyZaPwAAAAAjdoU/AAAAoFzsnL8AAAAAz6p/PwAAAKAXXnK/AAAAgFqqhj8AAADglUtOPwAAACDYaJI/AAAAwDiRjb8AAAAAKPiZPwAAAKDVJ5C/AAAAQHLvej8AAABgF1+GPwAAAGAhY58/AAAAgAOHGD8AAADgFDZOvwAAAACmtaG/AAAAYCfidz8AAAAAPw+SvwAAAIBmwIE/AAAA4Nh+pL8AAACAXNSivwAAAIB82oU/AAAAwC+ikr8AAABAiQaTvwAAAOA/PX6/AAAAQM+RkT8AAABgVBNUvwAAACDqFYA/AAAAgCohkj8AAACgbWyiPwAAAMBkrYu/AAAAoMkpjz8AAADASRGDPwAAAOCG3Xq/AAAAgESonL8AAABAZ+6tPwAAAABibV0/AAAAADdmjb8AAAAAQmeaPwAAAKD0MI8/AAAAINl9cD8AAAAA2qucvwAAACC8z6W/AAAAwMFPcj8AAABAUumHPwAAAIBKP4+/AAAAQBCzdT8AAABgzWZxvwAAACCFsnq/AAAAIHdZhT8AAACgJ+FzvwAAAABH6Y6/AAAAIMbTjj8AAADAijKXvwAAAADGu5Q/AAAAgHDEij8AAADgVlSWvwAAACDZfWC/AAAA4Eo+iz8AAACgngqVPwAAAOAkoaW/AAAAgO6Bgr8AAABgCQaRPwAAAACVHYK/AAAAIL75kb8AAACAkMqdvwAAAKBR658/AAAAoOxWkj8AAADAmrWYvwAAAAB5hKU/AAAA4JMIhL8AAAAAjomLvwAAAEDmwKM/AAAAgNLoVb8AAAAgnd6wPwAAAGDd6ZK/AAAAgCSiib8AAAAg/fBJPwAAAKD1LYO/AAAAgHZDg78AAACgMuKwvwAAAAAtYnQ/AAAAIHvGiz8AAAAAAUaGvwAAAEBugqS/AAAAwDMPSb8AAACgvhCIvwAAAADhP4O/AAAAYHqwib8AAACAp+GVPwAAAGDEqI6/AAAAIJzJor8AAABAz5GhvwAAACA0DmW/AAAAAL8nfr8AAACA7YSOvwAAAKBBaH4/AAAAYNu/hj8AAABgKQx0PwAAAGBYgDo/AAAAQMWlcj8AAACgO9FrPwAAAGDNZoE/AAAAAGoWkj8AAAAgYCqDvwAAAEAVNZo/AAAAYIFEoL8AAAAgwmZ4vwAAAMBqLHQ/AAAAgMSPoD8AAAAAizGTPwAAAMDm15m/AAAAQGkAcL8AAACA0uiFvwAAAGCZoY6/AAAAAANwUr8AAACA0uh1vwAAACCz+JS/AAAAwBL0lz8AAADgvg90PwAAAMADhpS/AAAA4GbXl78AAAAA5ayJPwAAAOCc35Q/AAAAwNZUiL8AAABAImBjvwAAAACqIpi/AAAAoMomc78AAABAvfxtPwAAAIB82pW/AAAAIP8ahr8AAACAI42LvwAAAEBFvo6/AAAAQFdTkr8AAACAoE2fPwAAACCXX4g/AAAAICWgYT8AAAAA1j6WvwAAAEC6pCU/AAAAYAkGkT8AAABAmYmUvwAAAMCOn40/AAAAQFdTQj8AAACgIUqBPwAAAMC3Y5M/AAAAoOXCmz8AAABgkLKTvwAAAOAUHpS/AAAAQCJggz8AAACATFFRPwAAAIBx2Yi/AAAAYNC+mT8AAABALWGQvwAAAKA70Xs/AAAAYCj3hT8AAAAAlR2CPwAAAEDvr34/AAAAwNDVj78AAACgvhBIvwAAAIAQsoG/AAAAAIkHh78AAADg8gVvPwAAAIB7xWe/AAAA4Ibdmr8AAABATFKFPwAAAICMXYc/AAAAwObXib8AAABg4EGLPwAAAKBoApg/AAAAoISblL8AAACgEd+JPwAAACDG026/AAAA4DU5pT8AAAAgkLN3PwAAAMBEp3i/AAAAwLDPjL8AAABA1j1yvwAAAGBYgIo/AAAAQMa6YD8AAABAcMWOPwAAAOAWSKC/AAAA4BZIkL8AAAAg+pixvwAAAKAfOJ8/AAAAgPiFez8AAADgkd6XvwAAAABT/2k/AAAAQBU1qr8AAAAAOGOhPwAAAEB4boM/AAAAwGkXlj8AAABgsLiGPwAAAIC9+2k/AAAAQMkSib8AAABgY4EXPwAAAODigo0/AAAAQFHUmb8AAABAHMmQvwAAAMCARpg/AAAAAFl+kr8AAAAgJIujPwAAAMDhVaU/AAAA4EA6kr8AAABgOHqHvwAAAGBMap8/AAAAYK+jqD8AAACgo4yZvwAAAADrQ4y/AAAA4BQ2fj8AAADguHihPwAAAACloJO/AAAAYP3vlb8AAADAscyQPwAAACCRyJW/AAAAIMJmiL8AAAAg6OujPwAAAEA1O40/AAAAQBLdcT8AAAAgdkSXPwAAAACwoZA/AAAA4Ibdmj8AAADAT6iVPwAAAMAd9ZS/AAAAYPLumL8AAABg4muXPwAAAIDT/YO/AAAAAD3llb8AAACgV2qYPwAAAOCujJI/AAAA4I1xgT8AAABgoDWFPwAAAIBx2Wg/AAAAoJ8fcz8AAACg60F0vwAAACA2OFE/AAAAwLZOpb8AAADgFB50PwAAAGBqLZi/AAAAQOgDjj8AAAAgrEx0vwAAAEAAMJQ/AAAAYAkGcb8AAABALEyiPwAAAICteJg/AAAAINLpWb8AAACAdUaPvwAAAGBjgVe/AAAAQKN1c78AAACgVBKgvwAAAEAxzoY/AAAAQJmJdD8AAABAjoh3vwAAAECkiqG/AAAAQJMKnD8AAABgAnKKvwAAAOCNcWE/AAAAYPZbb78AAABgHfaYvwAAAGA8530/AAAAwMfmhD8AAACg1SeQvwAAAIAjjWu/AAAAAIWakD8AAABgRaWgvwAAAKBc7Hw/AAAAgEo/fz8AAABgN2WpPwAAAMCGxYA/AAAAYLu5k78AAADAl11wvwAAACDzBHs/AAAAYE6Um78AAADgBJtSPwAAAOBb1oo/AAAAIFmWfL8AAABABbKIPwAAAGBump4/AAAAgIfbYr8AAAAA5ayZvwAAAOBx2HQ/AAAA4NmToj8AAACAMxBtPwAAAIB972M/AAAAoPUtY78AAACAUdOFvwAAAGBvl5K/AAAAAObBl78AAAAgNSOTPwAAAMCFsJK/AAAAYHQZh78AAAAga0NqvwAAACAqIoa/AAAA4KFhiT8AAADgw5GYvwAAAKCujZa/AAAAQHmDQT8AAACguqORvwAAAEDVKIS/AAAAoLMPez8AAABg59VxvwAAAOCtd5S/AAAAwItHpT8AAACgZ+15vwAAACD98Im/AAAAYPLuqD8AAABAaOuhPwAAAICrTow/AAAAYIAvYj8AAAAgOZCJvwAAAOAdDY+/AAAAwMtTmz8AAAAA28CKvwAAACCAMJa/AAAAQFhogL8AAABgEeCdvwAAAGBUE5S/AAAAwMbRhr8AAABAjF6bvwAAAMAYi2o/AAAAwA1yY78AAADANCR3PwAAAADXU7Q/AAAAwMfmpD8AAAAg/xqGPwAAAECZiWQ/AAAAYIOHqr8AAABg91ijPwAAAMDCZKA/AAAAQN8sfb8AAABAyieXvwAAACA6pZe/AAAAYBdflr8AAADAfhycvwAAACDd6pa/AAAA4Eo+m78AAACgCjN5vwAAAGDhVom/AAAAwON/ob8AAACAl16EPwAAAEDklne/AAAAAISdbD8AAACgd3CbPwAAACDvl5Q/AAAAwLq7mz8AAACgVBLwvgAAAMBIFH8/AAAAgOgCij8AAAAAYm2dPwAAACDugoa/AAAAwGSti78AAAAAT5KjvwAAAICR33s/AAAAIHLXoD8AAADA12mmvwAAAAA3Zp2/AAAAIMjlYL8AAACgRtJoPwAAAEB5g2G/AAAAwLDPTL8AAABAz5GhPwAAAKDc02C/AAAAgL37OT8AAACA/xmSPwAAAEDwrGI/AAAAwC+igr8AAACgO9F7vwAAAGDAO5g/AAAAQFzVdr8AAABgai2IvwAAAACOiau/"}]}]}, "source_code": "class SymbolSimilarity(EmbeddingSimilarity):\n    def __init__(\n        self,\n        symbol_embedding_manager: SymbolCodeEmbeddingHandler,\n        norm_type: NormType = NormType.L2,\n    ):\n        \"\"\"\n        Initialize SymbolSimilarity\n\n        Args:\n            symbol_embedding_manager: A CodeEmbeddingManager\n            norm_type (NormType): The norm type to use for calculating similarity\n\n        Returns:\n            An instance of SymbolSimilarity\n        \"\"\"\n        self.embedding_handler: SymbolCodeEmbeddingHandler = symbol_embedding_manager\n        self.embedding_provider: EmbeddingProvider = symbol_embedding_manager.embedding_provider\n        self.norm_type = norm_type\n        supported_symbols = self.embedding_handler.get_all_supported_symbols()\n        self.index_to_symbol = {i: symbol for i, symbol in enumerate(supported_symbols)}\n        self.symbol_to_index = {symbol: i for i, symbol in enumerate(supported_symbols)}\n        self.available_symbols: Optional[Set[Symbol]] = None\n\n    def set_available_symbols(self, available_symbols: Set[Symbol]):\n        \"\"\"\n        Set the available symbols to use for similarity calculation\n\n        Args:\n            available_symbols (Set[Symbol]): The available symbols to\n                use for similarity calculation\n        \"\"\"\n        self.available_symbols = available_symbols\n\n    def get_available_symbols(self) -> List[Symbol]:\n        \"\"\"\n        Set the available symbols to use for similarity calculation\n\n        Args:\n            available_symbols (Set[Symbol]): The available symbols to\n                use for similarity calculation\n        \"\"\"\n        return [\n            symbol\n            for symbol in self.symbol_to_index\n            if not self.available_symbols or symbol in self.available_symbols\n        ]\n\n    def get_query_similarity_dict(self, query_text: str) -> Dict[Symbol, float]:\n        \"\"\"\n        Get the similarity scores of all symbols for the query_text\n\n        Args:\n            query_text (str): The query text\n\n        Returns:\n            A dictionary mapping each symbol's uri to its similarity score with the query\n        \"\"\"\n        query_embedding = self.embedding_provider.build_embedding(query_text)\n\n        # Compute the similarity of the query to all symbols\n        similarity_scores = self._calculate_query_similarity_vec(query_embedding)\n\n        similarity_dict = {\n            self.index_to_symbol[i]: similarity_scores[i]\n            for i in range(len(self.index_to_symbol))\n            if (not self.available_symbols) or self.index_to_symbol[i] in self.available_symbols\n        }\n        return similarity_dict\n\n    def get_nearest_entries_for_query(self, query_text: str, k: int = 10) -> Dict[Symbol, float]:\n        \"\"\"\n        Get the k most similar symbols to the query_text\n        Args:\n            query_text (str): The query text\n            k (int): The number of similar symbols to return\n        Returns:\n            A dictionary mapping the k most similar symbols to their similarity score\n        \"\"\"\n        query_embedding = self.embedding_provider.build_embedding(query_text)\n        # Compute the similarity of the query to all symbols\n        similarity_scores = self._calculate_query_similarity_vec(query_embedding)\n\n        if self.available_symbols is not None:\n            # Filter the indices by available symbols\n            available_indices = [\n                i\n                for i in range(len(self.index_to_symbol))\n                if self.index_to_symbol[i] in self.available_symbols\n            ]\n            # Get the similarity scores for the available symbols\n            available_similarity_scores = similarity_scores[available_indices]\n            # Get the indices of the k symbols with the highest similarity scores among the available symbols\n            top_k_indices_in_available = np.argsort(available_similarity_scores)[-k:]\n            # Convert these indices back to the indices in the original list of symbols\n            top_k_indices = [available_indices[i] for i in top_k_indices_in_available]\n        else:\n            # Get the indices of the k symbols with the highest similarity scores\n            top_k_indices = np.argsort(similarity_scores)[-k:]\n\n        # Return the corresponding symbols\n        return {\n            self.index_to_symbol[index]: similarity_scores[index]\n            for index in reversed(top_k_indices)\n        }\n\n    def _get_ordered_embeddings(self) -> np.ndarray:\n        \"\"\"\n        Get the embeddings in the correct order\n\n        Returns:\n            A numpy array containing the ordered embeddings\n        \"\"\"\n        return np.array(\n            [\n                self.embedding_handler.get_embedding(symbol).vector\n                for symbol in self.index_to_symbol.values()\n            ]\n        )\n\n    def _calculate_query_similarity_vec(self, query_embedding: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Calculate the similarity scores of the query embedding with all symbol embeddings\n        Args:\n            query_embedding (np.ndarray): The query embedding\n            norm_type (str): The type of normalization ('l2' for L2 norm, 'softmax' for softmax)\n        Returns:\n            A numpy array containing the similarity scores\n        \"\"\"\n        embeddings = self._get_ordered_embeddings()\n\n        # Normalize the embeddings and the query embedding\n        embeddings_norm = self._normalize_embeddings(embeddings, self.norm_type)\n        query_embedding_norm = self._normalize_embeddings(\n            query_embedding[np.newaxis, :], self.norm_type\n        )[0]\n\n        # Compute the dot product between normalized embeddings and query\n        similarity_scores = np.dot(embeddings_norm, query_embedding_norm)\n\n        return similarity_scores\n\n    @staticmethod\n    def _normalize_embeddings(embeddings: np.ndarray, norm_type: NormType) -> np.ndarray:\n        \"\"\"\n        Normalize the embeddings.\n        Args:\n            embeddings (np.ndarray): The embeddings\n            norm_type (NormType): The type of normalization (L1, L2, or softmax)\n        Returns:\n            The normalized embeddings\n        \"\"\"\n        if norm_type == NormType.L1:\n            norm = np.sum(np.abs(embeddings), axis=1, keepdims=True)\n            return embeddings / norm\n        elif norm_type == NormType.L2:\n            return embeddings / np.linalg.norm(embeddings, axis=1, keepdims=True)\n        elif norm_type == NormType.SOFTMAX:\n            e_x = np.exp(embeddings - np.max(embeddings, axis=1, keepdims=True))\n            return e_x / np.sum(e_x, axis=1, keepdims=True)\n        else:\n            raise ValueError(f\"Invalid normalization type {norm_type}\")\n", "summary": "The `SymbolSimilarity` class computes similarity scores between query texts and symbols using embeddings. It relies on a `SymbolCodeEmbeddingHandler` and an optional `NormType` to determine similarity. Users can retrieve the most similar symbols for a specific query and create a dictionary mapping similarity scores to each symbol. The class allows users to set available symbols for similarity calculation and supports various similarity metrics. However, its accuracy depends on the quality of pre-trained embeddings and the selected norm type. If the embeddings do not accurately represent symbols, or the norm type is unsuitable, the similarity scores might be inaccurate.\n\nHere's an example:\n\n```python\nimport numpy as np\nfrom automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\nfrom automata.core.embedding.embedding_types import EmbeddingProvider, NormType\nfrom automata.core.embedding.symbol_similarity import SymbolSimilarity\n\n# Instance of a SymbolCodeEmbeddingHandler\nembedding_handler = SymbolCodeEmbeddingHandler(embedding_db=embedding_db, embedding_provider=embedding_provider)\n\n# Create an instance of SymbolSimilarity\nsymbol_similarity = SymbolSimilarity(symbol_embedding_manager=embedding_handler, norm_type=NormType.L2)\n\n# Set available symbols\nsymbol_similarity.set_available_symbols(available_symbols)\n\n# Get the nearest entries for a query\nnearest_entries = symbol_similarity.get_nearest_entries_for_query(\"example query\", k=5)\n\n# Get the query similarity dictionary\nquery_similarity_dict = symbol_similarity.get_query_similarity_dict(\"example query\")\n```\n", "context": "\n    Generate the documentation for SymbolSimilarity using the context shown below -\n  Building context for primary symbol - automata.core.embedding.symbol_similarity.SymbolSimilarity -\n  \n    Import Statements:\n      import logging\n      import numpy as np\n      from typing import Dict, List, Optional, Set\n      from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n      from automata.core.symbol.symbol_types import Symbol\n      from .embedding_types import EmbeddingProvider, EmbeddingSimilarity, NormType\n      \n      # SymbolSimilarity\n      \n      `SymbolSimilarity` is a class providing functionality to compute similarity scores between given query texts and symbols using embeddings. You can retrieve the most similar symbols for a specific query and create a dictionary mapping the similarity scores to each symbol. Additionally, you have the flexibility to set the available symbols for similarity calculation.\n      \n      ## Overview\n      \n      The `SymbolSimilarity` class takes a `SymbolCodeEmbeddingHandler`, and an optional `NormType` to calculate similarity between query texts and symbols. It offers methods to get available symbols, get the nearest symbols for a query, and get the similarity dictionary for a query. The class uses embeddings and a variety of similarity metrics for determining the similarity between query texts and symbols.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.embedding.embedding_types.EmbeddingSimilarity`\n      - `automata.core.symbol.search.symbol_search.SymbolSearch`\n      - `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n      - `automata.core.embedding.embedding_types.NormType`\n      \n      ## Example\n      \n      The following example demonstrates how to create an instance of `SymbolSimilarity` using a predefined `SymbolCodeEmbeddingHandler`.\n      \n      ```python\n      import numpy as np\n      from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n      from automata.core.embedding.embedding_types import EmbeddingProvider, NormType\n      from automata.core.embedding.symbol_similarity import SymbolSimilarity\n      \n      # Instance of a SymbolCodeEmbeddingHandler\n      embedding_handler = SymbolCodeEmbeddingHandler(embedding_db=embedding_db, embedding_provider=embedding_provider)\n      \n      # Create an instance of SymbolSimilarity\n      symbol_similarity = SymbolSimilarity(symbol_embedding_manager=embedding_handler, norm_type=NormType.L2)\n      \n      # Set available symbols\n      symbol_similarity.set_available_symbols(available_symbols)\n      \n      # Get the nearest entries for a query\n      nearest_entries = symbol_similarity.get_nearest_entries_for_query(\"example query\", k=5)\n      \n      # Get the query similarity dictionary\n      query_similarity_dict = symbol_similarity.get_query_similarity_dict(\"example query\")\n      ```\n      \n      ## Limitations\n      \n      - The primary limitation of `SymbolSimilarity` is its reliance on pre-trained embeddings, which means the quality of the similarity scores depends on the quality of the embeddings and the selected norm type. If embeddings do not accurately represent the symbols or the norm type is not suitable for the given problem, the similarity scores might not be as accurate.\n      - As `SymbolSimilarity` uses `SymbolCodeEmbeddingHandler` to handle embeddings, if `SymbolCodeEmbeddingHandler` is not properly constructed or initialized, the class may not provide the desired results.\n      \n      ## Follow-up Questions:\n      \n      - How can we extend `SymbolSimilarity` for other types of embeddings or similarity measurements?\n      \n    Methods:\n      def __init__(\n              self,\n              symbol_embedding_manager: SymbolCodeEmbeddingHandler,\n              norm_type: NormType = NormType.L2,\n          ):\n              \"\"\"\n              Initialize SymbolSimilarity\n      \n              Args:\n                  symbol_embedding_manager: A CodeEmbeddingManager\n                  norm_type (NormType): The norm type to use for calculating similarity\n      \n              Returns:\n                  An instance of SymbolSimilarity\n              \"\"\"\n              self.embedding_handler: SymbolCodeEmbeddingHandler = symbol_embedding_manager\n              self.embedding_provider: EmbeddingProvider = symbol_embedding_manager.embedding_provider\n              self.norm_type = norm_type\n              supported_symbols = self.embedding_handler.get_all_supported_symbols()\n              self.index_to_symbol = {i: symbol for i, symbol in enumerate(supported_symbols)}\n              self.symbol_to_index = {symbol: i for i, symbol in enumerate(supported_symbols)}\n              self.available_symbols: Optional[Set[Symbol]] = None\n      \n          \n      def get_available_symbols(self) -> List[Symbol]:\n              \"\"\"\n              Set the available symbols to use for similarity calculation\n      \n              Args:\n                  available_symbols (Set[Symbol]): The available symbols to\n                      use for similarity calculation\n              \"\"\"\n              return [\n                  symbol\n                  for symbol in self.symbol_to_index\n                  if not self.available_symbols or symbol in self.available_symbols\n              ]\n      \n          \n      def get_nearest_entries_for_query(self, query_text: str, k: int = 10) -> Dict[Symbol, float]:\n              \"\"\"\n              Get the k most similar symbols to the query_text\n              Args:\n                  query_text (str): The query text\n                  k (int): The number of similar symbols to return\n              Returns:\n                  A dictionary mapping the k most similar symbols to their similarity score\n              \"\"\"\n              query_embedding = self.embedding_provider.build_embedding(query_text)\n              # Compute the similarity of the query to all symbols\n              similarity_scores = self._calculate_query_similarity_vec(query_embedding)\n      \n              if self.available_symbols is not None:\n                  # Filter the indices by available symbols\n                  available_indices = [\n                      i\n                      for i in range(len(self.index_to_symbol))\n                      if self.index_to_symbol[i] in self.available_symbols\n                  ]\n                  # Get the similarity scores for the available symbols\n                  available_similarity_scores = similarity_scores[available_indices]\n                  # Get the indices of the k symbols with the highest similarity scores among the available symbols\n                  top_k_indices_in_available = np.argsort(available_similarity_scores)[-k:]\n                  # Convert these indices back to the indices in the original list of symbols\n                  top_k_indices = [available_indices[i] for i in top_k_indices_in_available]\n              else:\n                  # Get the indices of the k symbols with the highest similarity scores\n                  top_k_indices = np.argsort(similarity_scores)[-k:]\n      \n              # Return the corresponding symbols\n              return {\n                  self.index_to_symbol[index]: similarity_scores[index]\n                  for index in reversed(top_k_indices)\n              }\n      \n          \n      def get_query_similarity_dict(self, query_text: str) -> Dict[Symbol, float]:\n              \"\"\"\n              Get the similarity scores of all symbols for the query_text\n      \n              Args:\n                  query_text (str): The query text\n      \n              Returns:\n                  A dictionary mapping each symbol's uri to its similarity score with the query\n              \"\"\"\n              query_embedding = self.embedding_provider.build_embedding(query_text)\n      \n              # Compute the similarity of the query to all symbols\n              similarity_scores = self._calculate_query_similarity_vec(query_embedding)\n      \n              similarity_dict = {\n                  self.index_to_symbol[i]: similarity_scores[i]\n                  for i in range(len(self.index_to_symbol))\n                  if (not self.available_symbols) or self.index_to_symbol[i] in self.available_symbols\n              }\n              return similarity_dict\n      \n          \n      def set_available_symbols(self, available_symbols: Set[Symbol]):\n              \"\"\"\n              Set the available symbols to use for similarity calculation\n      \n              Args:\n                  available_symbols (Set[Symbol]): The available symbols to\n                      use for similarity calculation\n              \"\"\"\n              self.available_symbols = available_symbols\n      \n          \n  Building context for related symbols -\n  \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.embedding.embedding_types.EmbeddingSimilarity\n    \n        `EmbeddingSimilarity` is an abstract base class providing an interface for finding the most similar symbols to a given query text in a codebase using embeddings, which are numerical representations of text data. Primary methods in this class are `get_nearest_entries_for_query` and `get_query_similarity_dict`. Implementations of this class cater to different types of similarity calculations and embedding providers. However, the class itself serves as an interface, and its effectiveness relies on the specific implementation, the choice of embedding provider, and the type of similarity calculation. \n        \n        Example:\n        \n        ```python\n        import numpy as np\n        from automata.core.embedding.embedding_types import EmbeddingSimilarity\n        \n        class CustomEmbeddingSimilarity(EmbeddingSimilarity):\n            \n            def __init__(self, embedding_handler):\n                self.embedding_handler = embedding_handler\n            \n            def get_nearest_entries_for_query(self, query_text: str, k_nearest: int) -> Dict[Symbol, float]:\n                # Implement custom logic to find k nearest entries\n                pass\n                \n            def get_query_similarity_dict(self, query_text: str) -> Dict[Symbol, float]:\n                # Implement custom logic to compute similarity between query and symbols\n                pass\n        \n        # Create an instance\n        embedding_handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        custom_similarity = CustomEmbeddingSimilarity(embedding_handler)\n        ```\n        \n      Methods:\n        get_nearest_entries_for_query(self, query_text: str, k_nearest: int) -> Dict[Any, float]\n        \n        get_query_similarity_dict(self, query_text: str) -> Dict[Any, float]\n        \n    automata.tests.unit.conftest.symbol_searcher\n    \n        @pytest.fixture\n        def symbol_searcher(mocker, symbol_graph_mock):\n            symbol_similarity_mock = mocker.MagicMock(spec=SymbolSimilarity)\n            symbol_similarity_mock.embedding_handler = mocker.MagicMock(spec=SymbolCodeEmbeddingHandler)\n            symbol_rank_config_mock = mocker.MagicMock(spec=SymbolRankConfig)\n        \n            return SymbolSearch(\n                symbol_graph_mock,\n                symbol_similarity_mock,\n                symbol_rank_config_mock,\n            )\n        \n        \n    automata.core.symbol.search.symbol_search.SymbolSearch\n    \n        `SymbolSearch` is a class used to search for symbols in a `SymbolGraph` by processing NLP-formatted queries and providing search results in various formats depending on the query type. The class utilizes a symbol similarity algorithm for ranking symbols according to relevance and a SymbolRank algorithm for computing a global symbol ranking. To use `SymbolSearch`, first initialize the necessary objects, such as `SymbolGraph` and `SymbolSimilarity`, then create a `SymbolSearch` object and process a query to obtain the search results.\n        \n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        from automata.core.embedding.symbol_similarity import SymbolSimilarity\n        from automata.core.symbol.search.symbol_search import SymbolSearch\n        \n        # Initialize necessary objects\n        symbol_graph = SymbolGraph()\n        symbol_similarity = SymbolSimilarity()\n        \n        # Create the SymbolSearch object\n        symbol_searcher = SymbolSearch(symbol_graph, symbol_similarity)\n        \n        # Process a query and get the search results\n        query = \"type:symbol_references <symbol_uri>\"\n        result = symbol_searcher.process_query(query)\n        ```\n        \n        Note that `SymbolSearch` relies on the availability of symbols in the `SymbolGraph` and `SymbolSimilarity` objects, and will produce incomplete or incorrect results if the necessary data is missing or the input query does not follow the expected format.\n        \n      Class Docstring:\n        Searches for symbols in a SymbolGraph\n        \n      Methods:\n        def __init__(\n                self,\n                symbol_graph: SymbolGraph,\n                symbol_similarity: SymbolSimilarity,\n                symbol_rank_config: Optional[SymbolRankConfig],\n                code_subgraph: Optional[SymbolGraph.SubGraph] = None,\n                *args,\n                **kwargs,\n            ):\n                \"\"\"\n                Args:\n                    symbol_graph (SymbolGraph): A SymbolGraph\n                    symbol_similarity (SymbolSimilarity): A SymbolSimilarity object\n                    symbol_rank_config (Optional[SymbolRankConfig]): A SymbolRankConfig object\n                    code_subgraph (Optional[SymbolGraph.SubGraph]): A subgraph of the SymbolGraph\n                \"\"\"\n        \n                if not code_subgraph:\n                    code_subgraph = symbol_graph.get_rankable_symbol_subgraph(\n                        kwargs.get(\"flow_rank\", \"bidirectional\")\n                    )\n                else:\n                    if not code_subgraph.parent == symbol_graph:\n                        raise ValueError(\"code_subgraph must be a subgraph of symbol_graph\")\n        \n                graph_symbols = symbol_graph.get_all_available_symbols()\n                embedding_symbols = symbol_similarity.embedding_handler.get_all_supported_symbols()\n                available_symbols = set(graph_symbols).intersection(set(embedding_symbols))\n                SymbolSearch.filter_graph(code_subgraph.graph, available_symbols)\n        \n                # TODO - Do we need to filter the SymbolGraph as well?\n                self.symbol_graph = symbol_graph\n                self.symbol_similarity = symbol_similarity\n                symbol_similarity.set_available_symbols(available_symbols)\n                self.symbol_rank = SymbolRank(code_subgraph.graph, config=symbol_rank_config)\n        \n            \n        exact_search(self, pattern: str) -> ExactSearchResult\n        \n        filter_graph(graph: nx.DiGraph, available_symbols: Set[Symbol]) -> None\n        \n        find_pattern_in_modules(pattern: str) -> Dict[str, List[int]]\n        \n        process_query(self, query: str) -> Union[SymbolReferencesResult, SymbolRankResult, SourceCodeResult, ExactSearchResult,]\n        \n        retrieve_source_code_by_symbol(self, symbol_uri: str) -> SourceCodeResult\n        \n        shifted_z_score_sq(values: Union[List[float], np.ndarray]) -> np.ndarray\n        \n        symbol_rank_search(self, query: str) -> SymbolRankResult\n        \n        symbol_references(self, symbol_uri: str) -> SymbolReferencesResult\n        \n        transform_dict_values(dictionary: Dict[Any, float], func: Callable[[List[float]], np.ndarray]\n            ) -> None\n        \n    automata.tests.unit.test_symbol_similarity.test_get_nearest_symbols_for_query\n    \n        def test_get_nearest_symbols_for_query(\n            monkeypatch, mock_embedding, mock_simple_method_symbols, temp_output_filename\n        ):\n            # Mocking symbols and their embeddings\n            symbol1 = mock_simple_method_symbols[0]\n            symbol2 = mock_simple_method_symbols[1]\n            symbol3 = mock_simple_method_symbols[2]\n        \n            embedding1 = SymbolCodeEmbedding(\n                symbol=symbol1, vector=np.array([1, 0, 0, 0]), source_code=\"symbol1\"\n            )\n            embedding2 = SymbolCodeEmbedding(\n                symbol=symbol2, vector=np.array([0, 1, 0, 0]), source_code=\"symbol2\"\n            )\n            embedding3 = SymbolCodeEmbedding(\n                symbol=symbol3, vector=np.array([0, 0, 1, 0]), source_code=\"symbol3\"\n            )\n        \n            # Mock JSONVectorDatabase methods\n            embedding_db = JSONVectorDatabase(temp_output_filename)\n            embedding_db.add(embedding1)\n            embedding_db.add(embedding2)\n            embedding_db.add(embedding3)\n        \n            # Create an instance of the class\n            mock_provider = MagicMock(EmbeddingProvider)\n            cem = SymbolCodeEmbeddingHandler(embedding_db=embedding_db, embedding_provider=mock_provider)\n        \n            symbol_similarity = SymbolSimilarity(cem)\n        \n            # Test with query_text that is most similar to symbol1\n            cem.embedding_provider.build_embedding.return_value = np.array([1, 0, 0, 0])\n            result = symbol_similarity.get_nearest_entries_for_query(\"symbol1\", k=1)\n            assert list(result.keys()) == [symbol1]\n        \n            # Test with query_text that is most similar to symbol2\n            cem.embedding_provider.build_embedding.return_value = np.array([0, 1, 0, 0])\n            result = symbol_similarity.get_nearest_entries_for_query(\"symbol2\", k=1)\n            assert list(result.keys()) == [symbol2]\n        \n            # Test with query_text that is most similar to symbol3\n            cem.embedding_provider.build_embedding.return_value = np.array([0, 0, 1, 0])\n            result = symbol_similarity.get_nearest_entries_for_query(\"symbol3\", k=1)\n            assert list(result.keys()) == [symbol3]\n        \n        \n    automata.core.symbol.symbol_types.SymbolReference.__eq__\n    \n      Methods:\n        __eq__(self, other) -> None\n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.core.database.vector.VectorDatabaseProvider\n    \n        `VectorDatabaseProvider` is an abstract base class designed for implementing custom vector database providers. It provides a basic structure for a vector storage system and requires subclasses to implement the `calculate_similarity()` and `get_all_symbols()` abstract methods. The former computes the similarity between a given vector and all stored vectors, while the latter retrieves a list of all symbols in the database. However, the base class does not offer built-in functionality for adding, updating, or removing symbols and their embeddings, requiring implementers to handle these operations themselves. A basic example implementation of the `VectorDatabaseProvider` class can be seen in the provided code snippet.\n        \n      Class Docstring:\n        Abstract base class for different types of vector database providers.\n        \n      Methods:\n        calculate_similarity(self, embedding: SymbolEmbedding) -> List[Dict[Symbol, float]]\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n    automata.core.symbol.symbol_types.SymbolReference\n    \n        `SymbolReference` is a class representing a reference to a symbol in a file, used for managing references to symbols within a codebase. It offers utility methods for comparing and hashing symbol references based on their URI, line number, and column number. In conjunction with other symbol-related classes, it helps track and manage references to symbols in files based on their location and usage. However, there is a potential limitation of causing collisions when the same symbol is referenced in different files at the same location (line and column). This is rare, but important to consider when working with multiple symbol references across files.\n        \n        Example usage: \n        ```python\n        from automata.core.symbol.symbol_types import SymbolReference\n        from automata.core.symbol.parser import parse_symbol\n        \n        symbol_uri = \"example_uri\"\n        line_number = 10\n        column_number = 5\n        symbol = parse_symbol(symbol_uri)\n        \n        symbol_ref1 = SymbolReference(symbol, line_number, column_number)\n        symbol_ref2 = SymbolReference(symbol, line_number + 1, column_number)\n        \n        assert symbol_ref1 != symbol_ref2\n        assert hash(symbol_ref1) != hash(symbol_ref2)\n        \n        symbol_ref3 = SymbolReference(symbol, line_number, column_number)\n        assert symbol_ref1 == symbol_ref3\n        ```\n        \n      Class Docstring:\n        Represents a reference to a symbol in a file\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n  Building context for dependencies -\n  \n    automata.core.embedding.embedding_types.NormType\n    \n        `NormType` is an enumeration class representing various normalization techniques available for calculating similarity in a `SymbolSimilarity` object, offering three options: L1, L2, and softmax. These can be used by the `SymbolSimilarity` class while computing similarities between symbols in a related codebase. However, using different normalization techniques may lead to potential limitations such as differences in interpretation and efficiency of similarity calculations. For example:\n        \n        ```python\n        from automata.core.embedding.symbol_similarity import SymbolSimilarity\n        from automata.core.embedding.embedding_types import NormType\n        from automata.core.embedding.manager.code_embedding_manager import SymbolCodeEmbeddingHandler\n        \n        symbol_embedding_manager = SymbolCodeEmbeddingHandler()\n        custom_norm_type = NormType.L1\n        \n        symbol_similarity = SymbolSimilarity(symbol_embedding_manager, custom_norm_type)\n        ```\n        Possible follow-up questions include exploring other normalization techniques to add to the `NormType` class and understanding the impact of different normalization techniques on the performance and interpretation of similarity calculations.\n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler.get_all_supported_symbols\n    \n      Class Docstring:\n        Get all the symbols in the database.\n        \n        Returns:\n        List[Symbol]: List of all the symbols in the database\n        \n      Methods:\n        get_all_supported_symbols(self) -> List[Symbol]\n        \n    automata.core.embedding.embedding_types.EmbeddingProvider\n    \n        `EmbeddingProvider` is an abstract base class that serves as an interface for obtaining mathematical representations called embeddings for symbols, used in tasks such as similarity search, ranking, and other natural language processing-related work. Its single abstract method, `build_embedding`, should be implemented by all subclasses to provide specific embedding implementations. Users must create their own classes that inherit from `EmbeddingProvider` and implement these methods, which might be a limitation for those unfamiliar with custom classes and abstract methods.\n        \n        Here is an example of using the `OpenAIEmbedding` class, a concrete implementation of `EmbeddingProvider`:\n        \n        ```python\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        import numpy as np\n        \n        symbol_source = \"This is an example of a Python function.\"\n        embedding_provider = OpenAIEmbedding() \n        embedding = embedding_provider.build_embedding(symbol_source)\n        \n        # Check if the generated embedding is a numpy array\n        assert isinstance(embedding, np.ndarray)\n        ```\n        Performance and accuracy of embeddings depend on the specific model and approach used in the concrete implementation of `EmbeddingProvider`.\n        \n      Class Docstring:\n        A class to provide embeddings for symbols\n        \n      Methods:\n        build_embedding(self, symbol_source: str) -> np.ndarray\n        \n    automata.core.embedding.embedding_types.EmbeddingProvider.build_embedding\n    \n      Methods:\n        build_embedding(self, symbol_source: str) -> np.ndarray\n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler.get_embedding\n    \n      Class Docstring:\n        Get the embedding of a symbol.\n        \n        Args:\n        symbol (Symbol): Symbol to get the embedding for\n        \n        Returns:\n        Embedding: The embedding of the symbol\n        \n      Methods:\n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.graph`/GraphBuilder#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.graph", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "GraphBuilder", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# GraphBuilder\n\n`GraphBuilder` is a class that enables the construction of a symbol graph from an `Index` object. The graph representation aids in exploring symbol relationships within source code.\n\n## Overview\n\nGiven an `Index` object as input, `GraphBuilder` processes the relationships and occurrences of each symbol in the index. The resulting graph is a networkx `MultiDiGraph` object, allowing for the identification of symbol patterns and relationships within the codebase.\n\nBy default, `GraphBuilder` does not include caller-callee relationships, for performance reasons. However, this feature can be enabled upon instantiation with the `build_caller_relationships` flag set to `True`.\n\n## Related Symbols\n\n- `automata.core.symbol.graph.SymbolGraph`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.parser.parse_symbol`\n\n## Example\n\nThe following example demonstrates how to create a `GraphBuilder` instance and build a graph from an `Index` object.\n\n```python\nfrom automata.core.symbol.graph import GraphBuilder\nfrom automata.core.symbol.scip_pb2 import Index\n\nindex = Index()  # Assuming a populated index object.\nbuild_caller_relationships = True  # Optional\ngraph_builder = GraphBuilder(index, build_caller_relationships)\ngraph = graph_builder.build_graph()\n```\n\n## Limitations\n\n`GraphBuilder` may exhibit performance-related limitations, especially when the `build_caller_relationships` flag is set to `True`. This can lead to significantly longer processing times, as it involves an expensive operation to compute the caller-callee relationships.\n\n## Follow-up Questions:\n\n- Are there any ways to optimize the caller-callee relationship computation within the `GraphBuilder`?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class GraphBuilder:\n    \"\"\"\n    Builds a symbol graph from an Index.\n    \"\"\"\n\n    def __init__(self, index: Index, build_caller_relationships: bool = False):\n        \"\"\"\n        Args:\n            index (Index): An Index object\n            build_caller_relationships (bool, optional): Whether to build\n                caller-callee relationships. Defaults to False.\n        \"\"\"\n        self.index = index\n        self.build_caller_relationships = build_caller_relationships\n        self._graph = nx.MultiDiGraph()\n\n    def build_graph(self):\n        \"\"\"\n        Builds the graph from the index\n        \"\"\"\n        for document in self.index.documents:\n            self._add_file_vertices(document)\n            self._add_symbol_vertices(document)\n            self._process_relationships(document)\n            self._process_occurrences(document)\n            if self.build_caller_relationships:\n                self._process_caller_callee_relationships(document)\n\n        return self._graph\n\n    def _add_file_vertices(self, document: Any):\n        \"\"\"\n        Adds the file vertices to the graph\n\n        Args:\n            document (Any): A Document object\n        \"\"\"\n        self._graph.add_node(\n            document.relative_path,\n            file=SymbolFile(document.relative_path, occurrences=document.occurrences),\n            label=\"file\",\n        )\n\n    def _add_symbol_vertices(self, document: Any):\n        \"\"\"\n        Adds the symbol vertices to the graph\n\n        Args:\n            document (Any): A Document object\n        \"\"\"\n        for symbol_information in document.symbols:\n            try:\n                symbol = parse_symbol(symbol_information.symbol)\n            except Exception as e:\n                logger.error(f\"Parsing symbol {symbol_information.symbol} failed with error {e}\")\n                continue\n\n            self._graph.add_node(symbol, label=\"symbol\")\n            self._graph.add_edge(document.relative_path, symbol, label=\"contains\")\n\n    def _process_relationships(self, document: Any):\n        \"\"\"\n        Processes the relationships in the local graph\n\n        Args:\n            document (Any): A Document object\n        \"\"\"\n        for symbol_information in document.symbols:\n            relationship_manager = _RelationshipManager(self._graph, symbol_information)\n            relationship_manager.process()\n\n    def _process_occurrences(self, document: Any):\n        \"\"\"\n        Processes the occurrences in the local graph\n\n        Args:\n            document (Any): A Document object\n        \"\"\"\n        occurrence_manager = _OccurrenceManager(self._graph, document)\n        occurrence_manager.process()\n\n    def _process_caller_callee_relationships(self, document: Any):\n        \"\"\"\n        Processes the caller-callee relationships in the local graph\n\n        Args:\n            document (Any): A Document object\n        \"\"\"\n        caller_callee_manager = _CallerCalleeManager(self._graph, document)\n        caller_callee_manager.process()\n\n\n", "summary": "GraphBuilder is a class that constructs a symbol graph from an `Index` object, helping to explore symbol relationships within source code. It processes the relationships and occurrences of each symbol in the index and creates a networkx `MultiDiGraph` object. By default, caller-callee relationships are not included to improve performance, but they can be added by setting the `build_caller_relationships` flag to `True`. To use GraphBuilder simply instantiate it with an `Index` object, and optionally set the build_caller_relationships flag. Note that enabling the caller-callee relationships can lead to performance limitations due to the expensive operation of computing these relationships.\n\nExample:\n```python\nfrom automata.core.symbol.graph import GraphBuilder\nfrom automata.core.symbol.scip_pb2 import Index\n\nindex = Index()  # Assuming a populated index object.\nbuild_caller_relationships = True  # Optional\ngraph_builder = GraphBuilder(index, build_caller_relationships)\ngraph = graph_builder.build_graph()\n```\n", "context": "\n    Generate the documentation for GraphBuilder using the context shown below -\n  Building context for primary symbol - automata.core.symbol.graph.GraphBuilder -\n  \n    Import Statements:\n      import logging\n      import os\n      import networkx as nx\n      from dataclasses import dataclass\n      from typing import Any, Dict, List, Optional, Set\n      from google.protobuf.json_format import MessageToDict\n      from tqdm import tqdm\n      from automata.config.config_enums import ConfigCategory\n      from automata.core.symbol.parser import parse_symbol\n      from automata.core.symbol.scip_pb2 import Index, SymbolRole\n      from automata.core.symbol.symbol_types import (\n          Symbol,\n          SymbolDescriptor,\n          SymbolFile,\n          SymbolReference,\n      )\n      from automata.core.symbol.symbol_utils import convert_to_fst_object, get_rankable_symbols\n      from automata.core.utils import config_fpath\n      \n      # GraphBuilder\n      \n      `GraphBuilder` is a class that enables the construction of a symbol graph from an `Index` object. The graph representation aids in exploring symbol relationships within source code.\n      \n      ## Overview\n      \n      Given an `Index` object as input, `GraphBuilder` processes the relationships and occurrences of each symbol in the index. The resulting graph is a networkx `MultiDiGraph` object, allowing for the identification of symbol patterns and relationships within the codebase.\n      \n      By default, `GraphBuilder` does not include caller-callee relationships, for performance reasons. However, this feature can be enabled upon instantiation with the `build_caller_relationships` flag set to `True`.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.graph.SymbolGraph`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.symbol_types.SymbolFile`\n      - `automata.core.symbol.parser.parse_symbol`\n      \n      ## Example\n      \n      The following example demonstrates how to create a `GraphBuilder` instance and build a graph from an `Index` object. \n      \n      ```python\n      from automata.core.symbol.graph import GraphBuilder\n      from automata.core.symbol.scip_pb2 import Index\n      \n      index = Index()  # Assuming a populated index object.\n      build_caller_relationships = True  # Optional\n      graph_builder = GraphBuilder(index, build_caller_relationships)\n      graph = graph_builder.build_graph()\n      ```\n      \n      ## Limitations\n      \n      `GraphBuilder` may exhibit performance-related limitations, especially when the `build_caller_relationships` flag is set to `True`. This can lead to significantly longer processing times, as it involves an expensive operation to compute the caller-callee relationships.\n      \n      ## Follow-up Questions:\n      \n      - Are there any ways to optimize the caller-callee relationship computation within the `GraphBuilder`?\n      \n    Class Docstring:\n      Builds a symbol graph from an Index.\n      \n    Methods:\n      def __init__(self, index: Index, build_caller_relationships: bool = False):\n              \"\"\"\n              Args:\n                  index (Index): An Index object\n                  build_caller_relationships (bool, optional): Whether to build\n                      caller-callee relationships. Defaults to False.\n              \"\"\"\n              self.index = index\n              self.build_caller_relationships = build_caller_relationships\n              self._graph = nx.MultiDiGraph()\n      \n          \n      def build_graph(self):\n              \"\"\"\n              Builds the graph from the index\n              \"\"\"\n              for document in self.index.documents:\n                  self._add_file_vertices(document)\n                  self._add_symbol_vertices(document)\n                  self._process_relationships(document)\n                  self._process_occurrences(document)\n                  if self.build_caller_relationships:\n                      self._process_caller_callee_relationships(document)\n      \n              return self._graph\n      \n          \n  Building context for related symbols -\n  \n    automata.core.symbol.graph.SymbolGraph\n    \n        The `SymbolGraph` class represents a symbol graph that captures relationships between symbols found in source code files and is built from an index protobuf file. Utilizing NetworkX's MultiDiGraph, `SymbolGraph` represents relationships as a directed graph and includes methods for querying relationships, obtaining all available symbols and files, and filtering to subgraphs of rankable symbols. A navigator interface, _SymbolGraphNavigator, is required for getting reachable objects in the symbol subgraph.\n        \n        Example usage:\n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        \n        # Replace with your own file path\n        index_path = \"path/to/index.scip\"\n        symbol_graph = SymbolGraph(index_path)\n        all_symbols = symbol_graph.get_all_available_symbols()\n        ```\n        \n        Limitations include only being built from index protobuf files and the `get_potential_symbol_callers` method requiring downstream filtering to remove non-call statements. Future improvements may address these limitations and better handle edge cases in the symbol graph building process.\n        \n      Methods:\n        def __init__(\n                self, index_path: str = DEFAULT_SCIP_PATH, build_caller_relationships: bool = False\n            ):\n                \"\"\"\n                Initializes SymbolGraph with the path of an index protobuf file.\n        \n                Args:\n                    index_path (str): Path to index protobuf file\n                Returns:\n                    SymbolGraph instance\n                \"\"\"\n                index = self._load_index_protobuf(index_path)\n                builder = GraphBuilder(index, build_caller_relationships)\n                self._graph = builder.build_graph()\n                self.navigator = _SymbolGraphNavigator(self._graph)\n        \n            \n        get_all_available_symbols(self) -> List[Symbol]\n        \n        get_all_files(self) -> List[SymbolFile]\n        \n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n        get_rankable_symbol_subgraph(self, flow_rank=\"bidirectional\", path_filter: Optional[str] = None) -> SubGraph\n        \n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.core.symbol.search.tests.conftest.symbol_graph_mock\n    \n        @pytest.fixture\n        def symbol_graph_mock(mocker):\n            mock = mocker.MagicMock(spec=SymbolGraph)\n            return mock\n        \n        \n    automata.tests.unit.test_symbol_rank.test_get_ranks_small_graph\n    \n        def test_get_ranks_small_graph():\n            G = DiGraph()\n            G.add_edge(1, 2)\n            G.add_edge(2, 3)\n            G.add_edge(3, 1)\n            config = SymbolRankConfig()\n            pagerank = SymbolRank(G, config)\n        \n            ranks = pagerank.get_ranks()\n            assert len(ranks) == 3\n            assert sum([ele[1] for ele in ranks]) == pytest.approx(1.0)\n        \n        \n    automata.tests.unit.conftest.symbol_graph_mock\n    \n        @pytest.fixture\n        def symbol_graph_mock(mocker):\n            mock = mocker.MagicMock(spec=SymbolGraph)\n            return mock\n        \n        \n        \n        \n    automata.core.symbol.search.tests.conftest.symbol_graph\n    \n        @pytest.fixture\n        def symbol_graph():\n            # assuming the path to a valid index protobuf file, you should replace it with your own file path\n            file_dir = os.path.dirname(os.path.abspath(__file__))\n            index_path = os.path.join(file_dir, \"index.scip\")\n            graph = SymbolGraph(index_path)\n            return graph\n        \n        \n        \n        \n    automata.tests.unit.conftest.symbol_graph\n    \n        @pytest.fixture\n        def symbol_graph():\n            # assuming the path to a valid index protobuf file, you should replace it with your own file path\n            file_dir = os.path.dirname(os.path.abspath(__file__))\n            index_path = os.path.join(file_dir, \"index.scip\")\n            graph = SymbolGraph(index_path)\n            return graph\n        \n        \n        \n        \n    automata.tests.unit.test_symbol_rank.test_generate_random_graph\n    \n        def test_generate_random_graph():\n            nodes = 10\n            edges = 20\n            G = generate_random_graph(nodes, edges)\n        \n            assert G.number_of_nodes() == nodes\n            assert G.number_of_edges() <= edges  # It can be less because of randomly identical edges\n        \n        \n        \n        \n    automata.core.symbol.graph.SymbolGraph.SubGraph\n    \n        `SymbolGraph.SubGraph` is a data class designed to maintain and analyze subgraphs of a `SymbolGraph`. It contains a `parent` attribute to track the parent `SymbolGraph` instance and a `graph` attribute representing the actual subgraph with nodes and edges. The class offers a convenient way to encapsulate subgraphs for further analysis, connecting it closely to the `SymbolGraph` class and related methods. However, its main limitation is that it must be created from a `SymbolGraph` instance, requiring the extraction of the desired subgraph from an existing `SymbolGraph`.\n        \n  Building context for dependencies -\n  \n    automata.core.symbol.parser.parse_symbol\n    \n      Class Docstring:\n        Parses a symbol from a URI\n        \n        Args:\n        symbol_uri (str): The URI of the symbol\n        include_descriptors (bool): Whether to include descriptors in the symbol\n        \n        Returns:\n        Symbol - The parsed symbol\n        \n      Methods:\n        parse_symbol(symbol_uri: str, include_descriptors: bool = True) -> Symbol\n        \n    automata.core.symbol.graph._SymbolGraphNavigator\n    \n      Class Docstring:\n        Handles navigation of a symbol graph.\n        \n      Methods:\n        def __init__(self, graph: nx.MultiDiGraph):\n                \"\"\"\n                Args:\n                    graph (nx.MultiDiGraph): A networkx graph\n                \"\"\"\n                self._graph = graph\n        \n            \n        get_all_available_symbols(self) -> List[Symbol]\n        \n        get_all_files(self) -> List[SymbolFile]\n        \n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n    automata.core.symbol.graph._OccurrenceManager\n    \n        The `_OccurrenceManager` class manages symbol occurrences in a graph, accepting a networkx graph and document object as arguments during initialization. This class provides a `process` method which processes occurrences, adding edges and information to the graph based on the occurrences' symbol, roles, and location within the document. However, it currently lacks functionality to remove, modify, or search for occurrences within the graph, as well as advanced queries or filtering on the processed occurrences. To utilize the `_OccurrenceManager`, simply initialize it with a graph and document and run the `process` method to handle occurrences.\n        \n      Class Docstring:\n        Manages the occurrences of a symbol in a graph\n        \n      Methods:\n        def __init__(self, graph: nx.MultiDiGraph, document: Any):\n                \"\"\"\n                Args:\n                    graph (nx.MultiDiGraph): A networkx graph\n                    document (Any): A Document object\n                \"\"\"\n                self._graph = graph\n                self.document = document\n        \n            \n        process(self) -> None\n        \n    automata.core.symbol.graph._RelationshipManager.process\n    \n      Class Docstring:\n        Processes the relationships in the local graph\n        \n      Methods:\n        process(self) -> None\n        \n    automata.core.symbol.graph._CallerCalleeManager.process\n    \n      Class Docstring:\n        Processes the caller-callee relationships in the local graph\n        \n        Note that this is an expensive operation, and should be used sparingly\n        \n      Methods:\n        process(self) -> None\n        \n    automata.core.symbol.symbol_types.SymbolFile\n    \n        `SymbolFile` is a class used to represent files containing symbols, typically within the `SymbolGraph`. It provides methods for equality checks and hashing operations but does not include methods for modifying the file or accessing the symbol within. You can use the `SymbolFile` class to create instances of files containing symbols and compare them as shown in the following example:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolFile\n        \n        file_1 = SymbolFile(\"path/to/symbol/file\")\n        file_2 = SymbolFile(\"path/to/symbol/file\")\n        \n        # Comparing SymbolFile instances\n        assert file_1 == file_2\n        \n        # Comparing SymbolFile instance with a string representing the path\n        assert file_1 == \"path/to/symbol/file\"\n        ```\n        To access the symbol within a `SymbolFile` instance, you may need to use related symbol classes.\n        \n      Class Docstring:\n        Represents a file that contains a symbol\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n    automata.core.symbol.graph._OccurrenceManager.process\n    \n      Class Docstring:\n        Processes the occurrences in the local graph\n        \n      Methods:\n        process(self) -> None\n        \n    automata.core.symbol.graph._RelationshipManager\n    \n        The `_RelationshipManager` is a class within the `automata.core.symbol.graph` package that manages relationships between symbols in a graph. It works with the `GraphManager` and related classes, initializing with a `networkx` graph and a `SymbolInformation` object. The main function of the class is to process relationships between symbols and add them as edges in the given graph through the `process` method. However, it is designed for internal use and may not handle errors gracefully, relying on correct and consistent input from the `SymbolInformation` object.\n        \n      Class Docstring:\n        Manages the relationships between symbols in a graph\n        \n      Methods:\n        def __init__(self, graph: nx.MultiDiGraph, symbol_information: Any):\n                \"\"\"\n                Args:\n                    graph (nx.MultiDiGraph): A networkx graph\n                    symbol_information (Any): A SymbolInformation object\n                \"\"\"\n                self._graph = graph\n                self.symbol_information = symbol_information\n        \n            \n        process(self) -> None\n        \n    automata.core.symbol.graph._CallerCalleeManager\n    \n        The _CallerCalleeManager class manages caller-callee relationships of a symbol in a graph by processing all symbols that call or are called by another symbol within the local graph. This is crucial for understanding how different components of code interact with one another. However, processing these relationships is computationally expensive, so it should be used sparingly. The class relies on a networkx graph and a _SymbolGraphNavigator instance for its operations. There are limitations, such as including non-call statements, which can be mitigated with AST awareness and filtering downstream using the ASTNavigator.\n        \n        Example usage:\n        \n        ```python\n        import networkx as nx\n        from automata.core.symbol.graph import _CallerCalleeManager\n        from automata.core.symbol.graph import _SymbolGraphNavigator\n        \n        # Create a MultiDiGraph\n        graph = nx.MultiDiGraph()\n        \n        # Create a document with symbols\n        document = ...\n        \n        # Initialize CallerCalleeManager\n        manager = _CallerCalleeManager(graph=graph, document=document)\n        \n        # Process caller-callee relationships in the graph\n        manager.process()\n        ```\n        \n      Class Docstring:\n        Manages the caller-callee relationships of a symbol in a graph.\n        \n      Methods:\n        def __init__(self, graph: nx.MultiDiGraph, document: Any):\n                \"\"\"\n                Args:\n                    graph (nx.MultiDiGraph): A networkx graph\n                    document (Any): A Document object\n                \"\"\"\n                self._graph = graph\n                self.navigator = _SymbolGraphNavigator(graph)\n                self.document = document\n        \n            \n        process(self) -> None\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.graph`/SymbolGraph#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.graph", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolGraph", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolGraph\n\n`SymbolGraph` represents the symbol graph that captures the relationships between symbols found in various source code files. The symbol graph can be built from an index protobuf file, making it the central class for working with symbols and their relationships. Some of the primary methods in `SymbolGraph` include `get_all_available_symbols`, `get_all_files`, `get_potential_symbol_callees`, `get_potential_symbol_callers`, `get_references_to_symbol`, `get_symbol_dependencies`, and `get_symbol_relationships`.\n\n## Overview\n\n`SymbolGraph` uses NetworkX's MultiDiGraph to represent the relationships between symbols as a directed graph. It includes methods to query for callers, callees, and references to a symbol, as well as obtaining all available symbols and files in the graph. The graph can be filtered to subgraphs containing only rankable symbols. Getting reachable objects in the symbol subgraph requires using the navigator interface, _SymbolGraphNavigator.\n\n## Related Symbols\n\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.graph.GraphBuilder`\n- `automata.core.symbol.graph._SymbolGraphNavigator`\n- `automata.core.symbol.search.SymbolSearch`\n\n## Example\n\nThe following example demonstrates how to create an instance of `SymbolGraph` using an index protobuf file.\n\n```python\nfrom automata.core.symbol.graph import SymbolGraph\n\n# Assuming the path to a valid index protobuf file, you should replace it with your own file path\nindex_path = \"path/to/index.scip\"\nsymbol_graph = SymbolGraph(index_path)\nall_symbols = symbol_graph.get_all_available_symbols()\n```\n\n## Limitations\n\nSymbolGraph can only be built from an index protobuf file. In addition, the method `get_potential_symbol_callers` returns potential callers, but this list requires downstream filtering to remove non-call statements.\n\n## Follow-up Questions\n\n- How to better handle edge cases in the symbol graph building process?\n- How to make `get_potential_symbol_callers` more efficient with fewer potential callers?\n\n## Footnotes\n\nIn the context provided, some information was referring to 'mock' objects which are used for testing purposes. In the final documentation, it is recommended to replace mocked objects with actual underlying objects whenever possible. A list of some of the imported modules and methods is provided for reference, which may be useful in illustrating certain aspects of the SymbolGraph class.", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class SymbolGraph:\n    @dataclass\n    class SubGraph:\n        parent: \"SymbolGraph\"\n        graph: nx.DiGraph\n\n    DEFAULT_SCIP_PATH = os.path.join(config_fpath(), ConfigCategory.SYMBOL.value, \"index.scip\")\n\n    def __init__(\n        self, index_path: str = DEFAULT_SCIP_PATH, build_caller_relationships: bool = False\n    ):\n        \"\"\"\n        Initializes SymbolGraph with the path of an index protobuf file.\n\n        Args:\n            index_path (str): Path to index protobuf file\n        Returns:\n            SymbolGraph instance\n        \"\"\"\n        index = self._load_index_protobuf(index_path)\n        builder = GraphBuilder(index, build_caller_relationships)\n        self._graph = builder.build_graph()\n        self.navigator = _SymbolGraphNavigator(self._graph)\n\n    def get_all_files(self) -> List[SymbolFile]:\n        \"\"\"\n        Gets all file nodes in the graph.\n\n        Args:\n            None\n        Returns:\n            List of all defined symbols.\n        \"\"\"\n        return self.navigator.get_all_files()\n\n    def get_all_available_symbols(self) -> List[Symbol]:\n        \"\"\"\n        Gets all symbols defined in the graph.\n\n        Args:\n            None\n        Returns:\n            List[Symbol]: List of all defined symbols.\n        \"\"\"\n        return list(set(self.navigator.get_all_available_symbols()))\n\n    def get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]:\n        \"\"\"\n        Gets all symbols which contain a specified partial path\n\n        Args:\n            partial_py_path (PyPath): The partial path to explain\n        Returns:\n            Set[Symbol]: Set of symbols that follow the partial path\n        \"\"\"\n        return self.navigator.get_symbol_dependencies(symbol)\n\n    def get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]:\n        \"\"\"\n        Gets the set of symbols with relationships to the given symbol.\n\n        Args:\n            symbol (Symbol): The symbol to get relationships for.\n        Returns:\n            Set[Symbol]: The list of relationships for the symbol.\n\n        # TODO: Consider implications of using list instead of set\n        \"\"\"\n        return self.navigator.get_symbol_relationships(symbol)\n\n    def get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]:\n        \"\"\"\n        Gets the (potential) callers of the given symbol.\n        Requires downstream filtering to remove non-call statements.\n\n        Args:\n            symbol (Symbol): The symbol to get callers for.\n        Returns:\n            Dict[Symbol]: The map of callers to callees for the symbol.\n        \"\"\"\n\n        return self.navigator.get_potential_symbol_callers(symbol)\n\n    def get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]:\n        \"\"\"\n        Gets the callers of the given symbol.\n        Requires downstream filtering to remove non-call statements.\n\n        Args:\n            symbol (Symbol): The symbol to get callees for.\n        Returns:\n            Dict[Symbol]: The map of callees to callers for the symbol.\n        \"\"\"\n        return self.navigator.get_potential_symbol_callees(symbol)\n\n    def get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]:\n        \"\"\"\n        Gets all references to a given module in the symbol graph.\n\n        Args:\n            module (Symbol): The module to locate references for\n        Returns:\n            List[SymbolReference]: List of symbol references\n        \"\"\"\n        return self.navigator.get_references_to_symbol(symbol)\n\n    def get_rankable_symbol_subgraph(\n        self, flow_rank=\"bidirectional\", path_filter: Optional[str] = None\n    ) -> SubGraph:\n        \"\"\"\n        Gets a detailed subgraph of rankable symbols.\n\n        Args:\n            symbol (str): The symbol in the form 'module`/ClassOrMethod#'\n\n        Returns:\n            List[str]: The list of dependencies for the symbol.\n        TODO: Consider ways to make this more efficient.\n        TODO: Find ways to better handle edge cases\n        \"\"\"\n        G = nx.DiGraph()\n\n        # Filter the symbols based on the provided path filter\n\n        filtered_symbols = get_rankable_symbols(self.get_all_available_symbols())\n\n        if path_filter is not None:\n            filtered_symbols = [\n                sym for sym in filtered_symbols if sym.dotpath.startswith(path_filter)  # type: ignore\n            ]\n\n        logger.info(\"Building the rankable symbol subgraph...\")\n        for symbol in tqdm(filtered_symbols):\n            try:\n                dependencies = self.get_symbol_dependencies(symbol)\n                relationships = self.get_symbol_relationships(symbol)\n                filtered_related_symbols = get_rankable_symbols(\n                    list(dependencies.union(relationships))\n                )\n                for dependency in filtered_related_symbols:\n                    if flow_rank == \"to_dependents\":\n                        G.add_edge(symbol, dependency)\n                    elif flow_rank == \"from_dependents\":\n                        G.add_edge(dependency, symbol)\n                    elif flow_rank == \"bidirectional\":\n                        G.add_edge(symbol, dependency)\n                        G.add_edge(dependency, symbol)\n                    else:\n                        raise ValueError(\n                            \"flow_rank must be one of 'to_dependents', 'from_dependents', or 'bidirectional'\"\n                        )\n\n            except Exception as e:\n                logger.error(f\"Error processing {symbol.uri}: {e}\")\n\n        logger.info(\"Built the rankable symbol subgraph\")\n\n        return SymbolGraph.SubGraph(graph=G, parent=self)\n\n    @staticmethod\n    def _load_index_protobuf(path: str) -> Index:\n        \"\"\"\n        Loads an index protobuf file from disk\n\n        Args:\n            path (str): The path to the index protobuf file\n\n        Returns:\n            Index: The loaded index protobuf\n        \"\"\"\n        index = Index()\n        with open(path, \"rb\") as f:\n            index.ParseFromString(f.read())\n        return index\n", "summary": "`SymbolGraph` is a central class representing the relationships between symbols in various source code files, using NetworkX's MultiDiGraph as a directed graph. It can be built from an index protobuf file and offers methods to query callers, callees, references to a symbol, as well as obtaining all available symbols and files in the graph. The graph can be filtered to subgraphs containing only rankable symbols. To navigate reachable objects in the symbol subgraph, use the _SymbolGraphNavigator interface. Note that SymbolGraph can only be built from an index protobuf file, and the `get_potential_symbol_callers` method returns potential callers that require downstream filtering.\n\nExample usage:\n```python\nfrom automata.core.symbol.graph import SymbolGraph\n\nindex_path = \"path/to/index.scip\"\nsymbol_graph = SymbolGraph(index_path)\nall_symbols = symbol_graph.get_all_available_symbols()\n```\n", "context": "\n    Generate the documentation for SymbolGraph using the context shown below -\n  Building context for primary symbol - automata.core.symbol.graph.SymbolGraph -\n  \n    Import Statements:\n      import logging\n      import os\n      import networkx as nx\n      from dataclasses import dataclass\n      from typing import Any, Dict, List, Optional, Set\n      from google.protobuf.json_format import MessageToDict\n      from tqdm import tqdm\n      from automata.config.config_enums import ConfigCategory\n      from automata.core.symbol.parser import parse_symbol\n      from automata.core.symbol.scip_pb2 import Index, SymbolRole\n      from automata.core.symbol.symbol_types import (\n          Symbol,\n          SymbolDescriptor,\n          SymbolFile,\n          SymbolReference,\n      )\n      from automata.core.symbol.symbol_utils import convert_to_fst_object, get_rankable_symbols\n      from automata.core.utils import config_fpath\n      \n      # SymbolGraph\n      \n      The `SymbolGraph` class represents the symbol graph that captures the relationships between symbols  found in various source code files. The symbol graph can be built from an index protobuf file, making it the central class for working with symbols and their relationships. Some of the primary methods in `SymbolGraph` include `get_all_available_symbols`, `get_all_files`, `get_potential_symbol_callees`, `get_potential_symbol_callers`, `get_references_to_symbol`, `get_symbol_dependencies`, and `get_symbol_relationships`.\n      \n      ## Overview\n      \n      `SymbolGraph` uses NetworkX's MultiDiGraph to represent the relationships between symbols as a directed graph. It includes methods to query for callers, callees, and references to a symbol, as well as obtaining all available symbols and files in the graph. The graph can be filtered to subgraphs containing only rankable symbols. Getting reachable objects in the symbol subgraph requires using the navigator interface, _SymbolGraphNavigator.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.graph.GraphBuilder`\n      - `automata.core.symbol.graph._SymbolGraphNavigator`\n      - `automata.core.symbol.search.SymbolSearch`\n      \n      ## Example\n      \n      The following example demonstrates how to create an instance of `SymbolGraph` using an index protobuf file.\n      \n      ```python\n      from automata.core.symbol.graph import SymbolGraph\n      \n      # Assuming the path to a valid index protobuf file, you should replace it with your own file path\n      index_path = \"path/to/index.scip\"\n      symbol_graph = SymbolGraph(index_path)\n      all_symbols = symbol_graph.get_all_available_symbols()\n      ```\n      \n      ## Limitations\n      \n      SymbolGraph can only be built from an index protobuf file. In addition, the method `get_potential_symbol_callers` returns potential callers, but this list requires downstream filtering to remove non-call statements.\n      \n      ## Follow-up Questions:\n      \n      - How to better handle edge cases in the symbol graph building process?\n      - How to make `get_potential_symbol_callers` more efficient with fewer potential callers?\n      \n      ## Footnotes\n      \n      In the context provided, some information was referring to 'mock' objects which are used for testing purposes. In the final documentation, it is recommended to replace mocked objects with actual underlying objects whenever possible. A list of some of the imported modules and methods is provided for reference, which may be useful in illustrating certain aspects of the SymbolGraph class.\n      \n    Methods:\n      def __init__(\n              self, index_path: str = DEFAULT_SCIP_PATH, build_caller_relationships: bool = False\n          ):\n              \"\"\"\n              Initializes SymbolGraph with the path of an index protobuf file.\n      \n              Args:\n                  index_path (str): Path to index protobuf file\n              Returns:\n                  SymbolGraph instance\n              \"\"\"\n              index = self._load_index_protobuf(index_path)\n              builder = GraphBuilder(index, build_caller_relationships)\n              self._graph = builder.build_graph()\n              self.navigator = _SymbolGraphNavigator(self._graph)\n      \n          \n      def get_all_available_symbols(self) -> List[Symbol]:\n              \"\"\"\n              Gets all symbols defined in the graph.\n      \n              Args:\n                  None\n              Returns:\n                  List[Symbol]: List of all defined symbols.\n              \"\"\"\n              return list(set(self.navigator.get_all_available_symbols()))\n      \n          \n      def get_all_files(self) -> List[SymbolFile]:\n              \"\"\"\n              Gets all file nodes in the graph.\n      \n              Args:\n                  None\n              Returns:\n                  List of all defined symbols.\n              \"\"\"\n              return self.navigator.get_all_files()\n      \n          \n      def get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]:\n              \"\"\"\n              Gets the callers of the given symbol.\n              Requires downstream filtering to remove non-call statements.\n      \n              Args:\n                  symbol (Symbol): The symbol to get callees for.\n              Returns:\n                  Dict[Symbol]: The map of callees to callers for the symbol.\n              \"\"\"\n              return self.navigator.get_potential_symbol_callees(symbol)\n      \n          \n      def get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]:\n              \"\"\"\n              Gets the (potential) callers of the given symbol.\n              Requires downstream filtering to remove non-call statements.\n      \n              Args:\n                  symbol (Symbol): The symbol to get callers for.\n              Returns:\n                  Dict[Symbol]: The map of callers to callees for the symbol.\n              \"\"\"\n      \n              return self.navigator.get_potential_symbol_callers(symbol)\n      \n          \n      def get_rankable_symbol_subgraph(\n              self, flow_rank=\"bidirectional\", path_filter: Optional[str] = None\n          ) -> SubGraph:\n              \"\"\"\n              Gets a detailed subgraph of rankable symbols.\n      \n              Args:\n                  symbol (str): The symbol in the form 'module`/ClassOrMethod#'\n      \n              Returns:\n                  List[str]: The list of dependencies for the symbol.\n              TODO: Consider ways to make this more efficient.\n              TODO: Find ways to better handle edge cases\n              \"\"\"\n              G = nx.DiGraph()\n      \n              # Filter the symbols based on the provided path filter\n      \n              filtered_symbols = get_rankable_symbols(self.get_all_available_symbols())\n      \n              if path_filter is not None:\n                  filtered_symbols = [\n                      sym for sym in filtered_symbols if sym.dotpath.startswith(path_filter)  # type: ignore\n                  ]\n      \n              logger.info(\"Building the rankable symbol subgraph...\")\n              for symbol in tqdm(filtered_symbols):\n                  try:\n                      dependencies = self.get_symbol_dependencies(symbol)\n                      relationships = self.get_symbol_relationships(symbol)\n                      filtered_related_symbols = get_rankable_symbols(\n                          list(dependencies.union(relationships))\n                      )\n                      for dependency in filtered_related_symbols:\n                          if flow_rank == \"to_dependents\":\n                              G.add_edge(symbol, dependency)\n                          elif flow_rank == \"from_dependents\":\n                              G.add_edge(dependency, symbol)\n                          elif flow_rank == \"bidirectional\":\n                              G.add_edge(symbol, dependency)\n                              G.add_edge(dependency, symbol)\n                          else:\n                              raise ValueError(\n                                  \"flow_rank must be one of 'to_dependents', 'from_dependents', or 'bidirectional'\"\n                              )\n      \n                  except Exception as e:\n                      logger.error(f\"Error processing {symbol.uri}: {e}\")\n      \n              logger.info(\"Built the rankable symbol subgraph\")\n      \n              return SymbolGraph.SubGraph(graph=G, parent=self)\n      \n          \n      def get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]:\n              \"\"\"\n              Gets all references to a given module in the symbol graph.\n      \n              Args:\n                  module (Symbol): The module to locate references for\n              Returns:\n                  List[SymbolReference]: List of symbol references\n              \"\"\"\n              return self.navigator.get_references_to_symbol(symbol)\n      \n          \n      def get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]:\n              \"\"\"\n              Gets all symbols which contain a specified partial path\n      \n              Args:\n                  partial_py_path (PyPath): The partial path to explain\n              Returns:\n                  Set[Symbol]: Set of symbols that follow the partial path\n              \"\"\"\n              return self.navigator.get_symbol_dependencies(symbol)\n      \n          \n      def get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]:\n              \"\"\"\n              Gets the set of symbols with relationships to the given symbol.\n      \n              Args:\n                  symbol (Symbol): The symbol to get relationships for.\n              Returns:\n                  Set[Symbol]: The list of relationships for the symbol.\n      \n              # TODO: Consider implications of using list instead of set\n              \"\"\"\n              return self.navigator.get_symbol_relationships(symbol)\n      \n          \n  Building context for related symbols -\n  \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_symbol_graph.test_get_all_symbols\n    \n        def test_get_all_symbols(symbol_graph):\n            graph_symbols = symbol_graph.get_all_available_symbols()\n            assert isinstance(graph_symbols, list)\n            assert all(isinstance(s, Symbol) for s in graph_symbols)\n        \n        \n    automata.core.symbol.search.tests.conftest.symbol_graph_mock\n    \n        @pytest.fixture\n        def symbol_graph_mock(mocker):\n            mock = mocker.MagicMock(spec=SymbolGraph)\n            return mock\n        \n        \n    automata.tests.unit.test_symbol_rank.test_get_ranks_small_graph\n    \n        def test_get_ranks_small_graph():\n            G = DiGraph()\n            G.add_edge(1, 2)\n            G.add_edge(2, 3)\n            G.add_edge(3, 1)\n            config = SymbolRankConfig()\n            pagerank = SymbolRank(G, config)\n        \n            ranks = pagerank.get_ranks()\n            assert len(ranks) == 3\n            assert sum([ele[1] for ele in ranks]) == pytest.approx(1.0)\n        \n        \n    automata.core.symbol.graph.GraphBuilder\n    \n        `GraphBuilder` is a class that constructs a symbol graph from an `Index` object, facilitating the exploration of symbol relationships within source code. The resulting graph, a networkx `MultiDiGraph` object, allows for identifying symbol patterns and relationships in the codebase. While caller-callee relationships are not included by default due to performance concerns, they can be enabled by setting the `build_caller_relationships` flag to `True`. However, enabling this feature can result in significantly longer processing times due to the expensive computation.\n        \n        Example:\n        \n        ```python\n        from automata.core.symbol.graph import GraphBuilder\n        from automata.core.symbol.scip_pb2 import Index\n        \n        index = Index()  # Assuming a populated index object.\n        build_caller_relationships = True  # Optional\n        graph_builder = GraphBuilder(index, build_caller_relationships)\n        graph = graph_builder.build_graph()\n        ```\n        \n      Class Docstring:\n        Builds a symbol graph from an Index.\n        \n      Methods:\n        def __init__(self, index: Index, build_caller_relationships: bool = False):\n                \"\"\"\n                Args:\n                    index (Index): An Index object\n                    build_caller_relationships (bool, optional): Whether to build\n                        caller-callee relationships. Defaults to False.\n                \"\"\"\n                self.index = index\n                self.build_caller_relationships = build_caller_relationships\n                self._graph = nx.MultiDiGraph()\n        \n            \n        build_graph(self) -> None\n        \n    automata.core.symbol.search.tests.conftest.symbol_graph\n    \n        @pytest.fixture\n        def symbol_graph():\n            # assuming the path to a valid index protobuf file, you should replace it with your own file path\n            file_dir = os.path.dirname(os.path.abspath(__file__))\n            index_path = os.path.join(file_dir, \"index.scip\")\n            graph = SymbolGraph(index_path)\n            return graph\n        \n        \n        \n        \n    automata.tests.unit.conftest.symbol_graph\n    \n        @pytest.fixture\n        def symbol_graph():\n            # assuming the path to a valid index protobuf file, you should replace it with your own file path\n            file_dir = os.path.dirname(os.path.abspath(__file__))\n            index_path = os.path.join(file_dir, \"index.scip\")\n            graph = SymbolGraph(index_path)\n            return graph\n        \n        \n        \n        \n    automata.core.symbol.search.symbol_search.SymbolSearch\n    \n        `SymbolSearch` is a class used to search for symbols in a `SymbolGraph` by processing NLP-formatted queries and providing search results in various formats depending on the query type. The class utilizes a symbol similarity algorithm for ranking symbols according to relevance and a SymbolRank algorithm for computing a global symbol ranking. To use `SymbolSearch`, first initialize the necessary objects, such as `SymbolGraph` and `SymbolSimilarity`, then create a `SymbolSearch` object and process a query to obtain the search results.\n        \n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        from automata.core.embedding.symbol_similarity import SymbolSimilarity\n        from automata.core.symbol.search.symbol_search import SymbolSearch\n        \n        # Initialize necessary objects\n        symbol_graph = SymbolGraph()\n        symbol_similarity = SymbolSimilarity()\n        \n        # Create the SymbolSearch object\n        symbol_searcher = SymbolSearch(symbol_graph, symbol_similarity)\n        \n        # Process a query and get the search results\n        query = \"type:symbol_references <symbol_uri>\"\n        result = symbol_searcher.process_query(query)\n        ```\n        \n        Note that `SymbolSearch` relies on the availability of symbols in the `SymbolGraph` and `SymbolSimilarity` objects, and will produce incomplete or incorrect results if the necessary data is missing or the input query does not follow the expected format.\n        \n      Class Docstring:\n        Searches for symbols in a SymbolGraph\n        \n      Methods:\n        def __init__(\n                self,\n                symbol_graph: SymbolGraph,\n                symbol_similarity: SymbolSimilarity,\n                symbol_rank_config: Optional[SymbolRankConfig],\n                code_subgraph: Optional[SymbolGraph.SubGraph] = None,\n                *args,\n                **kwargs,\n            ):\n                \"\"\"\n                Args:\n                    symbol_graph (SymbolGraph): A SymbolGraph\n                    symbol_similarity (SymbolSimilarity): A SymbolSimilarity object\n                    symbol_rank_config (Optional[SymbolRankConfig]): A SymbolRankConfig object\n                    code_subgraph (Optional[SymbolGraph.SubGraph]): A subgraph of the SymbolGraph\n                \"\"\"\n        \n                if not code_subgraph:\n                    code_subgraph = symbol_graph.get_rankable_symbol_subgraph(\n                        kwargs.get(\"flow_rank\", \"bidirectional\")\n                    )\n                else:\n                    if not code_subgraph.parent == symbol_graph:\n                        raise ValueError(\"code_subgraph must be a subgraph of symbol_graph\")\n        \n                graph_symbols = symbol_graph.get_all_available_symbols()\n                embedding_symbols = symbol_similarity.embedding_handler.get_all_supported_symbols()\n                available_symbols = set(graph_symbols).intersection(set(embedding_symbols))\n                SymbolSearch.filter_graph(code_subgraph.graph, available_symbols)\n        \n                # TODO - Do we need to filter the SymbolGraph as well?\n                self.symbol_graph = symbol_graph\n                self.symbol_similarity = symbol_similarity\n                symbol_similarity.set_available_symbols(available_symbols)\n                self.symbol_rank = SymbolRank(code_subgraph.graph, config=symbol_rank_config)\n        \n            \n        exact_search(self, pattern: str) -> ExactSearchResult\n        \n        filter_graph(graph: nx.DiGraph, available_symbols: Set[Symbol]) -> None\n        \n        find_pattern_in_modules(pattern: str) -> Dict[str, List[int]]\n        \n        process_query(self, query: str) -> Union[SymbolReferencesResult, SymbolRankResult, SourceCodeResult, ExactSearchResult,]\n        \n        retrieve_source_code_by_symbol(self, symbol_uri: str) -> SourceCodeResult\n        \n        shifted_z_score_sq(values: Union[List[float], np.ndarray]) -> np.ndarray\n        \n        symbol_rank_search(self, query: str) -> SymbolRankResult\n        \n        symbol_references(self, symbol_uri: str) -> SymbolReferencesResult\n        \n        transform_dict_values(dictionary: Dict[Any, float], func: Callable[[List[float]], np.ndarray]\n            ) -> None\n        \n    automata.tests.unit.conftest.symbol_graph_mock\n    \n        @pytest.fixture\n        def symbol_graph_mock(mocker):\n            mock = mocker.MagicMock(spec=SymbolGraph)\n            return mock\n        \n        \n        \n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n  Building context for dependencies -\n  \n    automata.core.symbol.graph._SymbolGraphNavigator.get_references_to_symbol\n    \n      Class Docstring:\n        Gets all references to a symbol\n        \n        Args:\n        symbol (Symbol): The symbol object to fetch references for\n        \n        Returns:\n        Dict[str, List[SymbolReference]]: A dictionary of file\n        paths to a list of SymbolReference objects\n        \n      Methods:\n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n    automata.core.symbol.graph.GraphBuilder.build_graph\n    \n      Class Docstring:\n        Builds the graph from the index\n        \n      Methods:\n        build_graph(self) -> None\n        \n    automata.core.symbol.graph._SymbolGraphNavigator.get_all_files\n    \n      Class Docstring:\n        Gets all files in the graph\n        \n        Returns:\n        List[SymbolFile]: A list of SymbolFile objects\n        \n      Methods:\n        get_all_files(self) -> List[SymbolFile]\n        \n    automata.core.symbol.graph._SymbolGraphNavigator.get_potential_symbol_callees\n    \n      Class Docstring:\n        Gets all potential callees of a symbol\n        \n        Args:\n        symbol (Symbol): The symbol object to fetch callees for\n        \n        Returns:\n        Dict[Symbol, SymbolReference]: A dictionary of Symbol objects to\n        Symbol callees (SymbolReference objects).\n        \n      Methods:\n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n    automata.core.symbol.graph._SymbolGraphNavigator.get_potential_symbol_callers\n    \n      Class Docstring:\n        Gets all potential callers of a symbol\n        \n        Args:\n        symbol (Symbol): The symbol object to fetch callers for\n        \n        Returns:\n        Dict[Symbol, SymbolReference]: A dictionary of Symbol objects to\n        Symbol calleers (SymbolReference objects).\n        TODO - Remove non-call statements from this return object\n        \n      Methods:\n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n    automata.core.symbol.graph._SymbolGraphNavigator.get_symbol_relationships\n    \n      Methods:\n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n    automata.core.symbol.graph._SymbolGraphNavigator.get_all_available_symbols\n    \n      Class Docstring:\n        Gets all available symbols in the graph\n        \n        Returns:\n        List[Symbol]: A list of Symbol objects\n        \n      Methods:\n        get_all_available_symbols(self) -> List[Symbol]\n        \n    automata.core.symbol.symbol_types.Symbol.dotpath\n    \n      Class Docstring:\n        Returns the dotpath of the symbol\n        \n      Methods:\n        dotpath(self) -> str\n        \n    automata.core.symbol.symbol_types.SymbolReference\n    \n        `SymbolReference` is a class representing a reference to a symbol in a file, used for managing references to symbols within a codebase. It offers utility methods for comparing and hashing symbol references based on their URI, line number, and column number. In conjunction with other symbol-related classes, it helps track and manage references to symbols in files based on their location and usage. However, there is a potential limitation of causing collisions when the same symbol is referenced in different files at the same location (line and column). This is rare, but important to consider when working with multiple symbol references across files.\n        \n        Example usage: \n        ```python\n        from automata.core.symbol.symbol_types import SymbolReference\n        from automata.core.symbol.parser import parse_symbol\n        \n        symbol_uri = \"example_uri\"\n        line_number = 10\n        column_number = 5\n        symbol = parse_symbol(symbol_uri)\n        \n        symbol_ref1 = SymbolReference(symbol, line_number, column_number)\n        symbol_ref2 = SymbolReference(symbol, line_number + 1, column_number)\n        \n        assert symbol_ref1 != symbol_ref2\n        assert hash(symbol_ref1) != hash(symbol_ref2)\n        \n        symbol_ref3 = SymbolReference(symbol, line_number, column_number)\n        assert symbol_ref1 == symbol_ref3\n        ```\n        \n      Class Docstring:\n        Represents a reference to a symbol in a file\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n    automata.core.utils.config_fpath\n    \n      Class Docstring:\n        Get the path to the project config directory\n        \n        Returns:\n        str - A fpath object in string form\n        \n      Methods:\n        config_fpath() -> str\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.graph`/SymbolGraph#SubGraph#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.graph", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolGraph", "suffix": 2, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SubGraph", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolGraph.SubGraph\n\n`SymbolGraph.SubGraph` is a data class responsible for maintaining the subgraph of a `SymbolGraph`. It contains a `parent` attribute to track the parent `SymbolGraph` instance, and a `graph` attribute representing the actual subgraph with nodes and edges.\n\n## Overview\n\nThe `SymbolGraph.SubGraph` class provides an interface to work with subgraphs of a `SymbolGraph`. It can be used, for example, to analyze a subgraph consisting of only rankable symbols. The class offers a convenient way to encapsulate subgraphs for further analysis, connecting it closely to the `SymbolGraph` class and related methods.\n\n## Related Symbols\n\n- `automata.core.symbol.graph.SymbolGraph`\n- `automata.core.symbol.graph.SymbolGraph.get_rankable_symbol_subgraph`\n- `networkx.DiGraph`\n\n## Example\n\nThe following is an example demonstrating how to obtain and use a `SymbolGraph.SubGraph` instance.\n\n```python\nfrom automata.core.symbol.graph import SymbolGraph\n\n# assuming the path to a valid index protobuf file\nindex_path = \"path/to/index.scip\"\nsymbol_graph = SymbolGraph(index_path=index_path)\n\n# Get a SubGraph consisting of only rankable symbols\nsubgraph = symbol_graph.get_rankable_symbol_subgraph()\n\n# Use the SubGraph for further analysis and processing\n```\n\n## Limitations\n\nThe main limitation of `SymbolGraph.SubGraph` is that it must be created from a `SymbolGraph` instance. This means that in order to use a `SymbolGraph.SubGraph`, you must first have a `SymbolGraph` from which you can extract the desired subgraph.\n\n## Follow-up Questions:\n\n- How can we create `SymbolGraph.SubGraph` instances independent of the parent `SymbolGraph`?\n- Are there any specific use cases where such independent `SymbolGraph.SubGraph` instances may be useful?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "@dataclass\n    class SubGraph:\n        parent: \"SymbolGraph\"\n        graph: nx.DiGraph\n\n    ", "summary": "`SymbolGraph.SubGraph` is a data class that manages subgraphs of a `SymbolGraph` instance, with a `parent` attribute connecting it to the parent `SymbolGraph` and a `graph` attribute representing the subgraph's nodes and edges. The class offers a convenient way to analyze specific portions of a `SymbolGraph`, such as rankable symbols, by encapsulating subgraphs for further processing. To create a `SymbolGraph.SubGraph`, you must first have a `SymbolGraph` instance from which the desired subgraph can be extracted. For example, to obtain and analyze a subgraph of rankable symbols:\n\n```python\nfrom automata.core.symbol.graph import SymbolGraph\n\nindex_path = \"path/to/index.scip\"\nsymbol_graph = SymbolGraph(index_path=index_path)\n\nsubgraph = symbol_graph.get_rankable_symbol_subgraph()\n```\nConsiderations for creating independent `SymbolGraph.SubGraph` instances and their potential use cases should be addressed.", "context": "\n    Generate the documentation for SymbolGraph using the context shown below -\n  Building context for primary symbol - automata.core.symbol.graph.SymbolGraph.SubGraph -\n  \n    Import Statements:\n      import logging\n      import os\n      import networkx as nx\n      from dataclasses import dataclass\n      from typing import Any, Dict, List, Optional, Set\n      from google.protobuf.json_format import MessageToDict\n      from tqdm import tqdm\n      from automata.config.config_enums import ConfigCategory\n      from automata.core.symbol.parser import parse_symbol\n      from automata.core.symbol.scip_pb2 import Index, SymbolRole\n      from automata.core.symbol.symbol_types import (\n          Symbol,\n          SymbolDescriptor,\n          SymbolFile,\n          SymbolReference,\n      )\n      from automata.core.symbol.symbol_utils import convert_to_fst_object, get_rankable_symbols\n      from automata.core.utils import config_fpath\n      \n      # SymbolGraph.SubGraph\n      \n      `SymbolGraph.SubGraph` is a data class responsible for maintaining the subgraph of a `SymbolGraph`. It contains a `parent` attribute to track the parent `SymbolGraph` instance, and a `graph` attribute representing the actual subgraph with nodes and edges.\n      \n      ## Overview\n      \n      The `SymbolGraph.SubGraph` class provides an interface to work with subgraphs of a `SymbolGraph`. It can be used, for example, to analyze a subgraph consisting of only rankable symbols. The class offers a convenient way to encapsulate subgraphs for further analysis, connecting it closely to the `SymbolGraph` class and related methods.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.graph.SymbolGraph`\n      - `automata.core.symbol.graph.SymbolGraph.get_rankable_symbol_subgraph`\n      - `networkx.DiGraph`\n      \n      ## Example\n      \n      The following is an example demonstrating how to obtain and use a `SymbolGraph.SubGraph` instance.\n      \n      ```python\n      from automata.core.symbol.graph import SymbolGraph\n      \n      # assuming the path to a valid index protobuf file\n      index_path = \"path/to/index.scip\"\n      symbol_graph = SymbolGraph(index_path=index_path)\n      \n      # Get a SubGraph consisting of only rankable symbols\n      subgraph = symbol_graph.get_rankable_symbol_subgraph()\n      \n      # Use the SubGraph for further analysis and processing\n      ```\n      \n      ## Limitations\n      \n      The main limitation of `SymbolGraph.SubGraph` is that it must be created from a `SymbolGraph` instance. This means that in order to use a `SymbolGraph.SubGraph`, you must first have a `SymbolGraph` from which you can extract the desired subgraph.\n      \n      ## Follow-up Questions:\n      \n      - How can we create `SymbolGraph.SubGraph` instances independent of the parent `SymbolGraph`?\n      - Are there any specific use cases where such independent `SymbolGraph.SubGraph` instances may be useful?\n      \n  Building context for related symbols -\n  \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.symbol.graph.SymbolGraph\n    \n        The `SymbolGraph` class represents a symbol graph that captures relationships between symbols found in source code files and is built from an index protobuf file. Utilizing NetworkX's MultiDiGraph, `SymbolGraph` represents relationships as a directed graph and includes methods for querying relationships, obtaining all available symbols and files, and filtering to subgraphs of rankable symbols. A navigator interface, _SymbolGraphNavigator, is required for getting reachable objects in the symbol subgraph.\n        \n        Example usage:\n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        \n        # Replace with your own file path\n        index_path = \"path/to/index.scip\"\n        symbol_graph = SymbolGraph(index_path)\n        all_symbols = symbol_graph.get_all_available_symbols()\n        ```\n        \n        Limitations include only being built from index protobuf files and the `get_potential_symbol_callers` method requiring downstream filtering to remove non-call statements. Future improvements may address these limitations and better handle edge cases in the symbol graph building process.\n        \n      Methods:\n        def __init__(\n                self, index_path: str = DEFAULT_SCIP_PATH, build_caller_relationships: bool = False\n            ):\n                \"\"\"\n                Initializes SymbolGraph with the path of an index protobuf file.\n        \n                Args:\n                    index_path (str): Path to index protobuf file\n                Returns:\n                    SymbolGraph instance\n                \"\"\"\n                index = self._load_index_protobuf(index_path)\n                builder = GraphBuilder(index, build_caller_relationships)\n                self._graph = builder.build_graph()\n                self.navigator = _SymbolGraphNavigator(self._graph)\n        \n            \n        get_all_available_symbols(self) -> List[Symbol]\n        \n        get_all_files(self) -> List[SymbolFile]\n        \n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n        get_rankable_symbol_subgraph(self, flow_rank=\"bidirectional\", path_filter: Optional[str] = None) -> SubGraph\n        \n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n    automata.tests.unit.test_symbol_graph.test_get_all_symbols\n    \n        def test_get_all_symbols(symbol_graph):\n            graph_symbols = symbol_graph.get_all_available_symbols()\n            assert isinstance(graph_symbols, list)\n            assert all(isinstance(s, Symbol) for s in graph_symbols)\n        \n        \n    automata.core.symbol.search.tests.conftest.symbol_graph_mock\n    \n        @pytest.fixture\n        def symbol_graph_mock(mocker):\n            mock = mocker.MagicMock(spec=SymbolGraph)\n            return mock\n        \n        \n    automata.tests.unit.test_symbol_rank.test_get_ranks_small_graph\n    \n        def test_get_ranks_small_graph():\n            G = DiGraph()\n            G.add_edge(1, 2)\n            G.add_edge(2, 3)\n            G.add_edge(3, 1)\n            config = SymbolRankConfig()\n            pagerank = SymbolRank(G, config)\n        \n            ranks = pagerank.get_ranks()\n            assert len(ranks) == 3\n            assert sum([ele[1] for ele in ranks]) == pytest.approx(1.0)\n        \n        \n    automata.core.symbol.graph.GraphBuilder\n    \n        `GraphBuilder` is a class that constructs a symbol graph from an `Index` object, facilitating the exploration of symbol relationships within source code. The resulting graph, a networkx `MultiDiGraph` object, allows for identifying symbol patterns and relationships in the codebase. While caller-callee relationships are not included by default due to performance concerns, they can be enabled by setting the `build_caller_relationships` flag to `True`. However, enabling this feature can result in significantly longer processing times due to the expensive computation.\n        \n        Example:\n        \n        ```python\n        from automata.core.symbol.graph import GraphBuilder\n        from automata.core.symbol.scip_pb2 import Index\n        \n        index = Index()  # Assuming a populated index object.\n        build_caller_relationships = True  # Optional\n        graph_builder = GraphBuilder(index, build_caller_relationships)\n        graph = graph_builder.build_graph()\n        ```\n        \n      Class Docstring:\n        Builds a symbol graph from an Index.\n        \n      Methods:\n        def __init__(self, index: Index, build_caller_relationships: bool = False):\n                \"\"\"\n                Args:\n                    index (Index): An Index object\n                    build_caller_relationships (bool, optional): Whether to build\n                        caller-callee relationships. Defaults to False.\n                \"\"\"\n                self.index = index\n                self.build_caller_relationships = build_caller_relationships\n                self._graph = nx.MultiDiGraph()\n        \n            \n        build_graph(self) -> None\n        \n    automata.core.symbol.search.tests.conftest.symbol_graph\n    \n        @pytest.fixture\n        def symbol_graph():\n            # assuming the path to a valid index protobuf file, you should replace it with your own file path\n            file_dir = os.path.dirname(os.path.abspath(__file__))\n            index_path = os.path.join(file_dir, \"index.scip\")\n            graph = SymbolGraph(index_path)\n            return graph\n        \n        \n        \n        \n    automata.tests.unit.conftest.symbol_graph\n    \n        @pytest.fixture\n        def symbol_graph():\n            # assuming the path to a valid index protobuf file, you should replace it with your own file path\n            file_dir = os.path.dirname(os.path.abspath(__file__))\n            index_path = os.path.join(file_dir, \"index.scip\")\n            graph = SymbolGraph(index_path)\n            return graph\n        \n        \n        \n        \n    automata.core.symbol.search.symbol_search.SymbolSearch\n    \n        `SymbolSearch` is a class used to search for symbols in a `SymbolGraph` by processing NLP-formatted queries and providing search results in various formats depending on the query type. The class utilizes a symbol similarity algorithm for ranking symbols according to relevance and a SymbolRank algorithm for computing a global symbol ranking. To use `SymbolSearch`, first initialize the necessary objects, such as `SymbolGraph` and `SymbolSimilarity`, then create a `SymbolSearch` object and process a query to obtain the search results.\n        \n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        from automata.core.embedding.symbol_similarity import SymbolSimilarity\n        from automata.core.symbol.search.symbol_search import SymbolSearch\n        \n        # Initialize necessary objects\n        symbol_graph = SymbolGraph()\n        symbol_similarity = SymbolSimilarity()\n        \n        # Create the SymbolSearch object\n        symbol_searcher = SymbolSearch(symbol_graph, symbol_similarity)\n        \n        # Process a query and get the search results\n        query = \"type:symbol_references <symbol_uri>\"\n        result = symbol_searcher.process_query(query)\n        ```\n        \n        Note that `SymbolSearch` relies on the availability of symbols in the `SymbolGraph` and `SymbolSimilarity` objects, and will produce incomplete or incorrect results if the necessary data is missing or the input query does not follow the expected format.\n        \n      Class Docstring:\n        Searches for symbols in a SymbolGraph\n        \n      Methods:\n        def __init__(\n                self,\n                symbol_graph: SymbolGraph,\n                symbol_similarity: SymbolSimilarity,\n                symbol_rank_config: Optional[SymbolRankConfig],\n                code_subgraph: Optional[SymbolGraph.SubGraph] = None,\n                *args,\n                **kwargs,\n            ):\n                \"\"\"\n                Args:\n                    symbol_graph (SymbolGraph): A SymbolGraph\n                    symbol_similarity (SymbolSimilarity): A SymbolSimilarity object\n                    symbol_rank_config (Optional[SymbolRankConfig]): A SymbolRankConfig object\n                    code_subgraph (Optional[SymbolGraph.SubGraph]): A subgraph of the SymbolGraph\n                \"\"\"\n        \n                if not code_subgraph:\n                    code_subgraph = symbol_graph.get_rankable_symbol_subgraph(\n                        kwargs.get(\"flow_rank\", \"bidirectional\")\n                    )\n                else:\n                    if not code_subgraph.parent == symbol_graph:\n                        raise ValueError(\"code_subgraph must be a subgraph of symbol_graph\")\n        \n                graph_symbols = symbol_graph.get_all_available_symbols()\n                embedding_symbols = symbol_similarity.embedding_handler.get_all_supported_symbols()\n                available_symbols = set(graph_symbols).intersection(set(embedding_symbols))\n                SymbolSearch.filter_graph(code_subgraph.graph, available_symbols)\n        \n                # TODO - Do we need to filter the SymbolGraph as well?\n                self.symbol_graph = symbol_graph\n                self.symbol_similarity = symbol_similarity\n                symbol_similarity.set_available_symbols(available_symbols)\n                self.symbol_rank = SymbolRank(code_subgraph.graph, config=symbol_rank_config)\n        \n            \n        exact_search(self, pattern: str) -> ExactSearchResult\n        \n        filter_graph(graph: nx.DiGraph, available_symbols: Set[Symbol]) -> None\n        \n        find_pattern_in_modules(pattern: str) -> Dict[str, List[int]]\n        \n        process_query(self, query: str) -> Union[SymbolReferencesResult, SymbolRankResult, SourceCodeResult, ExactSearchResult,]\n        \n        retrieve_source_code_by_symbol(self, symbol_uri: str) -> SourceCodeResult\n        \n        shifted_z_score_sq(values: Union[List[float], np.ndarray]) -> np.ndarray\n        \n        symbol_rank_search(self, query: str) -> SymbolRankResult\n        \n        symbol_references(self, symbol_uri: str) -> SymbolReferencesResult\n        \n        transform_dict_values(dictionary: Dict[Any, float], func: Callable[[List[float]], np.ndarray]\n            ) -> None\n        \n    automata.tests.unit.conftest.symbol_graph_mock\n    \n        @pytest.fixture\n        def symbol_graph_mock(mocker):\n            mock = mocker.MagicMock(spec=SymbolGraph)\n            return mock\n        \n        \n        \n        \n  Building context for dependencies -\n  \n    automata.core.utils.config_fpath\n    \n      Class Docstring:\n        Get the path to the project config directory\n        \n        Returns:\n        str - A fpath object in string form\n        \n      Methods:\n        config_fpath() -> str\n        \n    automata.config.config_enums.ConfigCategory\n    \n        class ConfigCategory(Enum):\n            \"\"\"\n            An enum which corresponds to the name of a folder holding config\n            \"\"\"\n        \n            PROMPT = \"prompt\"\n            SYMBOL = \"symbol\"\n        \n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.graph`/_CallerCalleeManager#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.graph", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "_CallerCalleeManager", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# _CallerCalleeManager\n\n`_CallerCalleeManager` is a class that manages the caller-callee relationships of a symbol in a graph. It processes the caller-callee relationships in the local graph in order to generate a connected graph of all symbols that call or are called by another symbol. This is an important step in analyzing how different components of code interact with one another.\n\n## Overview\n\nThe `_CallerCalleeManager` processes and maintains the caller-callee relationships by finding all symbols that call a given symbol or are called by a given symbol within the local graph. The processing of these relationships is an expensive operation and should be used sparingly. The class uses a `networkx` graph and a `_SymbolGraphNavigator` instance to carry out its operations.\n\n## Related Symbols\n\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.graph.GraphBuilder._process_caller_callee_relationships`\n- `automata.core.context.py_context.retriever.PyContextRetriever`\n- `automata.core.coding.py_coding.writer.PyCodeWriter`\n- `automata.core.symbol.graph._SymbolGraphNavigator.get_potential_symbol_callers`\n\n## Example\n\nThe following is an example demonstrating how to use the `_CallerCalleeManager` class to process caller-callee relationships.\n\n```python\nimport networkx as nx\nfrom automata.core.symbol.graph import _CallerCalleeManager\nfrom automata.core.symbol.graph import _SymbolGraphNavigator\n\n# Create a MultiDiGraph\ngraph = nx.MultiDiGraph()\n\n# Create a document with symbols\ndocument = ...\n\n# Initialize CallerCalleeManager\nmanager = _CallerCalleeManager(graph=graph, document=document)\n\n# Process caller-callee relationships in the graph\nmanager.process()\n```\n\n## Limitations\n\nThe `_CallerCalleeManager` has the limitation that it may include non-call statements, such as return statements, in its analysis. This is due to the current approach used in processing the relationships. Handling this limitation would require AST (Abstract Syntax Tree) awareness. Filtering for non-call statements is done downstream with the `ASTNavigator`.\n\n## Follow-up Questions:\n\n- Is there a more efficient approach to processing the caller-callee relationships within the `_CallerCalleeManager`?\n- How can the `_CallerCalleeManager` be improved to exclude non-call statements from its analysis?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class _CallerCalleeManager:\n    \"\"\"\n    Manages the caller-callee relationships of a symbol in a graph.\n    \"\"\"\n\n    def __init__(self, graph: nx.MultiDiGraph, document: Any):\n        \"\"\"\n        Args:\n            graph (nx.MultiDiGraph): A networkx graph\n            document (Any): A Document object\n        \"\"\"\n        self._graph = graph\n        self.navigator = _SymbolGraphNavigator(graph)\n        self.document = document\n\n    def process(self):\n        \"\"\"\n        Processes the caller-callee relationships in the local graph\n\n        Note that this is an expensive operation, and should be used sparingly\n        \"\"\"\n        for symbol in self.document.symbols:\n            try:\n                symbol_object = parse_symbol(symbol.symbol)\n            except Exception as e:\n                logger.error(f\"Parsing symbol {symbol.symbol} failed with error {e}\")\n                continue\n\n            if symbol_object.symbol_kind_by_suffix() != SymbolDescriptor.PyKind.Method:\n                continue\n\n            try:\n                references_in_scope = self.navigator._get_symbol_references_in_scope(symbol_object)\n            except Exception as e:\n                logger.error(\n                    f\"Failed to get references in scope for symbol {symbol} with error {e}\"\n                )\n                continue\n\n            for ref in references_in_scope:\n                try:\n                    if (\n                        ref.symbol.symbol_kind_by_suffix() == SymbolDescriptor.PyKind.Method\n                        or ref.symbol.symbol_kind_by_suffix() == SymbolDescriptor.PyKind.Class\n                    ):\n                        if ref.symbol == symbol_object:\n                            continue\n                        # TODO - This approach will include non-call statements, like return statements\n                        # unfortunately, this seems necessary to get the full set of callers\n                        # e.g. omitting classes appears to remove constructor calls for X, like X()\n                        # For, we filtering is done downstream with the ASTNavigator\n                        # with current understanding, it seems handling will require AST awareness\n                        self._graph.add_edge(\n                            symbol_object,\n                            ref.symbol,\n                            line_number=ref.line_number,\n                            column_number=ref.column_number,\n                            roles=ref.roles,\n                            label=\"caller\",\n                        )\n                        self._graph.add_edge(\n                            ref.symbol,\n                            symbol_object,\n                            line_number=ref.line_number,\n                            column_number=ref.column_number,\n                            roles=ref.roles,\n                            label=\"callee\",\n                        )\n                except Exception as e:\n                    logger.error(f\"Failed to add caller-callee edge for {symbol} with error {e} \")\n                    continue\n\n\n", "summary": "_CallerCalleeManager is a class that manages caller-callee relationships in a symbol graph by generating a connected graph of all symbols that call or are called by another symbol. This helps analyze how different components of code interact with each other. The class uses a networkx graph and a _SymbolGraphNavigator instance for its operations, making it resource-intensive and should be used sparingly. The manager has limitations, such as including non-call statements like return statements; resolving this limitation would require AST awareness.\n\nAn example of using the _CallerCalleeManager class:\n```python\nimport networkx as nx\nfrom automata.core.symbol.graph import _CallerCalleeManager\nfrom automata.core.symbol.graph import _SymbolGraphNavigator\n\n# Create a MultiDiGraph\ngraph = nx.MultiDiGraph()\n\n# Create a document with symbols\ndocument = ...\n\n# Initialize CallerCalleeManager\nmanager = _CallerCalleeManager(graph=graph, document=document)\n\n# Process caller-callee relationships in the graph\nmanager.process()\n```", "context": "\n    Generate the documentation for _CallerCalleeManager using the context shown below -\n  Building context for primary symbol - automata.core.symbol.graph._CallerCalleeManager -\n  \n    Import Statements:\n      import logging\n      import os\n      import networkx as nx\n      from dataclasses import dataclass\n      from typing import Any, Dict, List, Optional, Set\n      from google.protobuf.json_format import MessageToDict\n      from tqdm import tqdm\n      from automata.config.config_enums import ConfigCategory\n      from automata.core.symbol.parser import parse_symbol\n      from automata.core.symbol.scip_pb2 import Index, SymbolRole\n      from automata.core.symbol.symbol_types import (\n          Symbol,\n          SymbolDescriptor,\n          SymbolFile,\n          SymbolReference,\n      )\n      from automata.core.symbol.symbol_utils import convert_to_fst_object, get_rankable_symbols\n      from automata.core.utils import config_fpath\n      \n      # _CallerCalleeManager\n      \n      `_CallerCalleeManager` is a class that manages the caller-callee relationships of a symbol in a graph. It processes the caller-callee relationships in the local graph in order to generate a connected graph of all symbols that call or are called by another symbol. This is an important step in analyzing how different components of code interact with one another.\n      \n      ## Overview\n      \n      The `_CallerCalleeManager` processes and maintains the caller-callee relationships by finding all symbols that call a given symbol or are called by a given symbol within the local graph. The processing of these relationships is an expensive operation and should be used sparingly. The class uses a `networkx` graph and a `_SymbolGraphNavigator` instance to carry out its operations.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.graph.GraphBuilder._process_caller_callee_relationships`\n      - `automata.tests.unit.test_py_writer.MockCodeGenerator`\n      - `automata.core.context.py_context.retriever.PyContextRetriever`\n      - `automata.core.coding.py_coding.writer.PyCodeWriter`\n      - `automata.core.symbol.graph._SymbolGraphNavigator.get_potential_symbol_callers`\n      \n      ## Example\n      \n      The following is an example demonstrating how to use the `_CallerCalleeManager` class to process caller-callee relationships.\n      \n      ```python\n      import networkx as nx\n      from automata.core.symbol.graph import _CallerCalleeManager\n      from automata.core.symbol.graph import _SymbolGraphNavigator\n      \n      # Create a MultiDiGraph\n      graph = nx.MultiDiGraph()\n      \n      # Create a document with symbols\n      document = ...\n      \n      # Initialize CallerCalleeManager\n      manager = _CallerCalleeManager(graph=graph, document=document)\n      \n      # Process caller-callee relationships in the graph\n      manager.process()\n      ```\n      \n      ## Limitations\n      \n      The `_CallerCalleeManager` has the limitation that it may include non-call statements, such as return statements, in its analysis. This is due to the current approach used in processing the relationships. Handling this limitation would require AST (Abstract Syntax Tree) awareness. Filtering for non-call statements is done downstream with the `ASTNavigator`.\n      \n      ## Follow-up Questions:\n      \n      - Is there a more efficient approach to processing the caller-callee relationships within the `_CallerCalleeManager`?\n      - How can the `_CallerCalleeManager` be improved to exclude non-call statements from its analysis?\n      \n    Class Docstring:\n      Manages the caller-callee relationships of a symbol in a graph.\n      \n    Methods:\n      def __init__(self, graph: nx.MultiDiGraph, document: Any):\n              \"\"\"\n              Args:\n                  graph (nx.MultiDiGraph): A networkx graph\n                  document (Any): A Document object\n              \"\"\"\n              self._graph = graph\n              self.navigator = _SymbolGraphNavigator(graph)\n              self.document = document\n      \n          \n      def process(self):\n              \"\"\"\n              Processes the caller-callee relationships in the local graph\n      \n              Note that this is an expensive operation, and should be used sparingly\n              \"\"\"\n              for symbol in self.document.symbols:\n                  try:\n                      symbol_object = parse_symbol(symbol.symbol)\n                  except Exception as e:\n                      logger.error(f\"Parsing symbol {symbol.symbol} failed with error {e}\")\n                      continue\n      \n                  if symbol_object.symbol_kind_by_suffix() != SymbolDescriptor.PyKind.Method:\n                      continue\n      \n                  try:\n                      references_in_scope = self.navigator._get_symbol_references_in_scope(symbol_object)\n                  except Exception as e:\n                      logger.error(\n                          f\"Failed to get references in scope for symbol {symbol} with error {e}\"\n                      )\n                      continue\n      \n                  for ref in references_in_scope:\n                      try:\n                          if (\n                              ref.symbol.symbol_kind_by_suffix() == SymbolDescriptor.PyKind.Method\n                              or ref.symbol.symbol_kind_by_suffix() == SymbolDescriptor.PyKind.Class\n                          ):\n                              if ref.symbol == symbol_object:\n                                  continue\n                              # TODO - This approach will include non-call statements, like return statements\n                              # unfortunately, this seems necessary to get the full set of callers\n                              # e.g. omitting classes appears to remove constructor calls for X, like X()\n                              # For, we filtering is done downstream with the ASTNavigator\n                              # with current understanding, it seems handling will require AST awareness\n                              self._graph.add_edge(\n                                  symbol_object,\n                                  ref.symbol,\n                                  line_number=ref.line_number,\n                                  column_number=ref.column_number,\n                                  roles=ref.roles,\n                                  label=\"caller\",\n                              )\n                              self._graph.add_edge(\n                                  ref.symbol,\n                                  symbol_object,\n                                  line_number=ref.line_number,\n                                  column_number=ref.column_number,\n                                  roles=ref.roles,\n                                  label=\"callee\",\n                              )\n                      except Exception as e:\n                          logger.error(f\"Failed to add caller-callee edge for {symbol} with error {e} \")\n                          continue\n      \n      \n      \n  Building context for related symbols -\n  \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.symbol.graph.GraphBuilder._process_caller_callee_relationships\n    \n      Class Docstring:\n        Processes the caller-callee relationships in the local graph\n        \n        Args:\n        document (Any): A Document object\n        \n      Methods:\n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.core.context.py_context.retriever.PyContextRetriever\n    \n        PyContextRetriever is a class that retrieves the context of a symbol in a Python project, helping generate documentation and understanding symbol relationships. It processes abstract syntax tree (AST) nodes and operates on a SymbolGraph with a PyContextRetrieverConfig object. To use it, create a SymbolGraph instance, instantiate the PyContextRetriever with the graph, process a symbol using the `process_symbol` method, and retrieve the context buffer. Note that PyContextRetriever relies on accurate SymbolGraph and PyContextRetrieverConfig inputs; errors in these may cause issues when processing symbols. \n        \n        Usage Example:\n        \n        ```python\n        from automata.core.context.py_context.retriever import PyContextRetriever\n        from automata.core.symbol.graph import SymbolGraph\n        \n        graph = SymbolGraph()\n        py_context_retriever = PyContextRetriever(graph)\n        symbol = some_symbol\n        \n        # Process the context of the symbol\n        py_context_retriever.process_symbol(symbol)\n        \n        # Retrieve the context buffer\n        context_buffer = py_context_retriever.get_context_buffer()\n        ```\n        \n      Class Docstring:\n        The PyContextRetriever is used to retrieve the context of a symbol in a Python project\n        \n      Methods:\n        IndentManager(self) -> None\n        \n        def __init__(\n                self,\n                graph: SymbolGraph,\n                config: PyContextRetrieverConfig = PyContextRetrieverConfig(),\n                doc_embedding_db: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                Args:\n                    graph (SymbolGraph): The symbol graph to use\n                    config (PyContextRetrieverConfig): The configuration to use\n                \"\"\"\n                self.graph = graph\n                self.config = config\n                self.indent_level = 0\n                self.doc_embedding_db = doc_embedding_db\n                self.encoding = tiktoken.encoding_for_model(self.config.model_name)\n        \n                self.reset()\n        \n            \n        get_context_buffer(self) -> str\n        \n        indent() -> str\n        \n        process_ast(self, symbol: Symbol) -> None\n        \n        process_docstring(self, ast_object: RedBaron) -> None\n        \n        process_documentation(self, symbol: Symbol, is_main_symbol: bool) -> None\n        \n        process_headline(self, symbol: Symbol) -> None\n        \n        process_imports(self, symbol: Symbol) -> None\n        \n        process_message(self, message: str) -> None\n        \n        process_method(self, method: RedBaron, is_main_symbol: bool) -> None\n        \n        process_symbol(self,\n                symbol: Symbol,\n                related_symbols: List[Symbol] = [],\n            ) -> None\n        \n        reset(self) -> None\n        \n    automata.core.coding.py_coding.writer.PyCodeWriter\n    \n        PyCodeWriter is a utility class designed for writing and updating Python code in the Abstract Syntax Tree (AST) format, enabling programmatic manipulation of Python elements such as classes, functions, and imports. The main functionality includes initializing with a PyCodeRetriever instance, creating a new module object from source code, updating an existing module, and writing the updated module to disk. However, PyCodeWriter's primary limitation is its reliance on RedBaron, which has known limitations and bugs, along with relatively low support in recent years. Additionally, error reporting in PyCodeWriter can be improved for a better user experience. \n        \n        ```python\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        from automata.core.coding.py_coding.writer import PyCodeWriter\n        \n        # Initialize the PyCodeWriter with a PyCodeRetriever instance\n        retriever = PyCodeRetriever()\n        writer = PyCodeWriter(retriever)\n        \n        # Create a new module object from source code\n        module_dotpath = \"my_module\"\n        source_code = \"def hello():\\n    print('Hello, World!')\\n\"\n        writer.create_new_module(module_dotpath, source_code)\n        \n        # Update the existing module by adding a new function\n        new_function_code = \"def goodbye():\\n    print('Goodbye, World!')\\n\"\n        writer.update_existing_module(module_dotpath, new_function_code, do_write=True)\n        ```\n        \n      Class Docstring:\n        A utility class for writing Python code along AST nodes\n        \n      Methods:\n        def __init__(self, python_retriever: PyCodeRetriever):\n                \"\"\"\n                Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n                Args:\n                    python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n                \"\"\"\n                self.code_retriever = python_retriever\n        \n            \n        create_new_module(self, module_dotpath: str, source_code: str, do_write: bool = False) -> None\n        \n        delete_from_existing__module(self, module_dotpath: str, object_dotpath: str, do_write: bool = False) -> None\n        \n        replace(match) -> None\n        \n        replace_newline_chars(input_str: str) -> str\n        \n        update_existing_module(self,\n                module_dotpath: str,\n                source_code: str,\n                disambiguator: Optional[str] = \"\",\n                do_write: bool = False,\n            ) -> None\n        \n    automata.tests.unit.sample_modules.sample.EmptyClass\n    \n        class EmptyClass:\n            pass\n        \n        \n        \n        \n    automata.core.symbol.graph._SymbolGraphNavigator.get_potential_symbol_callers\n    \n      Class Docstring:\n        Gets all potential callers of a symbol\n        \n        Args:\n        symbol (Symbol): The symbol object to fetch callers for\n        \n        Returns:\n        Dict[Symbol, SymbolReference]: A dictionary of Symbol objects to\n        Symbol calleers (SymbolReference objects).\n        TODO - Remove non-call statements from this return object\n        \n      Methods:\n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n    automata.core.coding.py_coding.retriever.PyCodeRetriever\n    \n        `PyCodeRetriever` is a class designed to fetch Python code from a specified module, enabling the retrieval of source code, docstrings, and source code without docstrings for a given module, class, or function/method. Through methods like `get_docstring`, `get_source_code`, and `get_source_code_without_docstrings`, it offers a way to programmatically analyze, extract, and comprehend Python projects. However, this class assumes a specific directory structure for the modules and relies on the RedBaron library for parsing, which may have limitations when parsing complex or unconventional code patterns.\n        \n        An example usage of `PyCodeRetriever` for retrieving the source code of a function from a specified module is as follows:\n        \n        ```python\n        from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        \n        module_tree_map = LazyModuleTreeMap.cached_default()\n        code_retriever = PyCodeRetriever(module_tree_map)\n        \n        module_dotpath = \"mymodule.example\"\n        object_path = \"ExampleClass.example_function\"\n        \n        source_code = code_retriever.get_source_code(module_dotpath, object_path)\n        print(source_code)\n        ```\n        \n        \n      Class Docstring:\n        Code retriever for fetching python code\n        \n      Methods:\n        def __init__(self, module_tree_map: LazyModuleTreeMap = LazyModuleTreeMap.cached_default()):\n                self.module_tree_map = module_tree_map\n        \n            \n        get_docstring(self, module_dotpath: str, object_path: Optional[str]) -> str\n        \n        get_docstring_from_node(node: Optional[FSTNode]) -> str\n        \n        get_source_code(self, module_dotpath: str, object_path: Optional[str] = None) -> str\n        \n        get_source_code_without_docstrings(self, module_dotpath: str, object_path: Optional[str]\n            ) -> str\n        \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap\n    \n        The `LazyModuleTreeMap` class is a lazy dictionary that maps module dotpaths to their corresponding RedBaron FST objects, loading and caching the modules in memory as they are accessed. It provides methods for fetching existing module dotpaths and filepaths, as well as fetching, putting, and updating modules by their dotpaths. However, it assumes a specific directory structure according to the `DotPathMap` class and does not support custom directory structures for modules.\n        \n        ```python\n        from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n        from automata.core.utils import root_fpath\n        \n        path_to_root = root_fpath()\n        module_tree_map = LazyModuleTreeMap(path_to_root)\n        \n        # Fetch an existing module by its dotpath\n        module_dotpath = \"automata.core.agent.automata_agent\"\n        module = module_tree_map.fetch_module(module_dotpath)\n        \n        # Check if a module with the given dotpath exists\n        exists = module_dotpath in module_tree_map\n        ```\n        \n      Class Docstring:\n        A lazy dictionary between module dotpaths and their corresponding RedBaron FST objects.\n        Loads and caches modules in memory as they are accessed\n        \n      Methods:\n        __contains__(self, dotpath) -> None\n        \n        def __init__(self, path: str):\n                \"\"\"\n                Args:\n                    path: The absolute path to the root of the module tree\n                \"\"\"\n                self._dotpath_map = DotPathMap(path)\n                self._loaded_modules: Dict[str, Optional[RedBaron]] = {}\n        \n            \n        cached_default(cls) -> \"LazyModuleTreeMap\"\n        \n        fetch_existing_module_dotpath(self, module_obj: RedBaron) -> Optional[str]\n        \n        fetch_existing_module_fpath_by_dotpath(self, module_dotpath: str) -> Optional[str]\n        \n        fetch_module(self, module_dotpath: str) -> Optional[RedBaron]\n        \n        get_module_dotpath_by_fpath(self, module_fpath: str) -> str\n        \n        items(self) -> Iterable[Tuple[str, Optional[RedBaron]]]\n        \n        put_module(self, module_dotpath: str, module: RedBaron) -> None\n        \n    automata.core.symbol.graph._SymbolGraphNavigator.get_potential_symbol_callees\n    \n      Class Docstring:\n        Gets all potential callees of a symbol\n        \n        Args:\n        symbol (Symbol): The symbol object to fetch callees for\n        \n        Returns:\n        Dict[Symbol, SymbolReference]: A dictionary of Symbol objects to\n        Symbol callees (SymbolReference objects).\n        \n      Methods:\n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n  Building context for dependencies -\n  \n    automata.core.symbol.parser.parse_symbol\n    \n      Class Docstring:\n        Parses a symbol from a URI\n        \n        Args:\n        symbol_uri (str): The URI of the symbol\n        include_descriptors (bool): Whether to include descriptors in the symbol\n        \n        Returns:\n        Symbol - The parsed symbol\n        \n      Methods:\n        parse_symbol(symbol_uri: str, include_descriptors: bool = True) -> Symbol\n        \n    automata.core.symbol.symbol_types.SymbolDescriptor.PyKind\n    \n        `SymbolDescriptor` is a Python object representing the descriptor component of a URI within the `automata.core.symbol` framework. It serves as a building block for creating and parsing symbols and provides methods to work with descriptor components. For example, to create a `SymbolDescriptor` instance:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolDescriptor\n        from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n        \n        descriptor = SymbolDescriptor(\n            name=\"ActionIndicator\",\n            suffix=DescriptorProto.TYPE,\n        )\n        ```\n        \n        It is closely tied to the `automata.core.symbol` framework and may require updates if the underlying descriptor format or parser implementation changes.\n        \n    automata.core.symbol.graph._SymbolGraphNavigator\n    \n      Class Docstring:\n        Handles navigation of a symbol graph.\n        \n      Methods:\n        def __init__(self, graph: nx.MultiDiGraph):\n                \"\"\"\n                Args:\n                    graph (nx.MultiDiGraph): A networkx graph\n                \"\"\"\n                self._graph = graph\n        \n            \n        get_all_available_symbols(self) -> List[Symbol]\n        \n        get_all_files(self) -> List[SymbolFile]\n        \n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n    automata.core.symbol.graph.GraphBuilder\n    \n        `GraphBuilder` is a class that constructs a symbol graph from an `Index` object, facilitating the exploration of symbol relationships within source code. The resulting graph, a networkx `MultiDiGraph` object, allows for identifying symbol patterns and relationships in the codebase. While caller-callee relationships are not included by default due to performance concerns, they can be enabled by setting the `build_caller_relationships` flag to `True`. However, enabling this feature can result in significantly longer processing times due to the expensive computation.\n        \n        Example:\n        \n        ```python\n        from automata.core.symbol.graph import GraphBuilder\n        from automata.core.symbol.scip_pb2 import Index\n        \n        index = Index()  # Assuming a populated index object.\n        build_caller_relationships = True  # Optional\n        graph_builder = GraphBuilder(index, build_caller_relationships)\n        graph = graph_builder.build_graph()\n        ```\n        \n      Class Docstring:\n        Builds a symbol graph from an Index.\n        \n      Methods:\n        def __init__(self, index: Index, build_caller_relationships: bool = False):\n                \"\"\"\n                Args:\n                    index (Index): An Index object\n                    build_caller_relationships (bool, optional): Whether to build\n                        caller-callee relationships. Defaults to False.\n                \"\"\"\n                self.index = index\n                self.build_caller_relationships = build_caller_relationships\n                self._graph = nx.MultiDiGraph()\n        \n            \n        build_graph(self) -> None\n        \n    automata.core.symbol.graph._SymbolGraphNavigator._get_symbol_references_in_scope\n    \n      Class Docstring:\n        Gets all symbol references in the scope of a symbol\n        \n        Args:\n        symbol (Symbol): The symbol object to fetch references for\n        \n        Returns:\n        List[SymbolReference]: A list of SymbolReference objects in scope\n        \n      Methods:\n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.graph`/_OccurrenceManager#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.graph", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "_OccurrenceManager", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# _OccurrenceManager\n\nThe `_OccurrenceManager` is a class responsible for managing the occurrences of a symbol within a graph. It accepts a networkx graph and a document object as its arguments during initialization. The class provides a `process` method which processes the occurrences in the local graph, adding edges and information to the graph based on the occurrences' symbol, roles, and location within the document.\n\n## Overview\n\nThe `_OccurrenceManager` class is designed to manage occurrences of symbols within a graph. It initializes with a given graph and document and provides the `process` method for processing occurrences in the local graph. This method adds edges and information to the graph based on the occurrences' symbol, roles, and location within the document.\n\n## Related Symbols\n\n- `automata.core.symbol.graph.GraphBuilder._process_occurrences`\n- `automata.core.context.py_context.retriever.PyContextRetriever.IndentManager`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.tests.unit.sample_modules.sample_module_2.ObNMl`\n- `automata.core.context.py_context.retriever.PyContextRetriever`\n- `automata.core.symbol.graph._CallerCalleeManager`\n- `automata.core.embedding.symbol_similarity.SymbolSimilarity`\n- `automata.core.database.vector.JSONVectorDatabase`\n- `automata.core.symbol.graph.GraphBuilder`\n- `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n\n## Example\n\nThe following example demonstrates how to create an `_OccurrenceManager` object and process occurrences in a given graph and document.\n\n```python\nimport networkx as nx\nfrom automata.core.symbol.graph import _OccurrenceManager\n\n# Assume that graph and document are already defined\ngraph = nx.MultiDiGraph()\ndocument = ...\n\n# Initialize the _OccurrenceManager\noccurrence_manager = _OccurrenceManager(graph, document)\n\n# Process occurrences in the graph and document\noccurrence_manager.process()\n```\n\n## Limitations\n\nThe `_OccurrenceManager` class currently does not provide any functionality to remove, modify, or search for occurrences within the graph. Additionally, it does not support advanced queries or filtering on the processed occurrences.\n\n## Follow-up Questions:\n\n- What would be the appropriate way to remove or modify occurrences within the graph after processing with the `_OccurrenceManager`?\n- Can you provide an example of what advanced queries could be supported for `process` method or other parts of the `_OccurrenceManager`?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 7}, false, {"py/b64": "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"}]}]}, "source_code": "class _OccurrenceManager:\n    \"\"\"\n    Manages the occurrences of a symbol in a graph\n    \"\"\"\n\n    def __init__(self, graph: nx.MultiDiGraph, document: Any):\n        \"\"\"\n        Args:\n            graph (nx.MultiDiGraph): A networkx graph\n            document (Any): A Document object\n        \"\"\"\n        self._graph = graph\n        self.document = document\n\n    def process(self):\n        \"\"\"\n        Processes the occurrences in the local graph\n        \"\"\"\n        for occurrence in self.document.occurrences:\n            try:\n                occurrence_symbol = parse_symbol(occurrence.symbol)\n            except Exception as e:\n                logger.error(f\"Parsing symbol {occurrence.symbol} failed with error {e}\")\n                continue\n\n            occurrence_range = tuple(occurrence.range)\n            occurrence_roles = _OccurrenceManager._process_symbol_roles(occurrence.symbol_roles)\n            occurrence_reference = SymbolReference(\n                symbol=occurrence_symbol,\n                line_number=occurrence_range[0],\n                column_number=occurrence_range[1],\n                roles=occurrence_roles,\n            )\n            self._graph.add_edge(\n                occurrence_symbol,\n                self.document.relative_path,\n                symbol_reference=occurrence_reference,\n                label=\"reference\",\n            )\n            if occurrence_roles.get(SymbolRole.Name(SymbolRole.Definition)):\n                # TODO this is gross\n                incorrect_contains_edges = [\n                    (source, target)\n                    for source, target, data in self._graph.in_edges(occurrence_symbol, data=True)\n                    if data.get(\"label\") == \"contains\"\n                ]\n                for source, target in incorrect_contains_edges:\n                    self._graph.remove_edge(source, target)\n\n                self._graph.add_edge(\n                    self.document.relative_path,\n                    occurrence_symbol,\n                    label=\"contains\",\n                )\n\n    @staticmethod\n    def _process_symbol_roles(role: int) -> Dict[str, bool]:\n        \"\"\"\n        Processes the symbol roles into a dictionary of role names to booleans\n\n        Args:\n            role (int): The symbol role\n        \"\"\"\n        result = {}\n        for role_name, role_value in SymbolRole.items():\n            if (role & role_value) > 0:\n                result[role_name] = (role & role_value) > 0\n        return result\n\n\n", "summary": "The `_OccurrenceManager` class is responsible for managing the occurrences of a symbol within a networkx graph, taking a graph and a document object as its arguments. The class provides a `process` method, which processes the occurrences in the local graph, adding edges and information based on the symbol, roles, and location within the document. However, the class currently lacks functionality to remove, modify, or search for occurrences within the graph and does not support advanced queries or filtering on the processed occurrences.", "context": "\n    Generate the documentation for _OccurrenceManager using the context shown below -\n  Building context for primary symbol - automata.core.symbol.graph._OccurrenceManager -\n  \n    Import Statements:\n      import logging\n      import os\n      import networkx as nx\n      from dataclasses import dataclass\n      from typing import Any, Dict, List, Optional, Set\n      from google.protobuf.json_format import MessageToDict\n      from tqdm import tqdm\n      from automata.config.config_enums import ConfigCategory\n      from automata.core.symbol.parser import parse_symbol\n      from automata.core.symbol.scip_pb2 import Index, SymbolRole\n      from automata.core.symbol.symbol_types import (\n          Symbol,\n          SymbolDescriptor,\n          SymbolFile,\n          SymbolReference,\n      )\n      from automata.core.symbol.symbol_utils import convert_to_fst_object, get_rankable_symbols\n      from automata.core.utils import config_fpath\n      \n      # _OccurrenceManager\n      \n      `_OccurrenceManager` class manages the occurrences of a symbol in a graph. It consists of methods to initialize the class with a given graph and document, as well as process the occurrences in the local graph.\n      \n      ## Overview\n      \n      The `_OccurrenceManager` is responsible for managing the occurrences of a symbol within a graph. It accepts a networkx graph and a document object as its arguments during initialization. The class provides a `process` method which processes the occurrences in the local graph, adding edges and information to the graph based on the occurrences' symbol, roles, and location within the document.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.graph.GraphBuilder._process_occurrences`\n      - `automata.core.context.py_context.retriever.PyContextRetriever.IndentManager`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.tests.unit.sample_modules.sample_module_2.ObNMl`\n      - `automata.core.context.py_context.retriever.PyContextRetriever`\n      - `automata.core.symbol.graph._CallerCalleeManager`\n      - `automata.core.embedding.symbol_similarity.SymbolSimilarity`\n      - `automata.core.database.vector.JSONVectorDatabase`\n      - `automata.core.symbol.graph.GraphBuilder`\n      - `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n      \n      ## Example\n      \n      The following example demonstrates how to create an `_OccurrenceManager` object and process occurrences in a given graph and document.\n      \n      ```python\n      import networkx as nx\n      from automata.core.symbol.graph import _OccurrenceManager\n      \n      # Assume that graph and document are already defined\n      graph = nx.MultiDiGraph()\n      document = ...\n      \n      # Initialize the _OccurrenceManager\n      occurrence_manager = _OccurrenceManager(graph, document)\n      \n      # Process occurrences in the graph and document\n      occurrence_manager.process()\n      ```\n      \n      ## Limitations\n      \n      The `_OccurrenceManager` class currently does not provide any functionality to remove, modify, or search for occurrences within the graph. Additionally, it does not support advanced queries or filtering on the processed occurrences.\n      \n      ## Follow-up Questions:\n      \n      - What would be the appropriate way to remove or modify occurrences within the graph after processing with the `_OccurrenceManager`?\n      - Can you provide an example of what advanced queries could be supported for `process` method or other parts of the `_OccurrenceManager`?\n      \n    Class Docstring:\n      Manages the occurrences of a symbol in a graph\n      \n    Methods:\n      def __init__(self, graph: nx.MultiDiGraph, document: Any):\n              \"\"\"\n              Args:\n                  graph (nx.MultiDiGraph): A networkx graph\n                  document (Any): A Document object\n              \"\"\"\n              self._graph = graph\n              self.document = document\n      \n          \n      def process(self):\n              \"\"\"\n              Processes the occurrences in the local graph\n              \"\"\"\n              for occurrence in self.document.occurrences:\n                  try:\n                      occurrence_symbol = parse_symbol(occurrence.symbol)\n                  except Exception as e:\n                      logger.error(f\"Parsing symbol {occurrence.symbol} failed with error {e}\")\n                      continue\n      \n                  occurrence_range = tuple(occurrence.range)\n                  occurrence_roles = _OccurrenceManager._process_symbol_roles(occurrence.symbol_roles)\n                  occurrence_reference = SymbolReference(\n                      symbol=occurrence_symbol,\n                      line_number=occurrence_range[0],\n                      column_number=occurrence_range[1],\n                      roles=occurrence_roles,\n                  )\n                  self._graph.add_edge(\n                      occurrence_symbol,\n                      self.document.relative_path,\n                      symbol_reference=occurrence_reference,\n                      label=\"reference\",\n                  )\n                  if occurrence_roles.get(SymbolRole.Name(SymbolRole.Definition)):\n                      # TODO this is gross\n                      incorrect_contains_edges = [\n                          (source, target)\n                          for source, target, data in self._graph.in_edges(occurrence_symbol, data=True)\n                          if data.get(\"label\") == \"contains\"\n                      ]\n                      for source, target in incorrect_contains_edges:\n                          self._graph.remove_edge(source, target)\n      \n                      self._graph.add_edge(\n                          self.document.relative_path,\n                          occurrence_symbol,\n                          label=\"contains\",\n                      )\n      \n          \n  Building context for related symbols -\n  \n    automata.core.symbol.graph.GraphBuilder._process_occurrences\n    \n      Class Docstring:\n        Processes the occurrences in the local graph\n        \n        Args:\n        document (Any): A Document object\n        \n      Methods:\n    automata.core.context.py_context.retriever.PyContextRetriever.IndentManager\n    \n      Class Docstring:\n        A context manager to manage the indentation level\n        \n      Methods:\n        IndentManager(self) -> None\n        \n    automata.core.context.py_context.retriever.PyContextRetriever\n    \n        PyContextRetriever is a class that retrieves the context of a symbol in a Python project, helping generate documentation and understanding symbol relationships. It processes abstract syntax tree (AST) nodes and operates on a SymbolGraph with a PyContextRetrieverConfig object. To use it, create a SymbolGraph instance, instantiate the PyContextRetriever with the graph, process a symbol using the `process_symbol` method, and retrieve the context buffer. Note that PyContextRetriever relies on accurate SymbolGraph and PyContextRetrieverConfig inputs; errors in these may cause issues when processing symbols. \n        \n        Usage Example:\n        \n        ```python\n        from automata.core.context.py_context.retriever import PyContextRetriever\n        from automata.core.symbol.graph import SymbolGraph\n        \n        graph = SymbolGraph()\n        py_context_retriever = PyContextRetriever(graph)\n        symbol = some_symbol\n        \n        # Process the context of the symbol\n        py_context_retriever.process_symbol(symbol)\n        \n        # Retrieve the context buffer\n        context_buffer = py_context_retriever.get_context_buffer()\n        ```\n        \n      Class Docstring:\n        The PyContextRetriever is used to retrieve the context of a symbol in a Python project\n        \n      Methods:\n        IndentManager(self) -> None\n        \n        def __init__(\n                self,\n                graph: SymbolGraph,\n                config: PyContextRetrieverConfig = PyContextRetrieverConfig(),\n                doc_embedding_db: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                Args:\n                    graph (SymbolGraph): The symbol graph to use\n                    config (PyContextRetrieverConfig): The configuration to use\n                \"\"\"\n                self.graph = graph\n                self.config = config\n                self.indent_level = 0\n                self.doc_embedding_db = doc_embedding_db\n                self.encoding = tiktoken.encoding_for_model(self.config.model_name)\n        \n                self.reset()\n        \n            \n        get_context_buffer(self) -> str\n        \n        indent() -> str\n        \n        process_ast(self, symbol: Symbol) -> None\n        \n        process_docstring(self, ast_object: RedBaron) -> None\n        \n        process_documentation(self, symbol: Symbol, is_main_symbol: bool) -> None\n        \n        process_headline(self, symbol: Symbol) -> None\n        \n        process_imports(self, symbol: Symbol) -> None\n        \n        process_message(self, message: str) -> None\n        \n        process_method(self, method: RedBaron, is_main_symbol: bool) -> None\n        \n        process_symbol(self,\n                symbol: Symbol,\n                related_symbols: List[Symbol] = [],\n            ) -> None\n        \n        reset(self) -> None\n        \n    automata.core.symbol.graph._CallerCalleeManager\n    \n        The _CallerCalleeManager class manages caller-callee relationships of a symbol in a graph by processing all symbols that call or are called by another symbol within the local graph. This is crucial for understanding how different components of code interact with one another. However, processing these relationships is computationally expensive, so it should be used sparingly. The class relies on a networkx graph and a _SymbolGraphNavigator instance for its operations. There are limitations, such as including non-call statements, which can be mitigated with AST awareness and filtering downstream using the ASTNavigator.\n        \n        Example usage:\n        \n        ```python\n        import networkx as nx\n        from automata.core.symbol.graph import _CallerCalleeManager\n        from automata.core.symbol.graph import _SymbolGraphNavigator\n        \n        # Create a MultiDiGraph\n        graph = nx.MultiDiGraph()\n        \n        # Create a document with symbols\n        document = ...\n        \n        # Initialize CallerCalleeManager\n        manager = _CallerCalleeManager(graph=graph, document=document)\n        \n        # Process caller-callee relationships in the graph\n        manager.process()\n        ```\n        \n      Class Docstring:\n        Manages the caller-callee relationships of a symbol in a graph.\n        \n      Methods:\n        def __init__(self, graph: nx.MultiDiGraph, document: Any):\n                \"\"\"\n                Args:\n                    graph (nx.MultiDiGraph): A networkx graph\n                    document (Any): A Document object\n                \"\"\"\n                self._graph = graph\n                self.navigator = _SymbolGraphNavigator(graph)\n                self.document = document\n        \n            \n        process(self) -> None\n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl\n    \n        class ObNMl:\n            \"\"\"zFsdXovhQSBlqDNpXSvl\"\"\"\n        \n            def __init__(self):\n                pass\n        \n            def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.embedding.symbol_similarity.SymbolSimilarity\n    \n        `SymbolSimilarity` is a class that computes similarity scores between query texts and symbols using embeddings, and allows users to retrieve the most similar symbols for a specific query and create a dictionary mapping the similarity scores to each symbol. Users can set the available symbols for the calculation, and the similarity scores depend on the quality of the supplied pre-trained embeddings and selected norm type. The class uses a `SymbolCodeEmbeddingHandler` for handling embeddings, which affects the accuracy of the results.\n        \n        Example usage of `SymbolSimilarity`:\n        ```python\n        import numpy as np\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        from automata.core.embedding.embedding_types import EmbeddingProvider, NormType\n        from automata.core.embedding.symbol_similarity import SymbolSimilarity\n        \n        embedding_handler = SymbolCodeEmbeddingHandler(embedding_db=embedding_db, embedding_provider=embedding_provider)\n        symbol_similarity = SymbolSimilarity(symbol_embedding_manager=embedding_handler, norm_type=NormType.L2)\n        symbol_similarity.set_available_symbols(available_symbols)\n        nearest_entries = symbol_similarity.get_nearest_entries_for_query(\"example query\", k=5)\n        query_similarity_dict = symbol_similarity.get_query_similarity_dict(\"example query\")\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                symbol_embedding_manager: SymbolCodeEmbeddingHandler,\n                norm_type: NormType = NormType.L2,\n            ):\n                \"\"\"\n                Initialize SymbolSimilarity\n        \n                Args:\n                    symbol_embedding_manager: A CodeEmbeddingManager\n                    norm_type (NormType): The norm type to use for calculating similarity\n        \n                Returns:\n                    An instance of SymbolSimilarity\n                \"\"\"\n                self.embedding_handler: SymbolCodeEmbeddingHandler = symbol_embedding_manager\n                self.embedding_provider: EmbeddingProvider = symbol_embedding_manager.embedding_provider\n                self.norm_type = norm_type\n                supported_symbols = self.embedding_handler.get_all_supported_symbols()\n                self.index_to_symbol = {i: symbol for i, symbol in enumerate(supported_symbols)}\n                self.symbol_to_index = {symbol: i for i, symbol in enumerate(supported_symbols)}\n                self.available_symbols: Optional[Set[Symbol]] = None\n        \n            \n        get_available_symbols(self) -> List[Symbol]\n        \n        get_nearest_entries_for_query(self, query_text: str, k: int = 10) -> Dict[Symbol, float]\n        \n        get_query_similarity_dict(self, query_text: str) -> Dict[Symbol, float]\n        \n        set_available_symbols(self, available_symbols: Set[Symbol]) -> None\n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.core.symbol.graph.GraphBuilder\n    \n        `GraphBuilder` is a class that constructs a symbol graph from an `Index` object, facilitating the exploration of symbol relationships within source code. The resulting graph, a networkx `MultiDiGraph` object, allows for identifying symbol patterns and relationships in the codebase. While caller-callee relationships are not included by default due to performance concerns, they can be enabled by setting the `build_caller_relationships` flag to `True`. However, enabling this feature can result in significantly longer processing times due to the expensive computation.\n        \n        Example:\n        \n        ```python\n        from automata.core.symbol.graph import GraphBuilder\n        from automata.core.symbol.scip_pb2 import Index\n        \n        index = Index()  # Assuming a populated index object.\n        build_caller_relationships = True  # Optional\n        graph_builder = GraphBuilder(index, build_caller_relationships)\n        graph = graph_builder.build_graph()\n        ```\n        \n      Class Docstring:\n        Builds a symbol graph from an Index.\n        \n      Methods:\n        def __init__(self, index: Index, build_caller_relationships: bool = False):\n                \"\"\"\n                Args:\n                    index (Index): An Index object\n                    build_caller_relationships (bool, optional): Whether to build\n                        caller-callee relationships. Defaults to False.\n                \"\"\"\n                self.index = index\n                self.build_caller_relationships = build_caller_relationships\n                self._graph = nx.MultiDiGraph()\n        \n            \n        build_graph(self) -> None\n        \n  Building context for dependencies -\n  \n    automata.core.symbol.parser.parse_symbol\n    \n      Class Docstring:\n        Parses a symbol from a URI\n        \n        Args:\n        symbol_uri (str): The URI of the symbol\n        include_descriptors (bool): Whether to include descriptors in the symbol\n        \n        Returns:\n        Symbol - The parsed symbol\n        \n      Methods:\n        parse_symbol(symbol_uri: str, include_descriptors: bool = True) -> Symbol\n        \n    automata.core.symbol.symbol_types.SymbolReference\n    \n        `SymbolReference` is a class representing a reference to a symbol in a file, used for managing references to symbols within a codebase. It offers utility methods for comparing and hashing symbol references based on their URI, line number, and column number. In conjunction with other symbol-related classes, it helps track and manage references to symbols in files based on their location and usage. However, there is a potential limitation of causing collisions when the same symbol is referenced in different files at the same location (line and column). This is rare, but important to consider when working with multiple symbol references across files.\n        \n        Example usage: \n        ```python\n        from automata.core.symbol.symbol_types import SymbolReference\n        from automata.core.symbol.parser import parse_symbol\n        \n        symbol_uri = \"example_uri\"\n        line_number = 10\n        column_number = 5\n        symbol = parse_symbol(symbol_uri)\n        \n        symbol_ref1 = SymbolReference(symbol, line_number, column_number)\n        symbol_ref2 = SymbolReference(symbol, line_number + 1, column_number)\n        \n        assert symbol_ref1 != symbol_ref2\n        assert hash(symbol_ref1) != hash(symbol_ref2)\n        \n        symbol_ref3 = SymbolReference(symbol, line_number, column_number)\n        assert symbol_ref1 == symbol_ref3\n        ```\n        \n      Class Docstring:\n        Represents a reference to a symbol in a file\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.graph`/_RelationshipManager#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.graph", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "_RelationshipManager", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# _RelationshipManager\n\n`_RelationshipManager` is a class that manages the relationships between symbols in a graph. It is used internally by the `GraphManager` and related classes in the `automata.core.symbol.graph` package. The main functionality of the class is to process relationships between symbols and add them as edges in the given graph.\n\n## Overview\n\nThe `_RelationshipManager` class is initialized with a `networkx` graph and a `SymbolInformation` object. The `process` method takes these relationships and adds them as edges in the graph. \n\n## Related Symbols\n\n- `automata.core.symbol.graph._CallerCalleeManager`\n- `automata.core.symbol.graph.GraphBuilder`\n- `automata.core.symbol.graph._SymbolGraphNavigator.get_symbol_relationships`\n- `automata.core.symbol.symbol_types.Symbol`\n\n## Usage Example\n\nThis example demonstrates how to create a `_RelationshipManager` and process symbol relationships in a sample `networkx` graph:\n\n```python\nimport networkx as nx\nfrom automata.core.symbol.graph import _RelationshipManager\nfrom automata.core.utils import config_fpath\n\n# Create a sample SymbolInformation object\nsymbol_information = ...\ngraph = nx.MultiDiGraph()\n\n# Create a _RelationshipManager instance\nrelationship_manager = _RelationshipManager(graph=graph, symbol_information=symbol_information)\n\n# Process the relationships in the local graph\nrelationship_manager.process()\n```\n\n## Limitations\n\nThe `_RelationshipManager` class is designed to be used internally by other classes in the `automata.core.symbol.graph` package. It relies on correct and consistent input from the `SymbolInformation` object and may not handle errors gracefully.\n\n## Follow-up Questions:\n\n- How can we improve error handling and robustness in the `_RelationshipManager` class?\n- Can the `_RelationshipManager` be used in isolation for specific use cases or is it strictly an internal class?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/reduce": [{"py/type": "numpy.dtype"}, {"py/tuple": ["f8", false, true]}, {"py/tuple": [3, "<", null, null, null, -1, -1, 0]}]}, false, {"py/b64": "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"}]}]}, "source_code": "class _RelationshipManager:\n    \"\"\"\n    Manages the relationships between symbols in a graph\n    \"\"\"\n\n    def __init__(self, graph: nx.MultiDiGraph, symbol_information: Any):\n        \"\"\"\n        Args:\n            graph (nx.MultiDiGraph): A networkx graph\n            symbol_information (Any): A SymbolInformation object\n        \"\"\"\n        self._graph = graph\n        self.symbol_information = symbol_information\n\n    def process(self):\n        \"\"\"\n        Processes the relationships in the local graph\n        \"\"\"\n        for relationship in self.symbol_information.relationships:\n            relationship_labels = MessageToDict(relationship)\n            relationship_labels.pop(\"symbol\")\n            related_symbol = parse_symbol(relationship.symbol)\n            self._graph.add_edge(\n                self.symbol_information.symbol,\n                related_symbol,\n                label=\"relationship\",\n                **relationship_labels,\n            )\n\n\n", "summary": "The `_RelationshipManager` is a class that manages relationships between symbols in a graph, primarily processing these relationships and representing them as edges in a given graph. It is initialized with a `networkx` graph and a `SymbolInformation` object and is designed to be used internally by the `GraphManager` and related classes in the `automata.core.symbol.graph` package. An example of creating a `_RelationshipManager` instance and processing symbol relationships in a sample `networkx` graph is provided in the documentation. It relies on correct and consistent input from the `SymbolInformation` object and may not handle errors gracefully.", "context": "\n    Generate the documentation for _RelationshipManager using the context shown below -\n  Building context for primary symbol - automata.core.symbol.graph._RelationshipManager -\n  \n    Import Statements:\n      import logging\n      import os\n      import networkx as nx\n      from dataclasses import dataclass\n      from typing import Any, Dict, List, Optional, Set\n      from google.protobuf.json_format import MessageToDict\n      from tqdm import tqdm\n      from automata.config.config_enums import ConfigCategory\n      from automata.core.symbol.parser import parse_symbol\n      from automata.core.symbol.scip_pb2 import Index, SymbolRole\n      from automata.core.symbol.symbol_types import (\n          Symbol,\n          SymbolDescriptor,\n          SymbolFile,\n          SymbolReference,\n      )\n      from automata.core.symbol.symbol_utils import convert_to_fst_object, get_rankable_symbols\n      from automata.core.utils import config_fpath\n      \n      # _RelationshipManager\n      \n      `_RelationshipManager` is a class that manages the relationships between symbols in a graph. It is used internally by the `GraphManager` and related classes in the `automata.core.symbol.graph` package. The main functionality of the class is to process relationships between symbols and add them as edges in the given graph.\n      \n      ## Overview\n      \n      The `_RelationshipManager` class is initialized with a `networkx` graph and a `SymbolInformation` object. The `process` method takes these relationships and adds them as edges in the graph. \n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.graph._CallerCalleeManager`\n      - `automata.core.symbol.graph.GraphBuilder`\n      - `automata.core.symbol.graph._SymbolGraphNavigator.get_symbol_relationships`\n      - `automata.core.symbol.symbol_types.Symbol`\n      \n      ## Example\n      \n      This example demonstrates how to create a `_RelationshipManager` and process symbol relationships in a sample `networkx` graph:\n      \n      ```python\n      import networkx as nx\n      from automata.core.symbol.graph import _RelationshipManager\n      from automata.core.utils import config_fpath\n      \n      # Create a sample SymbolInformation object\n      symbol_information = ...\n      graph = nx.MultiDiGraph()\n      \n      # Create a _RelationshipManager instance\n      relationship_manager = _RelationshipManager(graph=graph, symbol_information=symbol_information)\n      \n      # Process the relationships in the local graph\n      relationship_manager.process()\n      ```\n      \n      ## Limitations\n      \n      The `_RelationshipManager` class is designed to be used internally by other classes in the `automata.core.symbol.graph` package. It relies on correct and consistent input from the `SymbolInformation` object and may not handle errors gracefully.\n      \n      ## Follow-up Questions:\n      \n      - How can we improve error handling and robustness in the `_RelationshipManager` class?\n      - Can the `_RelationshipManager` be used in isolation for specific use cases or is it strictly an internal class?\n      \n    Class Docstring:\n      Manages the relationships between symbols in a graph\n      \n    Methods:\n      def __init__(self, graph: nx.MultiDiGraph, symbol_information: Any):\n              \"\"\"\n              Args:\n                  graph (nx.MultiDiGraph): A networkx graph\n                  symbol_information (Any): A SymbolInformation object\n              \"\"\"\n              self._graph = graph\n              self.symbol_information = symbol_information\n      \n          \n      def process(self):\n              \"\"\"\n              Processes the relationships in the local graph\n              \"\"\"\n              for relationship in self.symbol_information.relationships:\n                  relationship_labels = MessageToDict(relationship)\n                  relationship_labels.pop(\"symbol\")\n                  related_symbol = parse_symbol(relationship.symbol)\n                  self._graph.add_edge(\n                      self.symbol_information.symbol,\n                      related_symbol,\n                      label=\"relationship\",\n                      **relationship_labels,\n                  )\n      \n      \n      \n  Building context for related symbols -\n  \n    automata.core.symbol.graph._CallerCalleeManager\n    \n        The _CallerCalleeManager class manages caller-callee relationships of a symbol in a graph by processing all symbols that call or are called by another symbol within the local graph. This is crucial for understanding how different components of code interact with one another. However, processing these relationships is computationally expensive, so it should be used sparingly. The class relies on a networkx graph and a _SymbolGraphNavigator instance for its operations. There are limitations, such as including non-call statements, which can be mitigated with AST awareness and filtering downstream using the ASTNavigator.\n        \n        Example usage:\n        \n        ```python\n        import networkx as nx\n        from automata.core.symbol.graph import _CallerCalleeManager\n        from automata.core.symbol.graph import _SymbolGraphNavigator\n        \n        # Create a MultiDiGraph\n        graph = nx.MultiDiGraph()\n        \n        # Create a document with symbols\n        document = ...\n        \n        # Initialize CallerCalleeManager\n        manager = _CallerCalleeManager(graph=graph, document=document)\n        \n        # Process caller-callee relationships in the graph\n        manager.process()\n        ```\n        \n      Class Docstring:\n        Manages the caller-callee relationships of a symbol in a graph.\n        \n      Methods:\n        def __init__(self, graph: nx.MultiDiGraph, document: Any):\n                \"\"\"\n                Args:\n                    graph (nx.MultiDiGraph): A networkx graph\n                    document (Any): A Document object\n                \"\"\"\n                self._graph = graph\n                self.navigator = _SymbolGraphNavigator(graph)\n                self.document = document\n        \n            \n        process(self) -> None\n        \n    automata.core.symbol.graph.GraphBuilder\n    \n        `GraphBuilder` is a class that constructs a symbol graph from an `Index` object, facilitating the exploration of symbol relationships within source code. The resulting graph, a networkx `MultiDiGraph` object, allows for identifying symbol patterns and relationships in the codebase. While caller-callee relationships are not included by default due to performance concerns, they can be enabled by setting the `build_caller_relationships` flag to `True`. However, enabling this feature can result in significantly longer processing times due to the expensive computation.\n        \n        Example:\n        \n        ```python\n        from automata.core.symbol.graph import GraphBuilder\n        from automata.core.symbol.scip_pb2 import Index\n        \n        index = Index()  # Assuming a populated index object.\n        build_caller_relationships = True  # Optional\n        graph_builder = GraphBuilder(index, build_caller_relationships)\n        graph = graph_builder.build_graph()\n        ```\n        \n      Class Docstring:\n        Builds a symbol graph from an Index.\n        \n      Methods:\n        def __init__(self, index: Index, build_caller_relationships: bool = False):\n                \"\"\"\n                Args:\n                    index (Index): An Index object\n                    build_caller_relationships (bool, optional): Whether to build\n                        caller-callee relationships. Defaults to False.\n                \"\"\"\n                self.index = index\n                self.build_caller_relationships = build_caller_relationships\n                self._graph = nx.MultiDiGraph()\n        \n            \n        build_graph(self) -> None\n        \n    automata.core.symbol.graph._SymbolGraphNavigator.get_symbol_relationships\n    \n      Methods:\n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl\n    \n        class ObNMl:\n            \"\"\"zFsdXovhQSBlqDNpXSvl\"\"\"\n        \n            def __init__(self):\n                pass\n        \n            def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.core.symbol.graph.GraphBuilder._process_relationships\n    \n      Class Docstring:\n        Processes the relationships in the local graph\n        \n        Args:\n        document (Any): A Document object\n        \n      Methods:\n    automata.tests.unit.sample_modules.sample.Person\n    \n        class Person:\n            \"\"\"This is a sample class.\"\"\"\n        \n            def __init__(self, name):\n                \"\"\"This is the constructor.\"\"\"\n                self.name = name\n        \n            def say_hello(self):\n                \"\"\"This is a sample method.\"\"\"\n                return f\"Hello, I am {self.name}.\"\n        \n            def run(self) -> str:\n                ...\n        \n        \n        \n        \n    automata.core.symbol.graph._CallerCalleeManager.process\n    \n      Class Docstring:\n        Processes the caller-callee relationships in the local graph\n        \n        Note that this is an expensive operation, and should be used sparingly\n        \n      Methods:\n        process(self) -> None\n        \n    automata.core.symbol.graph.GraphBuilder._process_caller_callee_relationships\n    \n      Class Docstring:\n        Processes the caller-callee relationships in the local graph\n        \n        Args:\n        document (Any): A Document object\n        \n      Methods:\n    automata.tests.unit.sample_modules.sample.EmptyClass\n    \n        class EmptyClass:\n            pass\n        \n        \n        \n        \n  Building context for dependencies -\n  \n    automata.core.symbol.parser.parse_symbol\n    \n      Class Docstring:\n        Parses a symbol from a URI\n        \n        Args:\n        symbol_uri (str): The URI of the symbol\n        include_descriptors (bool): Whether to include descriptors in the symbol\n        \n        Returns:\n        Symbol - The parsed symbol\n        \n      Methods:\n        parse_symbol(symbol_uri: str, include_descriptors: bool = True) -> Symbol\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.parser`/SymbolParser#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.parser", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolParser", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolParser\n\n`SymbolParser` is a class that provides functionality to parse URIs into structured objects. It is based on the logic defined in [sourcegraph's scip repository](https://github.com/sourcegraph/scip/blob/ee677ba3756cdcdb55b39942b5701f0fde9d69fa/bindings/go/scip/symbol.go) and is used to parse URIs into a structured `Symbol` object. Although this implementation is not in hard sync with the Go version, it's good enough for now.\n\nThe `SymbolParser` class has methods for accepting and parsing various parts of the symbol string like identifiers, namespaces, characters, or descriptor suffixes.\n\n## Related Symbols\n\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.parser.parse_symbol`\n- `automata.core.symbol.graph.SymbolGraph`\n- `automata.core.symbol.symbol_types.SymbolDescriptor`\n- `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n- `automata.core.context.py_context.retriever.PyContextRetriever`\n\n## Example\n\nThe following example demonstrates how to use the `parse_symbol` function to create a `Symbol` object from a symbol URI string.\n\n```python\nfrom automata.core.symbol.parser import parse_symbol\n\nsymbol_class = parse_symbol(\n    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n)\n\nsymbol_method = parse_symbol(\n    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n)\n```\n\n## Limitations\n\nOne of the limitations of the current implementation is that it's not in hard sync with the Go version of the `SymbolParser`, which means that it may not be able to parse all the symbols that the Go version can.\n\n## Follow-up Questions:\n\n- Are there any plans to update this implementation to be in sync with the Go version?\n- What changes or improvements can be made to this implementation to better handle parsing limitations?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 198}, false, {"py/b64": "AAAAoAHjfr8AAAAg5lyhPwAAAOAz3ZM/AAAAQBIPir8AAABgkzCavwAAAKBOd5o/AAAAgJmDl78AAADgyBSYPwAAAKCdTmY/AAAAgIGipL8AAABgcoiUPwAAAOCnbHK/AAAAYIc6kL8AAABABhmAPwAAAOBPzoO/AAAAIJX9lr8AAAAgUhFUvwAAAKAfXI2/AAAAQP1cTj8AAACA/HCXPwAAAIBZxos/AAAAAKUDfr8AAACAOqaUvwAAAECbUJS/AAAA4KRIjL8AAACAASidPwAAAIB/Gna/AAAAYBOrob8AAADAyQBPvwAAAIBpwVG/AAAAQLW5lT8AAAAAXWClvwAAAOArApi/AAAAIBJUaL8AAABAIgqAvwAAAAArFnE/AAAAIElKkT8AAABArPKSvwAAAEAIrH8/AAAAIK9meD8AAAAAwfR9PwAAACCqr4K/AAAAgIGilL8AAAAgzoaPvwAAAMAXMYI/AAAAIGbimT8AAACgIoBTvwAAAEAIrJ+/AAAAwNwqfL8AAABgskWAPwAAAOAn8po/AAAAgDwuQz8AAABAVtySvwAAAMB2DpW/AAAAIJq0bL8AAADg4PWKPwAAAIAG1KE/AAAAoL72ez8AAACgphWJvwAAAIA2loe/AAAA4GL4oD8AAADgfumQvwAAAEBSzGW/AAAAQJtQhL8AAABACKx/PwAAAKC1L4m/AAAAQJ3Ykr8AAADAY+SXPwAAACDXQqG/AAAA4ApaUj8AAABghzqgPwAAAOA8pKY/AAAAwOqdgz8AAAAgHLdyPwAAACAlfqU/AAAAAPz6o78AAAAgPV+YvwAAAEBDspW/AAAAoEGgmr8AAACgQaB6PwAAAICQvIQ/AAAAwFmBbb8AAABAMIiIvwAAAGBHfaQ/AAAAAMgogb8AAACgn9aUvwAAAEAP4IK/AAAAYO1Wlz8AAABAIIKBvwAAAKAigGO/AAAAYHtPpz8AAABgWB+TPwAAAOBf1Io/AAAA4Kdskr8AAAAAxQSbPwAAAGBoJVq/AAAAwGibjb8AAACAmwumPwAAACDCkIU/AAAAgK41k78AAABgXC+QvwAAAEAq8Hw/AAAAgOOunr8AAABgK4xEvwAAACAtWZG/AAAAoIf1kb8AAAAgEMyJvwAAAICqJZa/AAAA4MwklT8AAAAA4pFyPwAAAKBHOJa/AAAA4AMmnz8AAADgp2ySvwAAACDc+Ta/AAAAgO79nz8AAACASCR9PwAAAODGjKk/AAAAQNDJP78AAABg6UZKvwAAAOCwM6W/AAAAQP1cjj8AAACA9tibPwAAAICDKpM/AAAAIIw2ZD8AAAAAgSyhPwAAACCt3nm/AAAAwPgbfL8AAAAAOjCRvwAAAKDHvY6/AAAA4Dyklr8AAABg7951PwAAAGAW2li/AAAAgPhgmj8AAABga0mQPwAAAADuh2w/AAAAoJYPkj8AAAAge5SlvwAAAABKNng/AAAAYKMrcL8AAADAzqyDvwAAAOADJn8/AAAAAMN8fD8AAACgu8eUvwAAAKD5/JE/AAAAADP8nb8AAABg8WZ0vwAAAAAGaY8/AAAAIB4/gT8AAAAARX+CPwAAAKC1L5m/AAAAAAM6aD8AAABgskWQvwAAAKCH9YE/AAAAoJ/WdD8AAADgRWuJvwAAAABD94M/AAAAAHCKcr8AAAAgxqCCvwAAAECIJoc/AAAAQB1eaz8AAABAp0Z+vwAAAGDMrjE/AAAAYG9kTj8AAABAPHOhvwAAAOCyu2O/AAAAwFJCmT8AAABgkahrPwAAAGCQAYO/AAAAIC1Zob8AAADAWYFtPwAAAIANEzY/AAAAIJw8az8AAAAA03dSvwAAAIDzqUS/AAAAADJVlb8AAADgX9SaPwAAAABP7Z0/AAAAINjpab8AAADg8PCgvwAAAGB5x3i/AAAAgDqmlD8AAACAlMyhvwAAAECB56I/AAAAAMBNdT8AAACACQOJvwAAAKAd1J6/AAAAoBXugT8AAABASGmLPwAAAIBXPo0/AAAA4DPdcz8AAAAAHaOJPwAAAOAFro0/AAAAwL+Sk78AAADgsDN1PwAAAEDKa+G/AAAA4Bv8gL8AAADAULp6vwAAAAC3hqK/AAAAoJYPgj8AAABgBTh6vwAAAGC02J+/AAAAgDwukz8AAADgDOKAvwAAAICNmI4/AAAAgARMk78AAAAAkTI4PwAAAMBQuno/AAAAoNUwlj8AAABgkAGTvwAAAICbC4a/AAAAwNXrdz8AAAAApuSTvwAAACDmXIE/AAAAgJf7iD8AAAAgkEaBvwAAAIDq4pE/AAAAIJN1eL8AAABgLRSTvwAAAABD93O/AAAAAI+qiT8AAADAp7FwPwAAAEBewo+/AAAAYPINnT8AAABgWB+TPwAAAOCiwJ2/AAAAQGLSLD8AAADgDYmJPwAAAODDXZK/AAAAgMiepD8AAABgeCBQPwAAAOCRHo+/AAAAYGQVjT8AAAAAOjAxPwAAAEDrE6c/AAAA4Eyqnb8AAACgUZugvwAAAEDwyow/AAAAINdCcT8AAABAyxKaPwAAAICWVIA/AAAAAKRclT8AAAAAuQ6BPwAAAKCweFO/AAAAgJmDl78AAADg1P9wPwAAAGDRZXc/AAAAwPNkpj8AAADAoH2dPwAAAKDfk7A/AAAAoLB4kz8AAADgp2yiPwAAAKAHe6q/AAAAQCCCob8AAADgy0OPvwAAAGAfoYu/AAAAwBWpgz8AAACgg+WEvwAAAGDFem6/AAAAwDTJmj8AAAAAeVGlPwAAAABuAoS/AAAAoFzqUT8AAABgaCWKvwAAACCoJ5S/AAAAQMM3jj8AAABgN4KePwAAAAClA46/AAAAIP2hjL8AAAAAYhdrvwAAAID1MaM/AAAAIKafpT8AAABA5wMqPwAAAMBcpZM/AAAAwBzolz8AAACAPdWLPwAAAAAadEI/AAAAAHISob8AAACgWwmcvwAAAABUmaI/AAAAAOnQlr8AAABgE6uhvwAAAKCH9VE/AAAAYKZahz8AAACg2uebvwAAAIDnvlu/AAAAIDIQhz8AAADAmT6JvwAAAEC6cJu/AAAAwBcxgr8AAACAdbdLPwAAAOCuq6a/AAAAQF0bdz8AAABgAgmTvwAAAAArFoG/AAAAoOkBjD8AAAAgxBikvwAAAMAGj+M+AAAAoB3Ujj8AAADgy0OfPwAAAMAGj5M/AAAAQOsTl78AAACA6uKBvwAAACBtIY4/AAAAwGVslr8AAACgIoCDPwAAAOCDoJa/AAAAoLxujb8AAABA/+R8PwAAACDtm3W/AAAA4PjWnb8AAADAIPikPwAAAKBuM4k/AAAAADcMmz8AAADgbGacvwAAAGB3P5q/AAAAYLmEdD8AAADgM92TvwAAACAMvIy/AAAAIJX9Rj8AAACAkkSDPwAAACBtIY4/AAAAoFjalL8AAACAT1iQPwAAACAknY+/AAAAQFRUlD8AAACgGqV3vwAAACA0mJU/AAAAwOgVhb8AAABAunCbPwAAAOAz3ZM/AAAAQFhkoT8AAACAgaKEvwAAAEAnwWU/AAAAIAmNdb8AAABAlBGQvwAAAIBXPl0/AAAAgAuLdz8AAADAVMqXvwAAAOBYlZa/AAAAoAA8lr8AAACAO019vwAAAGDCS4e/AAAAwGC1gL8AAABAWGRhPwAAAKChXqO/AAAAYAIJkz8AAADgf5BpvwAAAOCUQqU/AAAAQOTUor8AAACAVbaevwAAAEAwiEi/AAAAwGyrar8AAADgLYpmPwAAAAArFnG/AAAAwP3HcD8AAADAMZqTPwAAAOAKWqK/AAAAYAU4ir8AAAAgV8iZvwAAAODuaIK/AAAAgOOujr8AAABgCu+fPwAAAGDKJoO/AAAAgLC9ob8AAADAvQqFvwAAAAAWZIU/AAAAIB4/cb8AAABA4kyEPwAAAKDpAYw/AAAAgBBCbT8AAAAAtf6jvwAAAAAadJI/AAAAYAU4ij8AAABATRWQvwAAAMClKYK/AAAAQKAHir8AAADADc6HvwAAACDc+Za/AAAAQNZhmz8AAAAgU7icPwAAAIApBJY/AAAAgEgkjT8AAACgK0eWPwAAACAMvHw/AAAAIH7DjL8AAAAAzd+WPwAAAADN35a/AAAAQKAHmj8AAABAymtxvwAAAGDxZpQ/AAAAgFD/mL8AAAAglf12vwAAAAA3DIu/AAAAAH4Iiz8AAAAgJJ2fPwAAAGBvZH4/AAAAYBOrUb8AAAAgkEahvwAAACBsenU/AAAAoN+TUD8AAADgw11iPwAAAGD++JW/AAAAoB3Ujr8AAABgzjaQPwAAACCJEp4/AAAAoEMoaT8AAACgLnZtPwAAAGAa6oU/AAAAILHuhj8AAADAoRlVPwAAAODnNI8/AAAAQLMxhz8AAACgFpWKPwAAAOADJn+/AAAAwGojjL8AAADA6BVVPwAAACAyEJc/AAAAAHVBiD8AAACgsHiTvwAAAECnRp4/AAAAwMkAf78AAACAuiuNPwAAACD2Ypi/AAAA4KwjqL8AAAAAGnSSPwAAAABdYIU/AAAAADP8fb8AAACA8SF2PwAAAACdHZE/AAAAQM2amD8AAACAZzmTPwAAAED+PZS/AAAAgA+bpD8AAAAgKK2MvwAAAMAShY2/AAAAoEMoWb8AAADA6BVVvwAAAGCKaYe/AAAAYGHmlT8AAADgsDOlvwAAAID1MZM/AAAAAJhxbD8AAABAZ36hvwAAACACToG/AAAAQOsTl78AAAAAKY6SvwAAAGBTc06/AAAAIPZiiD8AAABgqmqUPwAAAMD4G3w/AAAAoLSIkD8AAACgQaCaPwAAAECwAqA/AAAAoEMoaT8AAACgogWcPwAAAKBtjHC/AAAAgAbUoT8AAACAMd9xPwAAAOCfkZY/AAAAoObSlD8AAADAquCHvwAAAGAdGZ2/AAAA4HL+l78AAADgBa59vwAAAECB54K/AAAAAH4Im78AAABA5NSivwAAAIA/XWo/AAAAIDiooj8AAAAgbSF+vwAAAGDmF3O/AAAAAEP3oz8AAADgWTyPPwAAACBxMXu/AAAAoPn8ob8AAAAgLVmRvwAAAADikXI/AAAAoG2MoD8AAADgpEh8vwAAAMB0hpa/AAAA4HB2ib8AAACAMd9xPwAAAGByiFS/AAAA4CCzhj8AAACA9TGTvwAAAEDgxJU/AAAAwHiWk78AAADA2fuUPwAAAOB62ZO/AAAAIMdHez8AAABAIIKhPwAAACALFZS/AAAAIIkSjr8AAACAjZiuPwAAAOAM4pC/AAAAIMagkj8AAACgq8xevwAAAMAHNpw/AAAAACy9qT8AAACgQyh5PwAAACB7lJW/AAAAYKmJbr8AAADgdS2PvwAAAAANnaK/AAAAYOYXM78AAADgPiyFPwAAAOAPEYi/AAAAIB4/gT8AAAAAOZSJPwAAAKATZoO/AAAA4LdyiT8AAADA+z9CvwAAAKBPE6I/AAAAYHtPpz8AAABg6854vwAAAMDuraC/AAAAACcGdL8AAAAApuSTPwAAAOBrv5M/AAAAYFNzjj8AAABg6idQPwAAAGB4IGA/AAAAYKTSeD8AAADgT86DPwAAAGDCS4e/AAAAoCm/p78AAAAAM/yNPwAAAGD3uYG/AAAAwBm5cD8AAACgh/WRPwAAAOAiO4W/AAAAoIPlhL8AAAAAGnRyPwAAAGD++JU/AAAAgPhgar8AAAAAQ/djPwAAAKC1L4k/AAAAYOvOeL8AAAAA4pGSPwAAAGCQAYO/AAAAoI/bnr8AAABAiCaHPwAAAICj5nE/AAAAAMN8jL8AAAAg8lKLPwAAAIBB5Zg/AAAA4JEejz8AAABAFJeovwAAAMBeLZK/AAAAgFKHh78AAADAeh6CPwAAAAAWZJU/AAAAICFuqL8AAABA5NSCPwAAAABgj6w/AAAA4P5ueT8AAAAg3yhuPwAAAKD17HS/AAAAYOonoD8AAABgdz9aPwAAAGAO/3w/AAAAQKnOTL8AAAAA/ylrvwAAAKAB446/AAAAAIEsob8AAAAgq1ZrvwAAAAAsvZk/AAAAoPn8cT8AAABANT9+vwAAAKAyhoq/AAAAwNwqjL8AAADglspDvwAAAGAwQ5o/AAAAgBd2cD8AAACgE2aTPwAAAAAz/H2/AAAAwDphdr8AAAAg8auivwAAACAaL4S/AAAAYDeCfr8AAABgtNhfPwAAAEBnfoG/AAAAQBIPij8AAADgdS2PvwAAAAAPJTG/AAAAQK56gb8AAACgrVSdvwAAAEA1P44/AAAA4HUtnz8AAACgUZuQvwAAAIBueHc/AAAAgCNsir8AAACAIsURvwAAAGB4IJC/AAAAIMAIhz8AAAAg10KRvwAAAEDwyly/AAAAwMkAjz8AAADAi8CQvwAAACCAS6u/AAAAYL47ir8AAABg+UGQvwAAAKDfk2A/AAAAYG9kjj8AAACAv9ehPwAAAACgTJg/AAAAYNV1lL8AAACAqiWGPwAAAACblZI/AAAAgOxqoD8AAACAwV+QvwAAAODmjYa/AAAAoEGgej8AAABAi1WePwAAAICqJZY/AAAAwL0KhT8AAABgXC9APwAAACAorYy/AAAAoEc4lj8AAACgWNqUvwAAACDXQqG/AAAA4FodRb8AAAAASK6JPwAAAGAJSHe/AAAAoLUvmT8AAADAi8CAPwAAAEB/X4S/AAAAoE53ij8AAADgYviQPwAAAIDCBnk/AAAAgD9dir8AAADgmtpwPwAAAAAadIK/AAAAAAGyib8AAADANlGZvwAAAOB62ZM/AAAAIJ7EiT8AAABAsAKwvwAAAGAO/4y/AAAAQGX2gr8AAABAhp6YPwAAAID/n44/AAAAYJABUz8AAABgK4yUPwAAAMA/GGy/AAAAIMdHiz8AAACA3VCQvwAAAECB55K/AAAAwAJ/hr8AAACAJ3xnPwAAAEBDsmU/AAAAIOp3j78AAABgAgmTPwAAACDCkJU/AAAAALN2lb8AAACA3vcYPwAAAGA9Gpq/AAAAYMcCfT8AAACgzvFxvwAAAODDXVI/AAAAwFylg78AAADgvrFtPwAAAOBAtKO/AAAA4BTInb8AAADAHnBWvwAAACCcPJs/AAAAgJJEcz8AAAAgaGqIPwAAAIBB5Vg/AAAAgO79jz8AAACAYymWPwAAAGAYYme/AAAAINW6cj8AAACgD1aWvwAAAIC/12E/AAAAwEl7lj8AAAAA+nKFPwAAACBlO4E/AAAAIBovlD8AAABAG9Z8vwAAAADgCYS/AAAAIFx/nz8AAABAsamIvwAAAGAjsWg/AAAAYKGjkb8AAAAAFmSFvwAAAKCP256/AAAA4IxneT8AAAAgdFWRvwAAAADrWJU/AAAAwPNkpr8AAABgSQWjvwAAAAA+S5+/AAAAoF2Rmj8AAABAXsIPPwAAAGBvZI4/AAAAgCd8Z78AAADA0rywvwAAAECLVY6/AAAAQBSXmD8AAADgbu6KPwAAAOA6HAi/AAAA4KwjqL8AAACAtXSHvwAAAMCXtoo/AAAAALBSj78AAABAG9aMPwAAACCcPJs/AAAAYIAGnT8AAACgJpCAPwAAAGAm4J8/AAAAAAZpj78AAABgU3OePwAAAAAuRWi/AAAAAJuVgj8AAADgd7WdvwAAACAJjYU/AAAAYBrqZb8AAADAi8CQPwAAAEByzaI/AAAAQDU/jj8AAACAgaKEPwAAAECLVY4/AAAAgGnBgT8AAABAK9GSPwAAAGAEkTE/AAAAIAmNpT8AAAAAhuOGvwAAAEBDsmW/AAAAAFSZor8AAADAAn+WvwAAAGCXQIe/AAAAgAkDmb8AAAAA6dCGvwAAACCJEm6/AAAAIEx5aL8AAACApW5gvwAAAODTY6m/AAAA4CZLcj8AAACAlXOKPwAAAGA+tqE/AAAAYK8haj8AAACgu8eUPwAAAIDsaqA/AAAAAJRhb78AAABgQD6QvwAAAMBsq3q/AAAAADDNhj8AAADAXKWDvwAAAEDsuo8/AAAAYOvOmD8AAABgNFNXPwAAAOA+LGU/AAAAYCbgb78AAAAgkEaRvwAAAOAkw6O/AAAAYOlGqr8AAABASvFJPwAAAKAB444/AAAAADcMqz8AAABAwzeOvwAAAGDJiou/AAAAoMB+mr8AAADAHOinPwAAAACdHWE/AAAAQA/ggj8AAACgL1eDvwAAACAct5K/AAAAwAJ/hr8AAABgNFOXPwAAACD7GW6/AAAAQJtQpD8AAABgvZRRvwAAAABIrok/AAAAwAaPcz8AAADgIjuVvwAAAKDHvY4/AAAAIOp3T78AAACAiOGoPwAAAKArRya/AAAAwDZReb8AAADABAeFPwAAAOC0Q5I/AAAAYOvOmD8AAADAbKt6PwAAAADUHnu/AAAAIC1Zgb8AAABAK9GiPwAAAOAUyJ2/AAAAIILTmb8AAAAgy1c4vwAAAICDKmO/AAAAAAwBi78AAABAJ8GFvwAAAOA37aC/AAAAgBLKi78AAACgjjSGvwAAAMA/GIw/AAAAIMAIpz8AAACg5EqGvwAAAABkn3m/AAAAwCc3eb8AAABAhBZ6PwAAACCMNnS/AAAA4LRDkr8AAADAaJt9vwAAAMDBGqI/AAAAwGyrqr8AAACAFFKqvwAAAAA6MIG/AAAAgBd2gL8AAAAAGZOcPwAAAMBNi4M/AAAAYKjipb8AAACASCR9PwAAAGDFeq4/AAAAoKFeY78AAABAi1WOPwAAAKAAPFa/AAAAAFSZoj8AAACgbYygvwAAAEDPIoe/AAAA4Ns+hb8AAADABAelvwAAAAAfK5g/AAAAIDIQZ78AAABA7Lp/vwAAAIAQQm2/AAAAYBCHe78AAACAWcaLPwAAACDtm5U/AAAAgGc5Uz8AAADg9y91PwAAAGBMNJo/AAAAINW6Yj8AAABgFTOAvwAAAADIKGE/AAAAoCaQkD8AAACA465OPwAAAGC5hIQ/AAAAoIl9gL8AAADANaqAvwAAACDvI5Q/AAAAgHW3iz8AAADA7CWSvwAAAODLQ18/AAAAwPNkpr8AAACAVbaOvwAAAABzuXm/AAAAQF7Cn78AAADABo+TvwAAAOB+6XA/AAAAoANrjb8AAADgcv53PwAAAIBo4Is/AAAAYKpqhL8AAADASwOFPwAAACCXhVW/AAAAgMSONz8AAADgdS2PvwAAAMA/GJw/AAAAwJL/lD8AAABgrZl7vwAAACDjOJu/AAAAAOtYlb8AAAAgspV/PwAAAMANzpe/AAAAYOvOeL8AAAAg3oGFvwAAAED6LYc/AAAAACy9Wb8AAABAiCanvwAAAIBVtp6/AAAAYNV1lL8AAABA1NmcvwAAAIBPWIA/AAAAoIysZz8AAABARuGMPwAAAID/n44/AAAAwLbLoD8AAADAGmBZPwAAAGB5x5g/AAAAYMV6nr8AAAAAWVCYPwAAAKCJfZC/AAAAQMjjkj8AAADg+bejPwAAAAD6cpU/AAAAQJakfz8AAABgzK5hvwAAAKCFbZO/AAAAgGc5k78AAABAgeeSPwAAAGDRZYc/AAAA4Fk8Pz8AAABgXdaoPwAAAKAB456/AAAAwB5wlr8AAADAtsuQvwAAAGCY528/AAAAgCkEhr8AAACA75lnvwAAAABFf4K/AAAAgE3Qkb8AAACg/CuJvwAAAECkF4e/AAAAIGU7gb8AAAAApuSTvwAAAEBXg5s/AAAAwIYUfD8AAAAgf6RSvwAAACAAxoI/AAAAAJuVgj8AAACAwV+QvwAAAKDHvY6/AAAAwOgVlb8AAADgw12iPwAAAAD/KYu/AAAA4Iewc78AAACAMd+hPwAAACC4LZs/AAAAwFf5Xj8AAADAXi2ivwAAAGB4IHA/AAAAYDRTd78AAACAcadePwAAAMBeLUI/AAAA4AzikL8AAACgnU6WPwAAAECEFnq/AAAAILKVnz8AAADgBkqFvwAAAEDePGc/AAAAwNn7lL8AAABAW5OYvwAAAED1dqG/AAAAwBKFjT8AAACA4geGvwAAAMDESYm/AAAAIFCJZb8AAAAAIlp/vwAAACAtWWG/AAAAQCfBhb8AAABgqYl+vwAAAGCc93y/AAAAIDIQZ78AAACgyuGUPwAAAAANnaK/AAAAgL/Xcb8AAADg9y+VvwAAAICUzHG/AAAAYMcCjT8AAACgFA2cvwAAACBfo4W/AAAAICV+xT8AAABgyYp7PwAAAGDFep4/AAAAoIicmj8AAABAvoBovwAAAMCLwIA/AAAAYOFrfj8AAABgWqeBvwAAAAA6MJG/AAAAQGw1d78AAADA/cdwPwAAAECd2GI/AAAA4OtEfL8AAAAA50hoPwAAAOARmXY/AAAAoLIAgj8AAACgh/WRvwAAAECKrqW/AAAA4AzioL8AAACgbYyAvwAAACACTnG/AAAAQOy6j78AAACgD1aWvwAAAKBaYpO/AAAAAPAPiz8AAABg4WuOvwAAAGAVM5C/AAAA4AZKdT8AAADA+z+iPwAAAADkGaE/AAAAgMYWlr8AAADAkHdGvwAAAOD+bnk/AAAAYOFrbj8AAAAgxBiUPwAAAMDZ+4S/AAAAoLSIcD8AAABAOGOEPwAAAGDE04W/AAAAgL1Pkz8AAABgtNiPvwAAAMBLA5W/AAAAoFpik78AAABg+UGQvwAAAABmJ4g/AAAA4CsCaL8AAACAScCEvwAAAGCyRVC/AAAAwNqibT8AAAAggEurPwAAAOCp9KC/AAAAQJtQlD8AAAAgdFWhPwAAAGCKafe+AAAAYHc/aj8AAADAMyKSvwAAAKBA+YE/AAAAYDuSez8AAADgsruTPwAAAOCiwG0/AAAA4BTInb8AAADgteqaPwAAACB9HIQ/AAAAwG/PoD8AAAAgzoZfPwAAACCexJk/AAAAYLsMc78AAACAoMJ7PwAAAGB2mJE/AAAAYNV15D4AAAAAHyuIvwAAAKCdToa/AAAAQJ3Ykr8AAACg64mKvwAAAMBExJC/AAAAoFZShr8AAADgJkuSPwAAAEB3hIg/AAAA4IbPjT8AAABASvGJPwAAAOAI0nO/AAAAgCRNoD8AAABAke2JvwAAAGDYpIs/AAAA4Dykdj8AAACAhNGbvwAAAABb2KY/AAAAQDhjVD8AAAAgbHp1PwAAAMA1qnA/AAAAoC3PZL8AAABgTryIvwAAAIDxIVY/AAAA4F1MjD8AAABAsAJQPwAAAACTulY/AAAA4Oc0fz8AAAAgAMZyPwAAAAB5UZW/AAAAIOGwfL8AAADAFamTvwAAAKAtz7Q/AAAA4DC5nT8AAACAbPCoPwAAAICDKpO/AAAAIJX9Zr8AAADgnQlIvwAAAEDbDZC/AAAAIPsZjr8AAAAgqCeUvwAAAGDMrpE/AAAAQMprob8AAADgAyaPPwAAAOCYUpI/AAAAoL72iz8AAAAAT+19PwAAAIAcLVY/AAAAgNlAY78AAADgU95wPwAAAAAadJI/AAAAgLorjb8AAACgXZGaPwAAAMAvEoW/AAAAIBovlD8AAABAerOfvwAAAMB4lpO/AAAAwMEaor8AAAAgUhGUvwAAAOCkSHy/AAAAoKvMfr8AAACA4geGPwAAAIAcLaa/AAAAYLf8lT8AAABALHiLvwAAAAC1/nM/AAAA4CsCqL8AAADg6byNvwAAAMDbg5O/AAAAIPGrgr8AAADgLYqGvwAAAEAWH4c/AAAAYPe5oT8AAACA28hxPwAAAMDOrIM/AAAAAMN8fD8AAABAFJdYPwAAACDXQlG/AAAAgL1Pkz8AAADgWh1lvwAAAKA5xX6/AAAAAHCKkj8AAABgnxtzvwAAAGCo4nW/AAAAoHJDlr8AAABgnxuTvwAAAOB+6bC/AAAAYGglmr8AAABANT+evwAAAMDgOgk/AAAAYO1WZ78AAABAmcilvwAAAKAd1I4/AAAAQNDJjz8AAACgB3uKPwAAAGAEkaG/AAAAQAP1mb8AAAAAotTGvwAAAEDLEno/AAAAABsbmz8AAADg/OaqvwAAAAABspk/AAAA4JbKQ78AAAAA4pGSPwAAAGBcL6C/AAAAwJk+ab8AAAAgqCeUvwAAAGAm4J8/AAAAICP2hj8AAACgRziWvwAAAGBLjaG/AAAAwAJ/hj8AAACgCp+QvwAAAIABKH2/AAAAII6+cr8AAACA75mnPwAAAEBBKnc/AAAAAIx7oj8AAAAAgSyhvwAAAKB0y4Q/AAAAYOvOmD8AAADgfulQPwAAAIBZxku/AAAAwK0Pn78AAAAgfsOMvwAAAOAWUJy/AAAA4DociL8AAABgqYluPwAAAICgwls/AAAAwPHcl78AAACg0SCJvwAAAIALi2e/AAAAoFZSdj8AAAAAFmSFvwAAAEBW3KK/AAAAIA5Em78AAAAAz2eVPwAAAOANiYk/AAAAQINvYT8AAACgUZuQvwAAAMAaYJm/AAAAALX+Qz8AAAAAtf5zPwAAAAClA44/AAAAwPs/or8AAACAW056PwAAAGA+tnE/AAAAAOAJVD8AAADgkR5vPwAAAEARaFE/AAAAwMEacj8AAAAAQW+lPwAAAOAY2Hq/AAAAwL+Skz8AAAAAd8mWPwAAAIAETIM/AAAA4Cl6mT8AAAAAs3aFvwAAAMDesoq/AAAAAAZpfz8AAAAgVUBbPwAAAMCUh5M/AAAAYKpqdD8AAADgJMOTvwAAAEBpBpA/AAAAoBaVmr8AAABghbKBvwAAAICBooS/AAAAAP6Coj8AAACgMP6LPwAAAIAsM42/AAAAgCwznT8AAAAglf2GPwAAAICWVJC/AAAAQFbcoj8AAAAAjHtivwAAAKDm0pS/AAAAIOM4Sz8AAAAg4bCcPwAAAGAyy3i/AAAAQNmFgb8AAAAg4zibPwAAAIBlsXS/AAAAQBIPar8AAABgvZShvwAAAICuNZM/AAAAIHkMl78AAAAgbHplvwAAAMDvVIm/AAAAoCtHlr8AAAAgH+ZZPwAAAIDu/W8/AAAAYEuNYT8AAAAAzd92vwAAAMBLA1U/AAAAgPhgSj8AAABAlBGgvwAAAGAa6oU/AAAA4Kn0YL8AAADgT86jvwAAACAHBVc/AAAAQNsNkD8AAABgdpihPwAAAIAQQp2/AAAAYBOrgT8AAADAMyKCvwAAACDLV3g/AAAAAEiumb8AAACgIeR7vwAAAGB7T5c/AAAAYEkFoz8AAADg7miivwAAAGAK758/AAAAwNn7lD8AAACgA2udvwAAAEBl9oK/AAAAAAwBi78AAACgCp+wPwAAAODuaJI/AAAAwDjZJz8AAACA2UCDvwAAAIBzL30/AAAA4Hxhkr8AAABAyOOyvwAAAKCT63u/AAAA4JRCZT8AAACAgaKUPwAAACAhbqi/AAAAIIkSnr8AAACAwV+AvwAAAKDfk1C/AAAAoP6zh78AAACATdBBPwAAAEAIrG+/AAAAoFzqkb8AAACAbPB4vwAAAOCiwJ2/AAAAQHX8ib8AAACAPC6DPwAAAKB8pmC/AAAAINW6kr8AAACgMP5rvwAAAODmjZY/AAAAQH9fVD8AAAAgjr6CPwAAAECgB0q/AAAA4He1jT8AAABAg29xPwAAAMD6o3q/AAAAoOLCl78AAAAAUXVsvwAAAECEFnq/AAAAQNsNoD8AAAAgHj9xvwAAACAknZ+/AAAAwH1NmT8AAACAmYOXvwAAAMB0hpY/AAAAYKMrcL8AAADgnQl4vwAAAEDpi3g/AAAAgBuRnj8AAACgw6KAvwAAAGBTc44/AAAAgEHleD8AAABAK9GSPwAAACCrVku/AAAAYBOrob8AAABARuGMvwAAACB/pAK/AAAA4JRCpT8AAAAA1qaZPwAAAIDxIWa/AAAAwETEoL8AAABA4MSVvwAAAIDZQKO/AAAAAGIXm78AAADgEZmmPwAAAID/n26/AAAA4E/OY78AAACAPdWLPwAAAAB1QZi/AAAA4MtDX78AAADA3CqcvwAAAODuaJK/AAAAwMkAnz8AAADA7CVyvwAAAOCbgYk/AAAAoLvHlD8AAADgN+2gvwAAAKAh5Js/AAAAwNK8gD8AAACAUP94vwAAAGA225W/AAAA4B8XL78AAACAkLx0vwAAAKAudj0/AAAAgEnAlD8AAADglEKFPwAAAMDXc5Y/AAAAgBwtlj8AAABgPRpqvwAAACBlO4G/AAAAQFLMhb8AAACAhNGLvwAAAEDPIoc/AAAAgOU2nb8AAAAAViFxPwAAAOAlaow/AAAAgKVuoD8AAADAqFiJPwAAAIBN0KE/AAAAQLz4mb8AAABgyiaTPwAAACBMeZg/AAAAgIZZqj8AAACg6FqjvwAAAMAIF2K/AAAAIPsZbr8AAAAAAAtxPwAAAEAWH5c/AAAAAH4Im78AAACgHdSePwAAAIAixaG/AAAAIA5Ei78AAABgXC+wvwAAAAAfK4g/AAAAoOLClz8AAACg+fyRvwAAAICwvXG/AAAAwKB9nb8AAADgN+1QvwAAAKCT63u/AAAAoCQIEr8AAABANT9+PwAAAGAHwJi/AAAAYACBlL8AAADAwDlsvwAAAKDneX0/AAAAYKMrgL8AAADAFamTvwAAAOCp9JA/AAAAwP3HoL8AAABgWB+jPwAAAEAr0VK/AAAAQIqudb8AAAAAGOxzPwAAAKAd1I4/AAAAQM2amD8AAACA4H+nvwAAAAAnBmQ/AAAAAMgokb8AAACgQPmRPwAAAOAtima/AAAAwBWpk78AAACAF3aQPwAAAACPqmm/AAAAoIl9oL8AAACgkWOdPwAAAEDwypw/AAAAQMM3fr8AAABg6UaqPwAAAAB4cI+/AAAAwO9UmT8AAACg9FCdPwAAAOD+bnk/AAAAAJ0dkb8AAADAyQB/PwAAAIAkTYC/AAAAoAA8hr8AAABg7VZ3vwAAAOBaHZW/AAAA4O5ooj8AAACAwV+QPwAAAGDv3oU/AAAA4HL+lz8AAACAZzlzPwAAAKDHvY6/AAAAgLPsmL8AAAAAmHF8vwAAAIAx36G/AAAAoE53ij8AAABASvGZPwAAACDCkHW/AAAAQLACgL8AAABA0aqlPwAAAEDDN34/AAAAgITRmz8AAABAgedivwAAAEDiTHQ/AAAAgGpomj8AAAAgTgGnvwAAACCsN3G/AAAA4GL4kD8AAADg+l6MvwAAAOD5t6O/AAAA4Iewgz8AAABArnphPwAAAOAlapw/AAAAwPHclz8AAAAApuSjvwAAAKBDKJm/AAAAgPOpdD8AAABA6xOHvwAAAADATYU/AAAAADWEnD8AAADADc6HvwAAAIDXuIQ/AAAAYDEkgD8AAADA/cegPwAAAGBwAJa/AAAAwAgXMj8AAABAhBaavwAAACC7UZE/AAAAoF2Rej8AAABA6YuIvwAAACCLmow/AAAAgJC8lD8AAABgqYluPwAAAGDqJ4A/AAAAwCWvmr8AAAAgdFUxvwAAAOCNA5E/AAAAAIx7oj8AAACgFe6BvwAAAIAzZ4A/AAAAIILTib8AAABgcohUPwAAAAAPJZG/AAAAIJeFlb8AAADAfU1pPwAAAKDTqKe/AAAAYPe5gb8AAADgjGd5PwAAAKC8bn0/AAAAoCtHhr8AAAAgbSGOvwAAAGBC0Z+/AAAAYAfAiD8AAACAxhZ2vwAAAMDSvIC/AAAAoCQIkj8AAACgH1xtPwAAAIDCBom/AAAA4DVlkj8AAABAVtxyvwAAAABzuXk/AAAA4K6rpj8AAAAgKjVbPwAAAOBPzjO/AAAA4DoceD8AAADAzqxjPwAAAIBZxpu/AAAAwAJ/lj8AAABAszFXPwAAAEBuvYW/AAAAAOAJpL8AAADg4n2pvwAAAMDAOYy/AAAAYFqnkb8AAACA3vd4vwAAACDGoHK/AAAAIGryZj8AAABA+i13vwAAAIAnfLc/AAAAoHymoD8AAADAAn+GPwAAAMCzp4q/AAAAgKytlL8AAADAXi2iPwAAAADnSIg/AAAAIOZccb8AAACAxhZmPwAAAECxqZi/AAAAgE9YkL8AAABgHvqivwAAAEDz7oK/AAAAIFVAi78AAABA6xOHPwAAAACzdpU/AAAAIN8ojr8AAADg306iPwAAAEA662K/AAAA4DC5fb8AAACAxhamPwAAAKA5xY4/AAAAoJYPYj8AAAAAT+19PwAAAKDdC6K/AAAAIPGrUr8AAAAA/ymbPwAAAMDQNJK/AAAAgKPmgT8AAAAAViGhvwAAAGCKaYc/AAAAAN3ljT8AAAAAuQ6hvwAAAADPZ5W/AAAAAA2dkr8AAAAgucmCPwAAACCMNpQ/AAAAYIpph78AAADgEyGlPwAAAGBV+5w/AAAAANN3gr8AAAAgIW5oPwAAAEAGGXA/AAAAADowob8AAABAWGQBPwAAAADFBIs/AAAAAPKXib8AAAAgiRKOvwAAAEBIaZu/"}]}]}, "source_code": "class SymbolParser:\n    \"\"\"\n    Translation of the logic defined in\n    https://github.com/sourcegraph/scip/blob/ee677ba3756cdcdb55b39942b5701f0fde9d69fa/bindings/go/scip/symbol.go\n    to parse URIs into structured objects.\n    It's not great that this implementation is not in hard sync with the Go one, but it's good enough for now.\n    \"\"\"\n\n    def __init__(self, symbol: str):\n        \"\"\"\n        Args:\n            symbol (str): The symbol URI to parse\n        \"\"\"\n        self.symbol = symbol\n        self.index = 0\n        self.symbol_str = symbol\n\n    def error(self, message: str) -> ValueError:\n        \"\"\"\n        Create a ValueError with the symbol and a pointer to the error location\n\n        Args:\n            message (str): The error message\n        \"\"\"\n        return ValueError(f\"{message}\\n{self.symbol_str}\\n{'_' * self.index}^\")\n\n    def current(self) -> str:\n        \"\"\"\n        Get the current character in the symbol\n\n        Returns:\n            str - The current character in the symbol\n        \"\"\"\n        return self.symbol[self.index]\n\n    def peek_next(self) -> Optional[str]:\n        \"\"\"\n        Peek at the next character in the symbol\n\n        Returns:\n            Optional[str] - The next character in the symbol,\n                or None if there is no next character\n        \"\"\"\n        if self.index + 1 < len(self.symbol):\n            return self.symbol[self.index + 1]\n        return None\n\n    def parse_descriptors(self) -> List[SymbolDescriptor]:\n        \"\"\"\n        Parse all descriptors in the symbol\n\n        Returns:\n            List[SymbolDescriptor] - The descriptors in the symbol\n        \"\"\"\n        result = []\n        while self.index < len(self.symbol):\n            descriptor = self.parse_descriptor()\n            result.append(descriptor)\n        return result\n\n    def parse_descriptor(self) -> SymbolDescriptor:\n        \"\"\"\n        Parse a single descriptor in the symbol\n\n        Returns:\n            SymbolDescriptor - The descriptor in the symbol\n        \"\"\"\n        next_char = self.current()\n        if next_char == \"(\":\n            self.index += 1\n            name = self.accept_identifier(\"parameter name\")\n            descriptor = SymbolDescriptor(name, SymbolDescriptor.ScipSuffix.Parameter)\n            self.accept_character(\")\", \"closing parameter name\")\n            return descriptor\n        elif next_char == \"[\":\n            self.index += 1\n            name = self.accept_identifier(\"type parameter name\")\n            descriptor = SymbolDescriptor(name, SymbolDescriptor.ScipSuffix.TypeParameter)\n            self.accept_character(\"]\", \"closing type parameter name\")\n            return descriptor\n        else:\n            name = self.accept_identifier(\"descriptor name\")\n            suffix = self.current()\n            self.index += 1\n            if suffix == \"(\":\n                disambiguator = \"\"\n                if self.current() != \")\":\n                    disambiguator = self.accept_identifier(\"method disambiguator\")\n                descriptor = SymbolDescriptor(\n                    name, SymbolDescriptor.ScipSuffix.Method, disambiguator\n                )\n                self.accept_character(\")\", \"closing method\")\n                self.accept_character(\".\", \"closing method\")\n                return descriptor\n            elif suffix == \"/\":\n                return SymbolDescriptor(name, SymbolDescriptor.ScipSuffix.Namespace)\n            elif suffix == \".\":\n                return SymbolDescriptor(name, SymbolDescriptor.ScipSuffix.Term)\n            elif suffix == \"#\":\n                return SymbolDescriptor(name, SymbolDescriptor.ScipSuffix.Type)\n            elif suffix == \":\":\n                return SymbolDescriptor(name, SymbolDescriptor.ScipSuffix.Meta)\n            elif suffix == \"!\":\n                return SymbolDescriptor(name, SymbolDescriptor.ScipSuffix.Macro)\n            else:\n                raise self.error(\"Expected a descriptor suffix\")\n\n    def accept_identifier(self, what: str) -> str:\n        \"\"\"\n        Accepts an identifier from the symbol\n\n        Args:\n            what (str): The name of the identifier\n\n        Returns:\n            str - The identifier\n        \"\"\"\n        if self.current() == \"`\":\n            self.index += 1\n            return self.accept_backtick_escaped_identifier(what)\n        start = self.index\n        while self.index < len(self.symbol) and self.is_identifier_character(self.current()):\n            self.index += 1\n        if start == self.index:\n            raise self.error(\"empty identifier: \" + what)\n        return self.symbol[start : self.index]\n\n    def accept_space_escaped_identifier(self, what: str) -> str:\n        \"\"\"\n        Accepts an identifier from the symbol, where the identifier is escaped by spaces\n\n        Args:\n            what (str): The name of the identifier\n\n        Returns:\n            str - The identifier\n        \"\"\"\n        return self.accept_escaped_identifier(what, \" \")\n\n    def accept_backtick_escaped_identifier(self, what: str) -> str:\n        \"\"\"\n        Accepts an identifier from the symbol,\n            where the identifier is escaped by backticks\n\n        Args:\n            what (str): The name of the identifier\n\n        Returns:\n            str - The identifier\n        \"\"\"\n        return self.accept_escaped_identifier(what, \"`\")\n\n    def accept_escaped_identifier(self, what: str, escape_character: str) -> str:\n        \"\"\"\n        Accepts an identifier from the symbol,\n            where the identifier is escaped by a given character\n\n        Args:\n            what (str): The name of the identifier\n\n        Returns:\n            str - The identifier\n        \"\"\"\n        builder = []\n        while self.index < len(self.symbol):\n            ch = self.current()\n            if ch == escape_character:\n                self.index += 1\n                if self.index >= len(self.symbol):\n                    break\n                if self.current() == escape_character:\n                    builder.append(ch)\n                else:\n                    return \"\".join(builder)\n            else:\n                builder.append(ch)\n            self.index += 1\n        raise self.error(\n            f\"reached end of symbol while parsing <{what}>, expected a '{escape_character}' character\"\n        )\n\n    def accept_character(self, r: str, what: str):\n        \"\"\"\n        Accepts a character from the symbol\n\n        Args:\n            r (str): The character to accept\n            what (str): The name of the character\n        \"\"\"\n        if self.current() == r:\n            self.index += 1\n        else:\n            raise self.error(f\"expected '{r}', obtained '{self.current()}', while parsing {what}\")\n\n    @staticmethod\n    def is_identifier_character(c: str) -> bool:\n        \"\"\"\n        Checks if a character is a valid identifier character\n\n        Args:\n            c (str): The character to check\n\n        \"\"\"\n        return c.isalpha() or c.isdigit() or c in [\"-\", \"+\", \"$\", \"_\"]\n\n\n", "summary": "SymbolParser is a class that offers functionality for parsing URIs into structured Symbol objects, using logic from the Sourcegraph's SCIP repository. The class contains methods for processing and parsing various aspects of symbol strings, such as identifiers, namespaces, characters, or descriptor suffixes. It's important to note that the current implementation is not in full sync with its Go counterpart, which may result in some parsing limitations. An example provided demonstrates how to utilize the `parse_symbol` function to create a Symbol object from a symbol URI string.", "context": "\n    Generate the documentation for SymbolParser using the context shown below -\n  Building context for primary symbol - automata.core.symbol.parser.SymbolParser -\n  \n    Import Statements:\n      import re\n      from typing import List, Optional\n      from automata.core.symbol.symbol_types import Symbol, SymbolDescriptor, SymbolPackage\n      \n      # SymbolParser\n      \n      SymbolParser is a class that provides functionality to parse URIs into structured objects. This implementation is based on the logic defined in [sourcegraph's scip repository](https://github.com/sourcegraph/scip/blob/ee677ba3756cdcdb55b39942b5701f0fde9d69fa/bindings/go/scip/symbol.go) and is used to parse URIs into a structured `Symbol` object. Although this implementation is not in hard sync with the Go version, it's good enough for now. \n      \n      The SymbolParser class has methods for accepting and parsing various parts of the symbol string like identifiers, namespaces, characters, or descriptor suffixes.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.parser.parse_symbol`\n      - `automata.core.symbol.graph.SymbolGraph`\n      - `automata.core.symbol.symbol_types.SymbolDescriptor`\n      - `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n      - `automata.core.context.py_context.retriever.PyContextRetriever`\n      \n      ## Example\n      \n      The following example demonstrates how to use the `parse_symbol` function to create a `Symbol` object from a symbol URI string.\n      \n      ```python\n      from automata.core.symbol.parser import parse_symbol\n      \n      symbol_class = parse_symbol(\n          \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n      )\n      \n      symbol_method = parse_symbol(\n          \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n      )\n      ```\n      \n      ## Limitations\n      \n      One of the limitations of the current implementation is that it's not in hard sync with the Go version of the SymbolParser, which means that it may not be able to parse all the symbols that the Go version can.\n      \n      ## Follow-up Questions:\n      \n      - Are there any plans to update this implementation to be in sync with the Go version?\n      - What changes or improvements can be made to this implementation to better handle parsing limitations?\n      \n    Class Docstring:\n      Translation of the logic defined in\n      https://github.com/sourcegraph/scip/blob/ee677ba3756cdcdb55b39942b5701f0fde9d69fa/bindings/go/scip/symbol.go\n      to parse URIs into structured objects.\n      It's not great that this implementation is not in hard sync with the Go one, but it's good enough for now.\n      \n    Methods:\n      def __init__(self, symbol: str):\n              \"\"\"\n              Args:\n                  symbol (str): The symbol URI to parse\n              \"\"\"\n              self.symbol = symbol\n              self.index = 0\n              self.symbol_str = symbol\n      \n          \n      def accept_backtick_escaped_identifier(self, what: str) -> str:\n              \"\"\"\n              Accepts an identifier from the symbol,\n                  where the identifier is escaped by backticks\n      \n              Args:\n                  what (str): The name of the identifier\n      \n              Returns:\n                  str - The identifier\n              \"\"\"\n              return self.accept_escaped_identifier(what, \"`\")\n      \n          \n      def accept_character(self, r: str, what: str):\n              \"\"\"\n              Accepts a character from the symbol\n      \n              Args:\n                  r (str): The character to accept\n                  what (str): The name of the character\n              \"\"\"\n              if self.current() == r:\n                  self.index += 1\n              else:\n                  raise self.error(f\"expected '{r}', obtained '{self.current()}', while parsing {what}\")\n      \n          \n      def accept_escaped_identifier(self, what: str, escape_character: str) -> str:\n              \"\"\"\n              Accepts an identifier from the symbol,\n                  where the identifier is escaped by a given character\n      \n              Args:\n                  what (str): The name of the identifier\n      \n              Returns:\n                  str - The identifier\n              \"\"\"\n              builder = []\n              while self.index < len(self.symbol):\n                  ch = self.current()\n                  if ch == escape_character:\n                      self.index += 1\n                      if self.index >= len(self.symbol):\n                          break\n                      if self.current() == escape_character:\n                          builder.append(ch)\n                      else:\n                          return \"\".join(builder)\n                  else:\n                      builder.append(ch)\n                  self.index += 1\n              raise self.error(\n                  f\"reached end of symbol while parsing <{what}>, expected a '{escape_character}' character\"\n              )\n      \n          \n      def accept_identifier(self, what: str) -> str:\n              \"\"\"\n              Accepts an identifier from the symbol\n      \n              Args:\n                  what (str): The name of the identifier\n      \n              Returns:\n                  str - The identifier\n              \"\"\"\n              if self.current() == \"`\":\n                  self.index += 1\n                  return self.accept_backtick_escaped_identifier(what)\n              start = self.index\n              while self.index < len(self.symbol) and self.is_identifier_character(self.current()):\n                  self.index += 1\n              if start == self.index:\n                  raise self.error(\"empty identifier: \" + what)\n              return self.symbol[start : self.index]\n      \n          \n      def accept_space_escaped_identifier(self, what: str) -> str:\n              \"\"\"\n              Accepts an identifier from the symbol, where the identifier is escaped by spaces\n      \n              Args:\n                  what (str): The name of the identifier\n      \n              Returns:\n                  str - The identifier\n              \"\"\"\n              return self.accept_escaped_identifier(what, \" \")\n      \n          \n      def current(self) -> str:\n              \"\"\"\n              Get the current character in the symbol\n      \n              Returns:\n                  str - The current character in the symbol\n              \"\"\"\n              return self.symbol[self.index]\n      \n          \n      def error(self, message: str) -> ValueError:\n              \"\"\"\n              Create a ValueError with the symbol and a pointer to the error location\n      \n              Args:\n                  message (str): The error message\n              \"\"\"\n              return ValueError(f\"{message}\\n{self.symbol_str}\\n{'_' * self.index}^\")\n      \n          \n      @staticmethod\n          def is_identifier_character(c: str) -> bool:\n              \"\"\"\n              Checks if a character is a valid identifier character\n      \n              Args:\n                  c (str): The character to check\n      \n              \"\"\"\n              return c.isalpha() or c.isdigit() or c in [\"-\", \"+\", \"$\", \"_\"]\n      \n      \n      \n      def parse_descriptor(self) -> SymbolDescriptor:\n              \"\"\"\n              Parse a single descriptor in the symbol\n      \n              Returns:\n                  SymbolDescriptor - The descriptor in the symbol\n              \"\"\"\n              next_char = self.current()\n              if next_char == \"(\":\n                  self.index += 1\n                  name = self.accept_identifier(\"parameter name\")\n                  descriptor = SymbolDescriptor(name, SymbolDescriptor.ScipSuffix.Parameter)\n                  self.accept_character(\")\", \"closing parameter name\")\n                  return descriptor\n              elif next_char == \"[\":\n                  self.index += 1\n                  name = self.accept_identifier(\"type parameter name\")\n                  descriptor = SymbolDescriptor(name, SymbolDescriptor.ScipSuffix.TypeParameter)\n                  self.accept_character(\"]\", \"closing type parameter name\")\n                  return descriptor\n              else:\n                  name = self.accept_identifier(\"descriptor name\")\n                  suffix = self.current()\n                  self.index += 1\n                  if suffix == \"(\":\n                      disambiguator = \"\"\n                      if self.current() != \")\":\n                          disambiguator = self.accept_identifier(\"method disambiguator\")\n                      descriptor = SymbolDescriptor(\n                          name, SymbolDescriptor.ScipSuffix.Method, disambiguator\n                      )\n                      self.accept_character(\")\", \"closing method\")\n                      self.accept_character(\".\", \"closing method\")\n                      return descriptor\n                  elif suffix == \"/\":\n                      return SymbolDescriptor(name, SymbolDescriptor.ScipSuffix.Namespace)\n                  elif suffix == \".\":\n                      return SymbolDescriptor(name, SymbolDescriptor.ScipSuffix.Term)\n                  elif suffix == \"#\":\n                      return SymbolDescriptor(name, SymbolDescriptor.ScipSuffix.Type)\n                  elif suffix == \":\":\n                      return SymbolDescriptor(name, SymbolDescriptor.ScipSuffix.Meta)\n                  elif suffix == \"!\":\n                      return SymbolDescriptor(name, SymbolDescriptor.ScipSuffix.Macro)\n                  else:\n                      raise self.error(\"Expected a descriptor suffix\")\n      \n          \n      def parse_descriptors(self) -> List[SymbolDescriptor]:\n              \"\"\"\n              Parse all descriptors in the symbol\n      \n              Returns:\n                  List[SymbolDescriptor] - The descriptors in the symbol\n              \"\"\"\n              result = []\n              while self.index < len(self.symbol):\n                  descriptor = self.parse_descriptor()\n                  result.append(descriptor)\n              return result\n      \n          \n      def peek_next(self) -> Optional[str]:\n              \"\"\"\n              Peek at the next character in the symbol\n      \n              Returns:\n                  Optional[str] - The next character in the symbol,\n                      or None if there is no next character\n              \"\"\"\n              if self.index + 1 < len(self.symbol):\n                  return self.symbol[self.index + 1]\n              return None\n      \n          \n  Building context for related symbols -\n  \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.symbol.parser.parse_symbol\n    \n      Class Docstring:\n        Parses a symbol from a URI\n        \n        Args:\n        symbol_uri (str): The URI of the symbol\n        include_descriptors (bool): Whether to include descriptors in the symbol\n        \n        Returns:\n        Symbol - The parsed symbol\n        \n      Methods:\n        parse_symbol(symbol_uri: str, include_descriptors: bool = True) -> Symbol\n        \n    automata.tests.unit.test_symbol_parser.test_parse_symbol\n    \n        def test_parse_symbol(symbols):\n            for symbol in symbols:\n                assert symbol.scheme == \"scip-python\"\n                assert symbol.package.manager == \"python\"\n                assert symbol.package.name == \"automata\"\n                assert symbol.package.version == \"75482692a6fe30c72db516201a6f47d9fb4af065\"\n                assert len(symbol.descriptors) > 0\n        \n        \n        \n        \n    automata.core.symbol.graph.SymbolGraph\n    \n        The `SymbolGraph` class represents a symbol graph that captures relationships between symbols found in source code files and is built from an index protobuf file. Utilizing NetworkX's MultiDiGraph, `SymbolGraph` represents relationships as a directed graph and includes methods for querying relationships, obtaining all available symbols and files, and filtering to subgraphs of rankable symbols. A navigator interface, _SymbolGraphNavigator, is required for getting reachable objects in the symbol subgraph.\n        \n        Example usage:\n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        \n        # Replace with your own file path\n        index_path = \"path/to/index.scip\"\n        symbol_graph = SymbolGraph(index_path)\n        all_symbols = symbol_graph.get_all_available_symbols()\n        ```\n        \n        Limitations include only being built from index protobuf files and the `get_potential_symbol_callers` method requiring downstream filtering to remove non-call statements. Future improvements may address these limitations and better handle edge cases in the symbol graph building process.\n        \n      Methods:\n        def __init__(\n                self, index_path: str = DEFAULT_SCIP_PATH, build_caller_relationships: bool = False\n            ):\n                \"\"\"\n                Initializes SymbolGraph with the path of an index protobuf file.\n        \n                Args:\n                    index_path (str): Path to index protobuf file\n                Returns:\n                    SymbolGraph instance\n                \"\"\"\n                index = self._load_index_protobuf(index_path)\n                builder = GraphBuilder(index, build_caller_relationships)\n                self._graph = builder.build_graph()\n                self.navigator = _SymbolGraphNavigator(self._graph)\n        \n            \n        get_all_available_symbols(self) -> List[Symbol]\n        \n        get_all_files(self) -> List[SymbolFile]\n        \n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n        get_rankable_symbol_subgraph(self, flow_rank=\"bidirectional\", path_filter: Optional[str] = None) -> SubGraph\n        \n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.core.context.py_context.retriever.PyContextRetriever\n    \n        PyContextRetriever is a class that retrieves the context of a symbol in a Python project, helping generate documentation and understanding symbol relationships. It processes abstract syntax tree (AST) nodes and operates on a SymbolGraph with a PyContextRetrieverConfig object. To use it, create a SymbolGraph instance, instantiate the PyContextRetriever with the graph, process a symbol using the `process_symbol` method, and retrieve the context buffer. Note that PyContextRetriever relies on accurate SymbolGraph and PyContextRetrieverConfig inputs; errors in these may cause issues when processing symbols. \n        \n        Usage Example:\n        \n        ```python\n        from automata.core.context.py_context.retriever import PyContextRetriever\n        from automata.core.symbol.graph import SymbolGraph\n        \n        graph = SymbolGraph()\n        py_context_retriever = PyContextRetriever(graph)\n        symbol = some_symbol\n        \n        # Process the context of the symbol\n        py_context_retriever.process_symbol(symbol)\n        \n        # Retrieve the context buffer\n        context_buffer = py_context_retriever.get_context_buffer()\n        ```\n        \n      Class Docstring:\n        The PyContextRetriever is used to retrieve the context of a symbol in a Python project\n        \n      Methods:\n        IndentManager(self) -> None\n        \n        def __init__(\n                self,\n                graph: SymbolGraph,\n                config: PyContextRetrieverConfig = PyContextRetrieverConfig(),\n                doc_embedding_db: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                Args:\n                    graph (SymbolGraph): The symbol graph to use\n                    config (PyContextRetrieverConfig): The configuration to use\n                \"\"\"\n                self.graph = graph\n                self.config = config\n                self.indent_level = 0\n                self.doc_embedding_db = doc_embedding_db\n                self.encoding = tiktoken.encoding_for_model(self.config.model_name)\n        \n                self.reset()\n        \n            \n        get_context_buffer(self) -> str\n        \n        indent() -> str\n        \n        process_ast(self, symbol: Symbol) -> None\n        \n        process_docstring(self, ast_object: RedBaron) -> None\n        \n        process_documentation(self, symbol: Symbol, is_main_symbol: bool) -> None\n        \n        process_headline(self, symbol: Symbol) -> None\n        \n        process_imports(self, symbol: Symbol) -> None\n        \n        process_message(self, message: str) -> None\n        \n        process_method(self, method: RedBaron, is_main_symbol: bool) -> None\n        \n        process_symbol(self,\n                symbol: Symbol,\n                related_symbols: List[Symbol] = [],\n            ) -> None\n        \n        reset(self) -> None\n        \n    automata.core.symbol.symbol_types.SymbolDescriptor\n    \n        `SymbolDescriptor` is a Python class that wraps the descriptor component of a Universal Resource Identifier (URI) and represents various symbols such as local, namespace, type, method, term, macro, parameter, and type-parameter. It provides methods to convert the descriptor suffix from the URI representation to a Python representation, extract the escaped name from a string, and represent the object as a URI string. However, it may not support custom URI representations or descriptors that do not follow the predefined format and structure. For example, an instance of `SymbolDescriptor` can be created using a name, suffix, and an optional disambiguator like this:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolDescriptor\n        from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n        \n        name = \"example_descriptor\"\n        suffix = DescriptorProto.Type\n        disambiguator = \"example_disambiguator\"\n        \n        descriptor = SymbolDescriptor(name, suffix, disambiguator)\n        ```\n        \n        Follow-up questions include exploring ways to update `SymbolDescriptor` to handle custom URI representations or descriptors that do not follow the predefined format and understanding any precautions that need to be taken when using `SymbolDescriptor`.\n        \n      Class Docstring:\n        Wraps the descriptor component of the URI into a python object\n        \n      Methods:\n        def __init__(self, name: str, suffix: DescriptorProto, disambiguator: Optional[str] = None):\n                self.name = name\n                self.suffix = suffix\n                self.disambiguator = disambiguator\n        \n            \n        __repr__(self) -> None\n        \n        convert_scip_to_python_suffix(descriptor_suffix: DescriptorProto,\n            ) -> PyKind\n        \n        get_escaped_name(name) -> None\n        \n        is_simple_identifier(name) -> None\n        \n        unparse(self) -> None\n        \n    automata.tests.unit.conftest.symbols\n    \n        @pytest.fixture\n        def symbols():\n            symbols = [\n                # Symbol with a simple attribute\n                parse_symbol(\n                    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `config.automata_agent_config`/AutomataAgentConfig#description.\"\n                ),\n                # Symbol with a method with foreign argument\n                parse_symbol(\n                    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `config.automata_agent_config`/AutomataAgentConfig#load().(config_name)\"\n                ),\n                # Symbol with a class method, self as argument\n                # parse_symbol(\n                #     \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `tools.python_tools.python_ast_indexer`/PythonASTIndexer#get_module_path().(self)\"\n                # ),\n                # Symbol with a locally defined object\n                parse_symbol(\n                    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `core.tasks.automata_task_executor`/logger.\"\n                ),\n                # Symbol with a class object and class variable\n                parse_symbol(\n                    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `config.automata_agent_config`/AutomataAgentConfig#verbose.\"\n                ),\n                # Symbol with a function in a module\n                # parse_symbol(\"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `core.coordinator.tests.test_automata_coordinator`/test().(coordinator)\"),\n                # Symbol with a class method\n                parse_symbol(\n                    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `evals.eval_helpers`/EvalAction#__init__().(action)\"\n                ),\n                # Symbol with an object\n                parse_symbol(\n                    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `core.agent.automata_agent_enums`/ActionIndicator#CODE.\"\n                ),\n                # Class Name\n                parse_symbol(\n                    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `core.agent.automata_agent_enums`/ActionIndicator#\"\n                ),\n                # Init\n                parse_symbol(\n                    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `core.base.tool`/ToolNotFoundError#__init__().\"\n                ),\n            ]\n        \n            return symbols\n        \n        \n        \n        \n    automata.core.symbol.search.tests.conftest.symbols\n    \n        @pytest.fixture\n        def symbols():\n            symbols = [\n                # Symbol with a simple attribute\n                parse_symbol(\n                    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `config.automata_agent_config`/AutomataAgentConfig#description.\"\n                ),\n                # Symbol with a method with foreign argument\n                parse_symbol(\n                    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `config.automata_agent_config`/AutomataAgentConfig#load().(config_name)\"\n                ),\n                # Symbol with a class method, self as argument\n                # parse_symbol(\n                #     \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `tools.python_tools.python_ast_indexer`/PythonASTIndexer#get_module_path().(self)\"\n                # ),\n                # Symbol with a locally defined object\n                parse_symbol(\n                    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `core.tasks.automata_task_executor`/logger.\"\n                ),\n                # Symbol with a class object and class variable\n                parse_symbol(\n                    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `config.automata_agent_config`/AutomataAgentConfig#verbose.\"\n                ),\n                # Symbol with a function in a module\n                # parse_symbol(\"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `core.coordinator.tests.test_automata_coordinator`/test().(coordinator)\"),\n                # Symbol with a class method\n                parse_symbol(\n                    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `evals.eval_helpers`/EvalAction#__init__().(action)\"\n                ),\n                # Symbol with an object\n                parse_symbol(\n                    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `core.agent.automata_agent_enums`/ActionIndicator#CODE.\"\n                ),\n                # Class Name\n                parse_symbol(\n                    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `core.agent.automata_agent_enums`/ActionIndicator#\"\n                ),\n                # Init\n                parse_symbol(\n                    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `core.base.tool`/ToolNotFoundError#__init__().\"\n                ),\n            ]\n        \n            return symbols\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.SymbolEmbedding\n    \n        SymbolEmbedding is an abstract base class used to represent various symbol embeddings, such as SymbolCodeEmbedding and SymbolDocEmbedding. It provides a basic structure for initializing and managing these embeddings, taking into account their source and their vector representation in the feature space. SymbolEmbedding is utilized by different embedding handlers like SymbolCodeEmbeddingHandler and SymbolDocEmbeddingHandler. As a base class, its functionality is limited and should be extended by classes with specific embedding types. An example of creating a SymbolCodeEmbedding instance is shown below:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def __init__(self, message): pass\"\n        vector = np.array([0.1, 0.2, 0.3])\n        \n        symbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Abstract base class for different types of embeddings\n        \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.search.rank`/SymbolRank#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.search.rank", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolRank", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolRank\n\n`SymbolRank` is a class that computes the PageRank algorithm on symbols in a graph. It takes a directed graph as input and calculates the SymbolRanks of each node in the graph. It provides a way to rank the relevance of symbols in a given graph based on their connectivity and usage.\n\n## Overview\n\nThe `SymbolRank` class is used to calculate the symbol ranks for a directed graph. It uses the PageRank algorithm to assign a rank value to each symbol in the graph based on their connections and usage. This ranking can be used to determine the importance of symbols in various contexts, such as symbol search, code analysis, and documentation generation.\n\n## Related Symbols\n\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.search.symbol_search.SymbolSearch`\n- `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n- `automata.core.embedding.symbol_similarity.SymbolSimilarity`\n- `automata.core.symbol.graph.SymbolGraph`\n\n## Example\n\nThe following example demonstrates how to create an instance of `SymbolRank` and calculate the symbol ranks for a simple directed graph.\n\n```python\nimport networkx as nx\nfrom automata.core.symbol.search.rank import SymbolRank\n\n# Create a simple directed graph\nG = nx.DiGraph()\nG.add_edge(1, 2)\nG.add_edge(2, 3)\nG.add_edge(3, 1)\n\n# Initialize SymbolRank with the graph\nsymbol_rank = SymbolRank(G)\n\n# Calculate SymbolRanks for the graph\nranks = symbol_rank.get_ranks()\n\nprint(ranks)\n```\n\n## Limitations\n\nThe primary limitation of the `SymbolRank` class is that it only supports directed graphs with symbols as nodes. Additionally, the convergence of the power iteration used by the PageRank algorithm is not guaranteed for all graphs.\n\n## Follow-up Questions:\n\n- Is there a way to make the SymbolRank algorithm more efficient for larger graphs?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 198}, false, {"py/b64": "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"}]}]}, "source_code": "class SymbolRank:\n    \"\"\"Computes the PageRank algorithm on symbols in a graph\"\"\"\n\n    def __init__(self, graph: nx.DiGraph, config: Optional[SymbolRankConfig] = None):\n        \"\"\"\n        Args:\n            graph (nx.DiGraph): A directed graph\n            config (Optional[SymbolRankConfig]): SymbolRank configuration\n        \"\"\"\n        if not config:\n            config = SymbolRankConfig()\n        self.graph = graph\n        self.config = config\n        self.config.validate(self.config)\n\n    def get_ranks(\n        self,\n        query_to_symbol_similarity: Optional[Dict[Symbol, float]] = None,\n        initial_weights: Optional[Dict[Symbol, float]] = None,\n        dangling: Optional[Dict[Symbol, float]] = None,\n    ) -> List[Tuple[Symbol, float]]:\n        \"\"\"\n        Calculate the SymbolRanks of each node in the graph\n\n        Args:\n            query_to_symbol_similarity (Optional[Dict[Symbol, float]]):\n                query_to_symbol_similarity dictionary\n            initial_weights (Optional[Dict[Symbol, float]]): Initial weights dictionary\n            dangling (Optional[Dict[Symbol, float]]): List of dangling nodes\n\n        Returns:\n            (Dict[str, float]): A dictionary mapping each node to its SymbolRank\n        \"\"\"\n        stochastic_graph = self._prepare_graph()\n        node_count = stochastic_graph.number_of_nodes()\n\n        rank_vec = self._prepare_initial_ranks(stochastic_graph, initial_weights)\n        prepared_similarity = self._prepare_query_to_symbol_similarity(\n            node_count, stochastic_graph, query_to_symbol_similarity\n        )\n        dangling_weights = self._prepare_dangling_weights(dangling, prepared_similarity)\n        dangling_nodes = self._get_dangling_nodes(stochastic_graph)\n\n        for _ in range(self.config.max_iterations):\n            last_rank_vec = rank_vec\n            rank_vec = {k: 0.0 for k in last_rank_vec.keys()}\n            danglesum = self.config.alpha * sum(last_rank_vec[node] for node in dangling_nodes)  # type: ignore\n            for node in rank_vec:\n                for nbr in stochastic_graph[node]:\n                    rank_vec[nbr] += (\n                        self.config.alpha\n                        * last_rank_vec[node]\n                        * stochastic_graph[node][nbr][self.config.weight_key]\n                    )\n                rank_vec[node] += (\n                    danglesum * dangling_weights[node]\n                    + (1.0 - self.config.alpha) * prepared_similarity[node]\n                )\n\n            err = sum(abs(rank_vec[node] - last_rank_vec[node]) for node in rank_vec)\n            if err < node_count * self.config.tolerance:\n                sorted_dict = sorted(rank_vec.items(), key=lambda x: x[1], reverse=True)\n                return sorted_dict\n\n        raise NetworkXError(\n            \"SymbolRank: power iteration failed to converge in %d iterations.\"\n            % self.config.max_iterations\n        )\n\n    def _prepare_graph(self) -> nx.DiGraph:\n        \"\"\"\n        Prepare the graph for the SymbolRank algorithm. If the graph is not directed,\n        convert it to a directed graph. Create a stochastic graph from the given graph\n\n        Returns:\n            stochastic_graph (nx.DiGraph): A NetworkX stochastic DiGraph\n        \"\"\"\n        if not self.graph.is_directed():\n            direct_graph = self.graph.to_directed()\n        else:\n            direct_graph = self.graph\n\n        stochastic_graph = nx.stochastic_graph(direct_graph, weight=self.config.weight_key)\n        return stochastic_graph\n\n    def _prepare_initial_ranks(\n        self,\n        stochastic_graph: nx.DiGraph,\n        initial_weights: Optional[Dict[Symbol, float]],\n    ) -> Dict[Symbol, float]:\n        \"\"\"\n        Prepare initial rank values for each node in the graph\n\n        Args:\n            stochastic_graph (nx.DiGraph): A NetworkX DiGraph.\n            initial_weights (Optional[Dict[Symbol, float]]): Initial weight for each node\n\n        Returns:\n            (Dict[Symbol, float]): A dictionary mapping each node to its initial rank\n        \"\"\"\n\n        node_count = stochastic_graph.number_of_nodes()\n        if initial_weights is None:\n            return {k: 1.0 / node_count for k in stochastic_graph}\n        else:\n            s = sum(initial_weights.values())\n            return {k: v / s for k, v in initial_weights.items()}\n\n    def _prepare_query_to_symbol_similarity(\n        self,\n        node_count: int,\n        stochastic_graph: nx.DiGraph,\n        query_to_symbol_similarity: Optional[Dict[Symbol, float]],\n    ) -> Dict[Symbol, float]:\n        \"\"\"\n        Prepare the symbol similarity matrix\n\n        Note - The term \"personalization\" is used in the context of the PageRank algorithm\n            to refer to a mechanism that allows the modification of the rank computation\n            based on some user-defined preferences. In this instance, symbol similarity is\n            an implementation of personalization that allows the modification of the rank\n            computation based on symbol source-code similarity\n\n        Args:\n            node_count (int): Number of nodes in the graph\n            stochastic_graph (nx.DiGraph): A NetworkX DiGraph\n            query_to_symbol_similarity (Optional[Dict[Symbol, float]]): Similarity between the query\n                and each node\n\n        Returns:\n            (Dict[Symbol, float]): A dictionary mapping each node to its symbol similarity\n        \"\"\"\n        if query_to_symbol_similarity is None:\n            return {k: 1.0 / node_count for k in stochastic_graph}\n        else:\n            missing = set(self.graph) - set(query_to_symbol_similarity)\n            if missing:\n                raise NetworkXError(\n                    \"query_to_symbol_similarity dictionary must have a value for every node. Missing nodes %s\"\n                    % missing\n                )\n            s = sum(query_to_symbol_similarity.values())\n            return {k: v / s for k, v in query_to_symbol_similarity.items()}\n\n    def _prepare_dangling_weights(\n        self,\n        dangling: Optional[Dict[Symbol, float]],\n        query_to_symbol_similarity: Dict[Symbol, float],\n    ) -> Dict[Symbol, float]:\n        \"\"\"\n        Prepare the weights for dangling nodes\n\n        Args:\n            dangling (list): List of dangling nodes.\n            query_to_symbol_similarity (Dict[str, float]): query_to_symbol_similarity dictionary\n\n        Returns:\n            (Dict[str, float]): A dictionary mapping each node to its weight\n        \"\"\"\n        if dangling is None:\n            return query_to_symbol_similarity\n        else:\n            missing = set(self.graph) - set(dangling)\n            if missing:\n                raise NetworkXError(\n                    \"Dangling node dictionary must have a value for every node. Missing nodes %s\"\n                    % missing\n                )\n            s = sum(dangling.values())\n            return {k: v / s for k, v in dangling.items()}\n\n    def _get_dangling_nodes(self, stochastic_graph: nx.DiGraph) -> List[Hashable]:\n        \"\"\"\n        Identify dangling nodes in the graph\n\n        Args:\n            stochastic_graph (nx.DiGraph): A NetworkX DiGraph\n\n        Returns:\n            (list): List of dangling nodes\n        \"\"\"\n        return [\n            node\n            for node in stochastic_graph\n            if stochastic_graph.out_degree(node, weight=self.config.weight_key) == 0.0\n        ]\n", "summary": "`SymbolRank` is a class that computes the PageRank algorithm on symbols in a directed graph, calculating the SymbolRanks of each node based on their connectivity and usage. This ranking system is useful in various contexts such as symbol search, code analysis, and documentation generation. However, the primary limitation is that it only supports directed graphs with symbols as nodes and the convergence of the algorithm isn't guaranteed for all graphs. An example of creating an instance of `SymbolRank` and calculating the symbol ranks for a simple directed graph is included below:\n\n```python\nimport networkx as nx\nfrom automata.core.symbol.search.rank import SymbolRank\n\n# Create a simple directed graph\nG = nx.DiGraph()\nG.add_edge(1, 2)\nG.add_edge(2, 3)\nG.add_edge(3, 1)\n\n# Initialize SymbolRank with the graph\nsymbol_rank = SymbolRank(G)\n\n# Calculate SymbolRanks for the graph\nranks = symbol_rank.get_ranks()\n\nprint(ranks)\n```", "context": "\n    Generate the documentation for SymbolRank using the context shown below -\n  Building context for primary symbol - automata.core.symbol.search.rank.SymbolRank -\n  \n    Import Statements:\n      import networkx as nx\n      from typing import Dict, Hashable, List, Optional, Tuple\n      from networkx.exception import NetworkXError\n      from pydantic import BaseModel\n      from automata.core.symbol.symbol_types import Symbol\n      \n      # SymbolRank\n      \n      `SymbolRank` is a class that computes the PageRank algorithm on symbols in a graph. It takes a directed graph as input and calculates the SymbolRanks of each node in the graph. It provides a way to rank the relevance of symbols in a given graph based on their connectivity and usage.\n      \n      ## Overview\n      \n      The `SymbolRank` class is used to calculate the symbol ranks for a directed graph. It uses the PageRank algorithm to assign a rank value to each symbol in the graph based on their connections and usage. This ranking can be used to determine the importance of symbols in various contexts, such as symbol search, code analysis, and documentation generation.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.search.symbol_search.SymbolSearch`\n      - `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n      - `automata.core.embedding.symbol_similarity.SymbolSimilarity`\n      - `automata.core.symbol.graph.SymbolGraph`\n      \n      ## Example\n      \n      The following example demonstrates how to create an instance of `SymbolRank` and calculate the symbol ranks for a simple directed graph.\n      \n      ```python\n      import networkx as nx\n      from automata.core.symbol.search.rank import SymbolRank\n      \n      # Create a simple directed graph\n      G = nx.DiGraph()\n      G.add_edge(1, 2)\n      G.add_edge(2, 3)\n      G.add_edge(3, 1)\n      \n      # Initialize SymbolRank with the graph\n      symbol_rank = SymbolRank(G)\n      \n      # Calculate SymbolRanks for the graph\n      ranks = symbol_rank.get_ranks()\n      \n      print(ranks)\n      ```\n      \n      ## Limitations\n      \n      The primary limitation of the `SymbolRank` class is that it only supports directed graphs with symbols as nodes. Additionally, the convergence of the power iteration used by the PageRank algorithm is not guaranteed for all graphs.\n      \n      ## Follow-up Questions:\n      \n      - Is there a way to make the SymbolRank algorithm more efficient for larger graphs?\n      \n    Class Docstring:\n      Computes the PageRank algorithm on symbols in a graph\n      \n    Methods:\n      def __init__(self, graph: nx.DiGraph, config: Optional[SymbolRankConfig] = None):\n              \"\"\"\n              Args:\n                  graph (nx.DiGraph): A directed graph\n                  config (Optional[SymbolRankConfig]): SymbolRank configuration\n              \"\"\"\n              if not config:\n                  config = SymbolRankConfig()\n              self.graph = graph\n              self.config = config\n              self.config.validate(self.config)\n      \n          \n      def get_ranks(\n              self,\n              query_to_symbol_similarity: Optional[Dict[Symbol, float]] = None,\n              initial_weights: Optional[Dict[Symbol, float]] = None,\n              dangling: Optional[Dict[Symbol, float]] = None,\n          ) -> List[Tuple[Symbol, float]]:\n              \"\"\"\n              Calculate the SymbolRanks of each node in the graph\n      \n              Args:\n                  query_to_symbol_similarity (Optional[Dict[Symbol, float]]):\n                      query_to_symbol_similarity dictionary\n                  initial_weights (Optional[Dict[Symbol, float]]): Initial weights dictionary\n                  dangling (Optional[Dict[Symbol, float]]): List of dangling nodes\n      \n              Returns:\n                  (Dict[str, float]): A dictionary mapping each node to its SymbolRank\n              \"\"\"\n              stochastic_graph = self._prepare_graph()\n              node_count = stochastic_graph.number_of_nodes()\n      \n              rank_vec = self._prepare_initial_ranks(stochastic_graph, initial_weights)\n              prepared_similarity = self._prepare_query_to_symbol_similarity(\n                  node_count, stochastic_graph, query_to_symbol_similarity\n              )\n              dangling_weights = self._prepare_dangling_weights(dangling, prepared_similarity)\n              dangling_nodes = self._get_dangling_nodes(stochastic_graph)\n      \n              for _ in range(self.config.max_iterations):\n                  last_rank_vec = rank_vec\n                  rank_vec = {k: 0.0 for k in last_rank_vec.keys()}\n                  danglesum = self.config.alpha * sum(last_rank_vec[node] for node in dangling_nodes)  # type: ignore\n                  for node in rank_vec:\n                      for nbr in stochastic_graph[node]:\n                          rank_vec[nbr] += (\n                              self.config.alpha\n                              * last_rank_vec[node]\n                              * stochastic_graph[node][nbr][self.config.weight_key]\n                          )\n                      rank_vec[node] += (\n                          danglesum * dangling_weights[node]\n                          + (1.0 - self.config.alpha) * prepared_similarity[node]\n                      )\n      \n                  err = sum(abs(rank_vec[node] - last_rank_vec[node]) for node in rank_vec)\n                  if err < node_count * self.config.tolerance:\n                      sorted_dict = sorted(rank_vec.items(), key=lambda x: x[1], reverse=True)\n                      return sorted_dict\n      \n              raise NetworkXError(\n                  \"SymbolRank: power iteration failed to converge in %d iterations.\"\n                  % self.config.max_iterations\n              )\n      \n          \n  Building context for related symbols -\n  \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_symbol_rank.test_get_ranks\n    \n        def test_get_ranks():\n            nodes = 10\n            edges = 20\n            G = generate_random_graph(nodes, edges)\n            config = SymbolRankConfig()\n            pagerank = SymbolRank(G, config)\n        \n            ranks = pagerank.get_ranks()\n            assert len(ranks) == nodes\n            assert sum([ele[1] for ele in ranks]) == pytest.approx(1.0)\n        \n        \n        \n        \n    automata.tests.unit.test_symbol_rank.test_get_ranks_small_graph\n    \n        def test_get_ranks_small_graph():\n            G = DiGraph()\n            G.add_edge(1, 2)\n            G.add_edge(2, 3)\n            G.add_edge(3, 1)\n            config = SymbolRankConfig()\n            pagerank = SymbolRank(G, config)\n        \n            ranks = pagerank.get_ranks()\n            assert len(ranks) == 3\n            assert sum([ele[1] for ele in ranks]) == pytest.approx(1.0)\n        \n        \n    automata.tests.unit.test_symbol_rank.test_prepare_initial_ranks\n    \n        def test_prepare_initial_ranks():\n            nodes = 10\n            edges = 20\n            G = generate_random_graph(nodes, edges)\n            config = SymbolRankConfig()\n            pagerank = SymbolRank(G, config)\n        \n            initial_ranks = pagerank._prepare_initial_ranks(G, None)\n            assert len(initial_ranks) == nodes\n            assert sum(initial_ranks.values()) == pytest.approx(1.0)\n        \n        \n        \n        \n    automata.core.symbol.search.symbol_search.SymbolSearch\n    \n        `SymbolSearch` is a class used to search for symbols in a `SymbolGraph` by processing NLP-formatted queries and providing search results in various formats depending on the query type. The class utilizes a symbol similarity algorithm for ranking symbols according to relevance and a SymbolRank algorithm for computing a global symbol ranking. To use `SymbolSearch`, first initialize the necessary objects, such as `SymbolGraph` and `SymbolSimilarity`, then create a `SymbolSearch` object and process a query to obtain the search results.\n        \n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        from automata.core.embedding.symbol_similarity import SymbolSimilarity\n        from automata.core.symbol.search.symbol_search import SymbolSearch\n        \n        # Initialize necessary objects\n        symbol_graph = SymbolGraph()\n        symbol_similarity = SymbolSimilarity()\n        \n        # Create the SymbolSearch object\n        symbol_searcher = SymbolSearch(symbol_graph, symbol_similarity)\n        \n        # Process a query and get the search results\n        query = \"type:symbol_references <symbol_uri>\"\n        result = symbol_searcher.process_query(query)\n        ```\n        \n        Note that `SymbolSearch` relies on the availability of symbols in the `SymbolGraph` and `SymbolSimilarity` objects, and will produce incomplete or incorrect results if the necessary data is missing or the input query does not follow the expected format.\n        \n      Class Docstring:\n        Searches for symbols in a SymbolGraph\n        \n      Methods:\n        def __init__(\n                self,\n                symbol_graph: SymbolGraph,\n                symbol_similarity: SymbolSimilarity,\n                symbol_rank_config: Optional[SymbolRankConfig],\n                code_subgraph: Optional[SymbolGraph.SubGraph] = None,\n                *args,\n                **kwargs,\n            ):\n                \"\"\"\n                Args:\n                    symbol_graph (SymbolGraph): A SymbolGraph\n                    symbol_similarity (SymbolSimilarity): A SymbolSimilarity object\n                    symbol_rank_config (Optional[SymbolRankConfig]): A SymbolRankConfig object\n                    code_subgraph (Optional[SymbolGraph.SubGraph]): A subgraph of the SymbolGraph\n                \"\"\"\n        \n                if not code_subgraph:\n                    code_subgraph = symbol_graph.get_rankable_symbol_subgraph(\n                        kwargs.get(\"flow_rank\", \"bidirectional\")\n                    )\n                else:\n                    if not code_subgraph.parent == symbol_graph:\n                        raise ValueError(\"code_subgraph must be a subgraph of symbol_graph\")\n        \n                graph_symbols = symbol_graph.get_all_available_symbols()\n                embedding_symbols = symbol_similarity.embedding_handler.get_all_supported_symbols()\n                available_symbols = set(graph_symbols).intersection(set(embedding_symbols))\n                SymbolSearch.filter_graph(code_subgraph.graph, available_symbols)\n        \n                # TODO - Do we need to filter the SymbolGraph as well?\n                self.symbol_graph = symbol_graph\n                self.symbol_similarity = symbol_similarity\n                symbol_similarity.set_available_symbols(available_symbols)\n                self.symbol_rank = SymbolRank(code_subgraph.graph, config=symbol_rank_config)\n        \n            \n        exact_search(self, pattern: str) -> ExactSearchResult\n        \n        filter_graph(graph: nx.DiGraph, available_symbols: Set[Symbol]) -> None\n        \n        find_pattern_in_modules(pattern: str) -> Dict[str, List[int]]\n        \n        process_query(self, query: str) -> Union[SymbolReferencesResult, SymbolRankResult, SourceCodeResult, ExactSearchResult,]\n        \n        retrieve_source_code_by_symbol(self, symbol_uri: str) -> SourceCodeResult\n        \n        shifted_z_score_sq(values: Union[List[float], np.ndarray]) -> np.ndarray\n        \n        symbol_rank_search(self, query: str) -> SymbolRankResult\n        \n        symbol_references(self, symbol_uri: str) -> SymbolReferencesResult\n        \n        transform_dict_values(dictionary: Dict[Any, float], func: Callable[[List[float]], np.ndarray]\n            ) -> None\n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.core.embedding.symbol_similarity.SymbolSimilarity\n    \n        `SymbolSimilarity` is a class that computes similarity scores between query texts and symbols using embeddings, and allows users to retrieve the most similar symbols for a specific query and create a dictionary mapping the similarity scores to each symbol. Users can set the available symbols for the calculation, and the similarity scores depend on the quality of the supplied pre-trained embeddings and selected norm type. The class uses a `SymbolCodeEmbeddingHandler` for handling embeddings, which affects the accuracy of the results.\n        \n        Example usage of `SymbolSimilarity`:\n        ```python\n        import numpy as np\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        from automata.core.embedding.embedding_types import EmbeddingProvider, NormType\n        from automata.core.embedding.symbol_similarity import SymbolSimilarity\n        \n        embedding_handler = SymbolCodeEmbeddingHandler(embedding_db=embedding_db, embedding_provider=embedding_provider)\n        symbol_similarity = SymbolSimilarity(symbol_embedding_manager=embedding_handler, norm_type=NormType.L2)\n        symbol_similarity.set_available_symbols(available_symbols)\n        nearest_entries = symbol_similarity.get_nearest_entries_for_query(\"example query\", k=5)\n        query_similarity_dict = symbol_similarity.get_query_similarity_dict(\"example query\")\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                symbol_embedding_manager: SymbolCodeEmbeddingHandler,\n                norm_type: NormType = NormType.L2,\n            ):\n                \"\"\"\n                Initialize SymbolSimilarity\n        \n                Args:\n                    symbol_embedding_manager: A CodeEmbeddingManager\n                    norm_type (NormType): The norm type to use for calculating similarity\n        \n                Returns:\n                    An instance of SymbolSimilarity\n                \"\"\"\n                self.embedding_handler: SymbolCodeEmbeddingHandler = symbol_embedding_manager\n                self.embedding_provider: EmbeddingProvider = symbol_embedding_manager.embedding_provider\n                self.norm_type = norm_type\n                supported_symbols = self.embedding_handler.get_all_supported_symbols()\n                self.index_to_symbol = {i: symbol for i, symbol in enumerate(supported_symbols)}\n                self.symbol_to_index = {symbol: i for i, symbol in enumerate(supported_symbols)}\n                self.available_symbols: Optional[Set[Symbol]] = None\n        \n            \n        get_available_symbols(self) -> List[Symbol]\n        \n        get_nearest_entries_for_query(self, query_text: str, k: int = 10) -> Dict[Symbol, float]\n        \n        get_query_similarity_dict(self, query_text: str) -> Dict[Symbol, float]\n        \n        set_available_symbols(self, available_symbols: Set[Symbol]) -> None\n        \n    automata.tests.unit.conftest.symbol_searcher\n    \n        @pytest.fixture\n        def symbol_searcher(mocker, symbol_graph_mock):\n            symbol_similarity_mock = mocker.MagicMock(spec=SymbolSimilarity)\n            symbol_similarity_mock.embedding_handler = mocker.MagicMock(spec=SymbolCodeEmbeddingHandler)\n            symbol_rank_config_mock = mocker.MagicMock(spec=SymbolRankConfig)\n        \n            return SymbolSearch(\n                symbol_graph_mock,\n                symbol_similarity_mock,\n                symbol_rank_config_mock,\n            )\n        \n        \n    automata.core.embedding.embedding_types.NormType\n    \n        `NormType` is an enumeration class representing various normalization techniques available for calculating similarity in a `SymbolSimilarity` object, offering three options: L1, L2, and softmax. These can be used by the `SymbolSimilarity` class while computing similarities between symbols in a related codebase. However, using different normalization techniques may lead to potential limitations such as differences in interpretation and efficiency of similarity calculations. For example:\n        \n        ```python\n        from automata.core.embedding.symbol_similarity import SymbolSimilarity\n        from automata.core.embedding.embedding_types import NormType\n        from automata.core.embedding.manager.code_embedding_manager import SymbolCodeEmbeddingHandler\n        \n        symbol_embedding_manager = SymbolCodeEmbeddingHandler()\n        custom_norm_type = NormType.L1\n        \n        symbol_similarity = SymbolSimilarity(symbol_embedding_manager, custom_norm_type)\n        ```\n        Possible follow-up questions include exploring other normalization techniques to add to the `NormType` class and understanding the impact of different normalization techniques on the performance and interpretation of similarity calculations.\n        \n    automata.core.symbol.graph.SymbolGraph\n    \n        The `SymbolGraph` class represents a symbol graph that captures relationships between symbols found in source code files and is built from an index protobuf file. Utilizing NetworkX's MultiDiGraph, `SymbolGraph` represents relationships as a directed graph and includes methods for querying relationships, obtaining all available symbols and files, and filtering to subgraphs of rankable symbols. A navigator interface, _SymbolGraphNavigator, is required for getting reachable objects in the symbol subgraph.\n        \n        Example usage:\n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        \n        # Replace with your own file path\n        index_path = \"path/to/index.scip\"\n        symbol_graph = SymbolGraph(index_path)\n        all_symbols = symbol_graph.get_all_available_symbols()\n        ```\n        \n        Limitations include only being built from index protobuf files and the `get_potential_symbol_callers` method requiring downstream filtering to remove non-call statements. Future improvements may address these limitations and better handle edge cases in the symbol graph building process.\n        \n      Methods:\n        def __init__(\n                self, index_path: str = DEFAULT_SCIP_PATH, build_caller_relationships: bool = False\n            ):\n                \"\"\"\n                Initializes SymbolGraph with the path of an index protobuf file.\n        \n                Args:\n                    index_path (str): Path to index protobuf file\n                Returns:\n                    SymbolGraph instance\n                \"\"\"\n                index = self._load_index_protobuf(index_path)\n                builder = GraphBuilder(index, build_caller_relationships)\n                self._graph = builder.build_graph()\n                self.navigator = _SymbolGraphNavigator(self._graph)\n        \n            \n        get_all_available_symbols(self) -> List[Symbol]\n        \n        get_all_files(self) -> List[SymbolFile]\n        \n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n        get_rankable_symbol_subgraph(self, flow_rank=\"bidirectional\", path_filter: Optional[str] = None) -> SubGraph\n        \n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.search.rank`/SymbolRankConfig#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.search.rank", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolRankConfig", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolRankConfig\n\n`SymbolRankConfig` is a configuration class for the `SymbolRank` algorithm, which computes the PageRank algorithm on a given symbol graph. The `SymbolRankConfig` class contains various attributes like `alpha`, `max_iterations`, `tolerance`, and `weight_key` that control the behavior of the algorithm.\n\n## Overview\n\n`SymbolRankConfig` allows users to set custom configuration parameters for the `SymbolRank` algorithm. The class exposes various attributes to control the algorithm's behavior, such as convergence rate, maximum number of iterations, stopping criteria (tolerance), and edge weights. It also provides a validation method to ensure the input configuration parameters are within acceptable limits.\n\n## Related Symbols\n\n- `automata.core.symbol.search.rank.SymbolRank`\n- `automata.tests.unit.test_symbol_rank.test_get_ranks`\n- `automata.tests.unit.test_symbol_rank.test_get_ranks_small_graph`\n- `automata.tests.unit.test_symbol_rank.test_prepare_initial_ranks`\n- `automata.tests.unit.test_symbol_rank.test_pagerank_config_validation`\n\n## Example\n\nThe following example demonstrates the creation of an instance of `SymbolRankConfig` with custom configuration parameters and validation.\n\n```python\nfrom automata.core.symbol.search.rank import SymbolRankConfig\n\n# Custom configuration parameters\ncustom_config = SymbolRankConfig(\n    alpha=0.3,\n    max_iterations=200,\n    tolerance=1.0e-7,\n    weight_key=\"custom_weight\"\n)\n\n# Validate the custom configuration parameters\ncustom_config.validate(custom_config)\n```\n\n## Limitations\n\nThe primary limitation of `SymbolRankConfig` is the restricted range of allowable values for `alpha` and `tolerance`. This might not be suitable for all use cases or specific graphs. Moreover, the validation method raises a `ValueError` for invalid inputs, which could be handled more gracefully.\n\n## Follow-up Questions:\n\n- Are there other configuration parameters that can enhance the `SymbolRankConfig` class?\n- How can we improve validation and error handling in the `SymbolRankConfig` class?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 198}, false, {"py/b64": "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"}]}]}, "source_code": "class SymbolRankConfig(BaseModel):\n    \"\"\"A configuration class for SymbolRank\"\"\"\n\n    alpha: float = 0.25\n    max_iterations: int = 100\n    tolerance: float = 1.0e-6\n    weight_key: str = \"weight\"\n\n    @classmethod\n    def validate(cls, config):\n        \"\"\"\n        Validate configuration parameters.\n\n        Args:\n            config (SymbolRankConfig): Configuration parameters.\n\n        Raises:\n            ValueError: If alpha is not in (0, 1), or tolerance is not in (1e-4, 1e-8).\n        \"\"\"\n        if not 0 < config.alpha < 1:\n            raise ValueError(f\"alpha must be in (0,1), but got {config.alpha}\")\n\n        if not 1.0e-8 < config.tolerance < 1.0e-4:\n            raise ValueError(f\"tolerance must be in (1e-4,1e-8), but got {config.tolerance}\")\n\n\n", "summary": "`SymbolRankConfig` is a configuration class for the `SymbolRank` algorithm, which computes the PageRank algorithm on symbol graphs. It allows users to set custom parameters controlling algorithm behavior, such as convergence rate, maximum iterations, stopping criteria (tolerance), and edge weights. Additionally, it provides a validation method to ensure input parameters are within acceptable limits. One limitation is the restricted range of allowable values for `alpha` and `tolerance`, which might not be suitable for all use cases or specific graphs. Here's an example of creating a `SymbolRankConfig` instance with custom parameters and validation:\n\n```python\nfrom automata.core.symbol.search.rank import SymbolRankConfig\n\n# Custom configuration parameters\ncustom_config = SymbolRankConfig(\n    alpha=0.3,\n    max_iterations=200,\n    tolerance=1.0e-7,\n    weight_key=\"custom_weight\"\n)\n\n# Validate the custom configuration parameters\ncustom_config.validate(custom_config)\n```", "context": "\n    Generate the documentation for SymbolRankConfig using the context shown below -\n  Building context for primary symbol - automata.core.symbol.search.rank.SymbolRankConfig -\n  \n      class SymbolRankConfig(BaseModel):\n          \"\"\"A configuration class for SymbolRank\"\"\"\n      \n          alpha: float = 0.25\n          max_iterations: int = 100\n          tolerance: float = 1.0e-6\n          weight_key: str = \"weight\"\n      \n          @classmethod\n          def validate(cls, config):\n              \"\"\"\n              Validate configuration parameters.\n      \n              Args:\n                  config (SymbolRankConfig): Configuration parameters.\n      \n              Raises:\n                  ValueError: If alpha is not in (0, 1), or tolerance is not in (1e-4, 1e-8).\n              \"\"\"\n              if not 0 < config.alpha < 1:\n                  raise ValueError(f\"alpha must be in (0,1), but got {config.alpha}\")\n      \n              if not 1.0e-8 < config.tolerance < 1.0e-4:\n                  raise ValueError(f\"tolerance must be in (1e-4,1e-8), but got {config.tolerance}\")\n      \n      \n      \n      \n  Building context for related symbols -\n  \n    automata.tests.unit.test_symbol_rank.test_get_ranks\n    \n        def test_get_ranks():\n            nodes = 10\n            edges = 20\n            G = generate_random_graph(nodes, edges)\n            config = SymbolRankConfig()\n            pagerank = SymbolRank(G, config)\n        \n            ranks = pagerank.get_ranks()\n            assert len(ranks) == nodes\n            assert sum([ele[1] for ele in ranks]) == pytest.approx(1.0)\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_symbol_rank.test_get_ranks_small_graph\n    \n        def test_get_ranks_small_graph():\n            G = DiGraph()\n            G.add_edge(1, 2)\n            G.add_edge(2, 3)\n            G.add_edge(3, 1)\n            config = SymbolRankConfig()\n            pagerank = SymbolRank(G, config)\n        \n            ranks = pagerank.get_ranks()\n            assert len(ranks) == 3\n            assert sum([ele[1] for ele in ranks]) == pytest.approx(1.0)\n        \n        \n    automata.core.symbol.search.rank.SymbolRank\n    \n        `SymbolRank` is a class that computes the PageRank algorithm to rank the relevance of symbols in a directed graph based on their connectivity and usage. This ranking can be utilized in various contexts such as symbol search, code analysis, and documentation generation. Although the class only supports directed graphs with symbols as nodes and the convergence of the power iteration isn't guaranteed for all graphs, it provides an effective way to analyze symbol importance. \n        \n        For example, to create an instance of `SymbolRank` and calculate the symbol ranks for a simple directed graph: \n        ```python\n        import networkx as nx\n        from automata.core.symbol.search.rank import SymbolRank\n        \n        # Create a simple directed graph\n        G = nx.DiGraph()\n        G.add_edge(1, 2)\n        G.add_edge(2, 3)\n        G.add_edge(3, 1)\n        \n        # Initialize SymbolRank with the graph\n        symbol_rank = SymbolRank(G)\n        \n        # Calculate SymbolRanks for the graph\n        ranks = symbol_rank.get_ranks()\n        \n        print(ranks)\n        ```\n        \n      Class Docstring:\n        Computes the PageRank algorithm on symbols in a graph\n        \n      Methods:\n        def __init__(self, graph: nx.DiGraph, config: Optional[SymbolRankConfig] = None):\n                \"\"\"\n                Args:\n                    graph (nx.DiGraph): A directed graph\n                    config (Optional[SymbolRankConfig]): SymbolRank configuration\n                \"\"\"\n                if not config:\n                    config = SymbolRankConfig()\n                self.graph = graph\n                self.config = config\n                self.config.validate(self.config)\n        \n            \n        get_ranks(self,\n                query_to_symbol_similarity: Optional[Dict[Symbol, float]] = None,\n                initial_weights: Optional[Dict[Symbol, float]] = None,\n                dangling: Optional[Dict[Symbol, float]] = None,\n            ) -> List[Tuple[Symbol, float]]\n        \n    automata.tests.unit.test_symbol_rank.test_prepare_initial_ranks\n    \n        def test_prepare_initial_ranks():\n            nodes = 10\n            edges = 20\n            G = generate_random_graph(nodes, edges)\n            config = SymbolRankConfig()\n            pagerank = SymbolRank(G, config)\n        \n            initial_ranks = pagerank._prepare_initial_ranks(G, None)\n            assert len(initial_ranks) == nodes\n            assert sum(initial_ranks.values()) == pytest.approx(1.0)\n        \n        \n        \n        \n    automata.tests.unit.test_symbol_rank.test_pagerank_config_validation\n    \n        def test_pagerank_config_validation():\n            with pytest.raises(ValueError):\n                invalid_config_alpha = SymbolRankConfig(alpha=1.5, max_iterations=100, tolerance=1.0e-5)\n                invalid_config_alpha.validate(invalid_config_alpha)\n            with pytest.raises(ValueError):\n                invalid_config_tolerance = SymbolRankConfig(\n                    alpha=0.5, max_iterations=100, tolerance=1.0e-3\n                )\n                invalid_config_tolerance.validate(invalid_config_tolerance)\n        \n        \n        \n        \n    automata.tests.unit.conftest.symbol_searcher\n    \n        @pytest.fixture\n        def symbol_searcher(mocker, symbol_graph_mock):\n            symbol_similarity_mock = mocker.MagicMock(spec=SymbolSimilarity)\n            symbol_similarity_mock.embedding_handler = mocker.MagicMock(spec=SymbolCodeEmbeddingHandler)\n            symbol_rank_config_mock = mocker.MagicMock(spec=SymbolRankConfig)\n        \n            return SymbolSearch(\n                symbol_graph_mock,\n                symbol_similarity_mock,\n                symbol_rank_config_mock,\n            )\n        \n        \n    automata.core.embedding.embedding_types.NormType\n    \n        `NormType` is an enumeration class representing various normalization techniques available for calculating similarity in a `SymbolSimilarity` object, offering three options: L1, L2, and softmax. These can be used by the `SymbolSimilarity` class while computing similarities between symbols in a related codebase. However, using different normalization techniques may lead to potential limitations such as differences in interpretation and efficiency of similarity calculations. For example:\n        \n        ```python\n        from automata.core.embedding.symbol_similarity import SymbolSimilarity\n        from automata.core.embedding.embedding_types import NormType\n        from automata.core.embedding.manager.code_embedding_manager import SymbolCodeEmbeddingHandler\n        \n        symbol_embedding_manager = SymbolCodeEmbeddingHandler()\n        custom_norm_type = NormType.L1\n        \n        symbol_similarity = SymbolSimilarity(symbol_embedding_manager, custom_norm_type)\n        ```\n        Possible follow-up questions include exploring other normalization techniques to add to the `NormType` class and understanding the impact of different normalization techniques on the performance and interpretation of similarity calculations.\n        \n    automata.core.symbol.search.symbol_search.SymbolSearch\n    \n        `SymbolSearch` is a class used to search for symbols in a `SymbolGraph` by processing NLP-formatted queries and providing search results in various formats depending on the query type. The class utilizes a symbol similarity algorithm for ranking symbols according to relevance and a SymbolRank algorithm for computing a global symbol ranking. To use `SymbolSearch`, first initialize the necessary objects, such as `SymbolGraph` and `SymbolSimilarity`, then create a `SymbolSearch` object and process a query to obtain the search results.\n        \n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        from automata.core.embedding.symbol_similarity import SymbolSimilarity\n        from automata.core.symbol.search.symbol_search import SymbolSearch\n        \n        # Initialize necessary objects\n        symbol_graph = SymbolGraph()\n        symbol_similarity = SymbolSimilarity()\n        \n        # Create the SymbolSearch object\n        symbol_searcher = SymbolSearch(symbol_graph, symbol_similarity)\n        \n        # Process a query and get the search results\n        query = \"type:symbol_references <symbol_uri>\"\n        result = symbol_searcher.process_query(query)\n        ```\n        \n        Note that `SymbolSearch` relies on the availability of symbols in the `SymbolGraph` and `SymbolSimilarity` objects, and will produce incomplete or incorrect results if the necessary data is missing or the input query does not follow the expected format.\n        \n      Class Docstring:\n        Searches for symbols in a SymbolGraph\n        \n      Methods:\n        def __init__(\n                self,\n                symbol_graph: SymbolGraph,\n                symbol_similarity: SymbolSimilarity,\n                symbol_rank_config: Optional[SymbolRankConfig],\n                code_subgraph: Optional[SymbolGraph.SubGraph] = None,\n                *args,\n                **kwargs,\n            ):\n                \"\"\"\n                Args:\n                    symbol_graph (SymbolGraph): A SymbolGraph\n                    symbol_similarity (SymbolSimilarity): A SymbolSimilarity object\n                    symbol_rank_config (Optional[SymbolRankConfig]): A SymbolRankConfig object\n                    code_subgraph (Optional[SymbolGraph.SubGraph]): A subgraph of the SymbolGraph\n                \"\"\"\n        \n                if not code_subgraph:\n                    code_subgraph = symbol_graph.get_rankable_symbol_subgraph(\n                        kwargs.get(\"flow_rank\", \"bidirectional\")\n                    )\n                else:\n                    if not code_subgraph.parent == symbol_graph:\n                        raise ValueError(\"code_subgraph must be a subgraph of symbol_graph\")\n        \n                graph_symbols = symbol_graph.get_all_available_symbols()\n                embedding_symbols = symbol_similarity.embedding_handler.get_all_supported_symbols()\n                available_symbols = set(graph_symbols).intersection(set(embedding_symbols))\n                SymbolSearch.filter_graph(code_subgraph.graph, available_symbols)\n        \n                # TODO - Do we need to filter the SymbolGraph as well?\n                self.symbol_graph = symbol_graph\n                self.symbol_similarity = symbol_similarity\n                symbol_similarity.set_available_symbols(available_symbols)\n                self.symbol_rank = SymbolRank(code_subgraph.graph, config=symbol_rank_config)\n        \n            \n        exact_search(self, pattern: str) -> ExactSearchResult\n        \n        filter_graph(graph: nx.DiGraph, available_symbols: Set[Symbol]) -> None\n        \n        find_pattern_in_modules(pattern: str) -> Dict[str, List[int]]\n        \n        process_query(self, query: str) -> Union[SymbolReferencesResult, SymbolRankResult, SourceCodeResult, ExactSearchResult,]\n        \n        retrieve_source_code_by_symbol(self, symbol_uri: str) -> SourceCodeResult\n        \n        shifted_z_score_sq(values: Union[List[float], np.ndarray]) -> np.ndarray\n        \n        symbol_rank_search(self, query: str) -> SymbolRankResult\n        \n        symbol_references(self, symbol_uri: str) -> SymbolReferencesResult\n        \n        transform_dict_values(dictionary: Dict[Any, float], func: Callable[[List[float]], np.ndarray]\n            ) -> None\n        \n    automata.core.symbol.graph.SymbolGraph\n    \n        The `SymbolGraph` class represents a symbol graph that captures relationships between symbols found in source code files and is built from an index protobuf file. Utilizing NetworkX's MultiDiGraph, `SymbolGraph` represents relationships as a directed graph and includes methods for querying relationships, obtaining all available symbols and files, and filtering to subgraphs of rankable symbols. A navigator interface, _SymbolGraphNavigator, is required for getting reachable objects in the symbol subgraph.\n        \n        Example usage:\n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        \n        # Replace with your own file path\n        index_path = \"path/to/index.scip\"\n        symbol_graph = SymbolGraph(index_path)\n        all_symbols = symbol_graph.get_all_available_symbols()\n        ```\n        \n        Limitations include only being built from index protobuf files and the `get_potential_symbol_callers` method requiring downstream filtering to remove non-call statements. Future improvements may address these limitations and better handle edge cases in the symbol graph building process.\n        \n      Methods:\n        def __init__(\n                self, index_path: str = DEFAULT_SCIP_PATH, build_caller_relationships: bool = False\n            ):\n                \"\"\"\n                Initializes SymbolGraph with the path of an index protobuf file.\n        \n                Args:\n                    index_path (str): Path to index protobuf file\n                Returns:\n                    SymbolGraph instance\n                \"\"\"\n                index = self._load_index_protobuf(index_path)\n                builder = GraphBuilder(index, build_caller_relationships)\n                self._graph = builder.build_graph()\n                self.navigator = _SymbolGraphNavigator(self._graph)\n        \n            \n        get_all_available_symbols(self) -> List[Symbol]\n        \n        get_all_files(self) -> List[SymbolFile]\n        \n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n        get_rankable_symbol_subgraph(self, flow_rank=\"bidirectional\", path_filter: Optional[str] = None) -> SubGraph\n        \n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.search.symbol_search`/SymbolSearch#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.search.symbol_search", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolSearch", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolSearch\n\n`SymbolSearch` is a class that searches for symbols in a `SymbolGraph`. It provides methods to process NLP-formatted queries and searches for exact matches, symbol references, symbol rankings, and source code retrieval.\n\n## Overview\n\n`SymbolSearch` is initialized with a `SymbolGraph`, a `SymbolSimilarity` object, an optional `SymbolRankConfig` object, and an optional `SymbolGraph.SubGraph`. The class contains methods such as `exact_search`, `filter_graph`, `find_pattern_in_modules`, `process_query`, `retrieve_source_code_by_symbol`, `shifted_z_score_sq`, `symbol_rank_search`, and `symbol_references` to perform various search operations.\n\nThe class uses a symbol similarity algorithm to rank symbols based on their relevance to the input query and a SymbolRank algorithm to compute a global ranking of symbols in the codebase. It provides search results in different formats depending on the search type specified in the query.\n\n## Related Symbols\n\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.graph.SymbolGraph`\n- `automata.core.symbol.parser.parse_symbol`\n- `automata.core.symbol.symbol_utils.convert_to_fst_object`\n- `automata.core.embedding.symbol_similarity.SymbolSimilarity`\n- `automata.core.symbol.search.rank.SymbolRank`\n\n## Example\n\nThe following example demonstrates how to use `SymbolSearch` to process a query and retrieve the search results.\n\n```python\nfrom automata.core.symbol.graph import SymbolGraph\nfrom automata.core.embedding.symbol_similarity import SymbolSimilarity\nfrom automata.core.symbol.search.symbol_search import SymbolSearch\n\n# Initialize necessary objects\nsymbol_graph = SymbolGraph()\nsymbol_similarity = SymbolSimilarity()\n\n# Create the SymbolSearch object\nsymbol_searcher = SymbolSearch(symbol_graph, symbol_similarity)\n\n# Process a query and get the search results\nquery = \"type:symbol_references <symbol_uri>\"\nresult = symbol_searcher.process_query(query)\n```\n\n## Limitations\n\n`SymbolSearch` relies on the availability of symbols in the `SymbolGraph` and the `SymbolSimilarity` object. If either of these objects doesn't have the necessary data, the search results might be incomplete or incorrect. Moreover, the class assumes a specific format for NLP-formatted queries and raises errors if the input query does not follow the expected format.\n\n## Follow-up Questions:\n\n- How can we improve the search performance of the `SymbolSearch` class?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 198}, false, {"py/b64": "AAAAgPVThb8AAACg6lSAPwAAAMAFX4m/AAAAgO5sor8AAAAgtXp/vwAAAMC/kp0/AAAAgFKwbb8AAAAgKghnPwAAAIBAypW/AAAAYOJgl78AAABArLh4PwAAAABnsGG/AAAAIH9NdL8AAACgkidZvwAAAAAbj5U/AAAAAD/WiL8AAABgBf2OPwAAAEBufou/AAAAIHV+dz8AAACAgXFpPwAAAIAXXnq/AAAAIJgaf78AAADAb3JYvwAAAKAiv4m/AAAAAPdHkr8AAABgbU6TPwAAAEDGMI8/AAAAgM/Po78AAADACgmOvwAAAICsn18/AAAAwNKehD8AAABgLxSWvwAAAGCa0qC/AAAAwEhDaz8AAAAgcNSCvwAAAIDtwXY/AAAAIK4OcD8AAAAAK7OSvwAAAMCOD5c/AAAAoB7AkL8AAAAgmcVqPwAAAIBhKU8/AAAAoOwWm78AAABA5c19vwAAAKATRoi/AAAAIP2Deb8AAADgAvKSvwAAACDnI5W/AAAAID4rjT8AAADgwc+bPwAAACCYGn8/AAAAYM2SlT8AAAAgHcyjvwAAAKC0rIE/AAAAgG+LcT8AAAAA4DxSPwAAACByEaE/AAAA4KwBWj8AAAAAaXJ8vwAAACAsRTU/AAAAoAxfhb8AAADgQCyQvwAAAOApIZC/AAAAYAmQlL8AAAAgNNdzvwAAAGBwu5m/AAAAYPaDjb8AAAAAZ7CRPwAAAEARIoO/AAAAgMRVez8AAABAESKTPwAAAKC9Va8/AAAAgB/weL8AAABA0P+LPwAAAGD5a5c/AAAAQBm0kb8AAACAb4uRvwAAACDFGWA/AAAAgIaWgT8AAABgghyFPwAAAOApIUA/AAAAIFsGgb8AAACAq4iAvwAAAIAKIpc/AAAAQND/S78AAACA1raWPwAAAEBSyZY/AAAAoPeQoz8AAACAziSIvwAAAMDwkJe/AAAAQDoTqz8AAABAYUKYPwAAACC1ep8/AAAA4Oo7h78AAAAAAZx7vwAAAEBfBVo/AAAAAJpwlr8AAAAAw2GePwAAAGADO4Q/AAAAYEvJmr8AAADAzguPvwAAAKCZDnw/AAAAwDgffr8AAAAgjsZ1PwAAAMBj4aC/AAAAYOVIgb8AAAAgDaiWvwAAAGDI6IC/AAAAwLU+dD8AAABA+hZDvwAAAMAQ2aG/AAAAYMBWkj8AAAAgAGxDPwAAAEBhQpi/AAAA4GwFkj8AAACAb4uRvwAAAKBZEqQ/AAAAgJtkg78AAABAufSLvwAAAEAjCJu/AAAAAJ1YkD8AAACA9v6APwAAAGChuYM/AAAAIImhnb8AAABA8y+QPwAAAEDtX2w/AAAAYEx0lr8AAABgbU6TvwAAACCoPpy/AAAAgHFNnL8AAAAg45BvvwAAAMD7j5w/AAAAIAbBYz8AAACALmmaPwAAAMDhF5a/AAAAYD84oz8AAADg/CGfvwAAAGCzn3s/AAAAQF5afr8AAACg/yKivwAAAMAcaok/AAAAQE0foj8AAAAAnxqLvwAAACBqf5K/AAAAoKwao78AAAAglBuWPwAAAOBV+nE/AAAAQLn0ez8AAAAgw9xhPwAAAMCtrJW/AAAAANLanz8AAADAPLKDvwAAAIDLPE6/AAAAgKAOeL8AAAAgpnyBPwAAAEDMAIO/AAAAYJJAgr8AAACAFrOePwAAAEAT5H2/AAAAwEOZlr8AAAAAbpeEvwAAAIBhKZ8/AAAAYHXggb8AAACA+MCLPwAAAGB9cmC/AAAAQINMjT8AAACgCMyfPwAAAOAG8Xu/AAAAQBGnn78AAAAAkt6HvwAAAADNMHu/AAAA4FX6gb8AAACg3PKdvwAAAADDYY6/AAAA4OKpaL8AAADA83iRvwAAAEBp1KY/AAAAgF9nhD8AAADAVX+OvwAAAAA/1oi/AAAA4Joboj8AAACgdceYvwAAAMA+76E/AAAAoNzyjT8AAAAgiaGNvwAAAAA87n6/AAAA4OWRkj8AAABAWbB5vwAAAGAqaoE/AAAAgFx/Wj8AAAAAZ7CBPwAAAGAqaqE/AAAAwIzSiD8AAABglH2AvwAAAEACqeG/AAAAAOjOkL8AAAAABISFvwAAAIBBdaG/AAAAAJ8amz8AAADAxyR8vwAAAKDq2Xy/AAAAQKcOlD8AAACgRMl+vwAAAMDKDKY/AAAAYB2zmr8AAADAZaNrvwAAAMAdFZW/AAAAoLSsoT8AAABg7C90vwAAAEAT5J2/AAAAQE/hnD8AAADAOweYvwAAAAD1CpQ/AAAA4LGrTj8AAABAZCqSvwAAAMBfTns/AAAAAIWilL8AAADgYYuJPwAAAMB/loW/AAAAIJNwmj8AAAAgU3SCPwAAAABkyKe/AAAAAKQ/kz8AAACgenGNPwAAAKABYKC/AAAAIAPZmT8AAAAgJyCdPwAAAEAM/Uq/AAAAYGsRpT8AAAAgagQfPwAAAMAZgn+/AAAAoEqZoj8AAAAApgGOPwAAAEAHU5Y/AAAAwAC1pL8AAACA/eWDvwAAAIAhLXc/AAAAgIRZgz8AAADgNbKXPwAAACDFGYA/AAAAgEDKhT8AAABgffeMPwAAAGCb6Y+/AAAAAPzxlr8AAABA4COZPwAAAGBB+l2/AAAAIL2HoT8AAABgqUuSPwAAAOCIuqY/AAAAwDE4ez8AAACgc4qaPwAAAICM66G/AAAAYFZDc78AAADAALV0PwAAACCWWJQ/AAAA4L5ihT8AAADAzEmEPwAAAADdVJi/AAAAAMZJiL8AAADga1qmPwAAAOBz7IQ/AAAAwMxJlL8AAACgnPaFvwAAAMB/lnW/AAAAYOVIoT8AAABg6UeaPwAAAKDqVFA/AAAAwNmFlz8AAAAAIDlavwAAAEDq8pU/AAAAQEKlqT8AAABA+NlkPwAAACBqBG+/AAAAYFvtlz8AAACArUqbPwAAAOARa3S/AAAAIOOQn78AAADA6+aCvwAAAMDra58/AAAAwBotm78AAABADP2avwAAAMA5ypm/AAAAYHXgkT8AAAAgxRlgvwAAAMD5zXG/AAAA4HSXoD8AAACgNcugvwAAAGDKqqu/AAAAQOMLY78AAADA3G2RPwAAACBYHoe/AAAAALRjcD8AAACAjq2cPwAAAKAIzI+/AAAAoCWnkz8AAAAgWwahvwAAAICsn2+/AAAAgFiAQb8AAACAm2RzPwAAAAA6LIQ/AAAAIGoEf78AAABgfzSLPwAAAMBTvZM/AAAAIFU2jb8AAACA0QxSvwAAAIDRDKK/AAAAwAVfeb8AAADgxvRzPwAAAGCb6Y8/AAAAgNmeoL8AAABAiRyhPwAAAACGTYC/AAAAAFuLfb8AAACAOeOSvwAAAGDX5j4/AAAAAIWilL8AAACAb4uBvwAAAIBso4e/AAAAgD6Nlz8AAADAxWKRPwAAAAAJLoq/AAAAAFuLjb8AAACg4IWTvwAAAKBOmHs/AAAAIC3woD8AAAAAIyGUvwAAAACmAW4/AAAA4KdXZT8AAADgmN5jPwAAAEDbeYS/AAAAYG1Okz8AAADgoq2QvwAAACDFnoy/AAAA4P5ejb8AAABgffd8vwAAAEBhQni/AAAAwNxtcT8AAADAM3WJvwAAAOAC8oK/AAAAQFpbVb8AAADAzEmEvwAAAODQSI0/AAAAgDFRlL8AAAAgd7t1vwAAAGA8UJm/AAAAYH1ykD8AAADAGGugvwAAAOBXvKw/AAAAQFWxoL8AAADAZaObvwAAAEDzL6C/AAAAYFQGdb8AAADAf5aFvwAAAOCF0oy/AAAAoPw6mD8AAAAgInaYPwAAAIA4OJe/AAAAAESAbT8AAADAHGqJvwAAAEDQ/4u/AAAAgJDqir8AAADA9uWnPwAAAKCVD3O/AAAAIJytpL8AAADA62t/vwAAAIB+BJO/AAAAANOFWz8AAACAoA6YPwAAAGAJkJQ/AAAAIHTTKz8AAABAYu2TvwAAAOD8IY8/AAAAgLJvgz8AAACAfomPvwAAAMD25Yc/AAAAoA6cgz8AAABgUHOfvwAAAMDR85i/AAAAABw6oT8AAABgbdNvPwAAAEBxZpU/AAAA4JKJgz8AAABAVbFwvwAAAOD6X5Q/AAAAQGbsTL8AAACAHIOCPwAAAGA3pqS/AAAAAKTEjz8AAAAgo5RnPwAAAADgPKI/AAAA4E1ok78AAABAhjSHPwAAAEB+omg/AAAAQPMvkD8AAAAgUTeUPwAAAKCauYc/AAAAQJADdL8AAADgSdVdPwAAAIBNBom/AAAAAA5Tgr8AAAAAkt6HPwAAAOBHE5O/AAAA4Lk9jT8AAAAg+0abPwAAAEAcIZg/AAAAoBYugj8AAAAA0Bg1PwAAAGCCHHU/AAAAgC5pmj8AAACApbh8PwAAAOCPoYk/AAAAIGCwdT8AAADAGYKPvwAAAKAtOZI/AAAAwOmphD8AAABA6LWHPwAAAKC4q5o/AAAAQOAjib8AAABAF3eTPwAAAIBlvKQ/AAAAoEREoj8AAABgiq6DPwAAAIDtwYa/AAAAwDsHmL8AAADgVfqBPwAAAECxYn2/AAAAoAu0ib8AAACAWICBvwAAAEDLVac/AAAAYJJAoj8AAAAAfruhPwAAAGCMcI6/AAAAQAo7kD8AAACgqTKJvwAAAAB705e/AAAAINk8Zr8AAACAIS2HPwAAAMBk+H+/AAAAADUHfD8AAABADP2KvwAAAAAUqKI/AAAAAO+1kz8AAACgvgBrvwAAAMCHKIQ/AAAA4LGrnr8AAABgNL5qPwAAACDkO5s/AAAAAMtugD8AAAAA7XiVPwAAACDcJJA/AAAAwNxtkT8AAACAF16aPwAAAGDNkmU/AAAAAGYFdj8AAAAA9QqUPwAAAEBi7XM/AAAAYNI8mj8AAACAJteLPwAAAKBjZn0/AAAAIJZYlL8AAAAgmBp/vwAAAOB5QYW/AAAAAPkJbb8AAADAH1KDPwAAAAD3R5K/AAAAQNZUnL8AAAAA9Qo0vwAAACAymnW/AAAAwFhnqD8AAADA/cyavwAAAAA475U/AAAAYJJAkj8AAACglQ+TPwAAAKDTSZC/AAAAIOOQj78AAABAONaMvwAAAKA6dZU/AAAAIHDUoj8AAABAjRuKvwAAAGBJB4C/AAAAIFE3lL8AAAAAFuWAPwAAAEDlzX0/AAAAYIIclT8AAACA6JyOPwAAAEAfCZI/AAAAgIaWkb8AAACgKlGIvwAAAMBlo3u/AAAA4AecZ78AAADANl2TPwAAAMAn5HG/AAAAIFbhiL8AAACAxpKZPwAAACCPcZE/AAAAYGsRlT8AAAAgS+KTvwAAAOB0l3A/AAAAYFBzrz8AAACAqt1EPwAAAOAqOI+/AAAAgGyjl78AAACAgMZ9vwAAACBvKZe/AAAAADNFgT8AAACgn2OMPwAAACALa5i/AAAAQNGqZz8AAACA9VOVPwAAAAAW5YA/AAAAIMIxlj8AAACgRgadPwAAAGALzXI/AAAAgLJvoz8AAADAJ+SRvwAAAMAYa6C/AAAAgCm/Vb8AAACAApCYPwAAACBJpaU/AAAAICoIpz8AAABANWl2vwAAAEDgI2m/AAAAYOJgZz8AAABADP2KPwAAAMBDmZa/AAAA4HSXoL8AAACAdDWGPwAAAMDcbYE/AAAA4E1ok78AAAAgeihMPwAAAKAEzYa/AAAAIC3wML8AAAAgaEKEPwAAAABcNok/AAAAIMIxpr8AAABgTHR2PwAAAKBSK5E/AAAAoMMlUz8AAAAAR2iXPwAAAGDVJIS/AAAAYLqGjr8AAADgV7xsPwAAAGCa0lC/AAAAgOPymb8AAAAgt7eNPwAAAMB/loU/AAAAAHYpg78AAABgW+2nvwAAAACs0ZG/AAAAAJXGgT8AAABAnT9XPwAAACASUos/AAAAgP3lk78AAACA9VOlPwAAACDpYKM/AAAAAN1UiD8AAACg00mQPwAAAOAC8oK/AAAAgGLUmj8AAADAeuyAPwAAAGCx3YA/AAAAwIHTcz8AAACAyf9vPwAAAKAJd3u/AAAAAIZNcL8AAACAF14KvwAAAOAG8Uu/AAAAIG8pRz8AAABAQqWJvwAAAEA4UaC/AAAAwIRAmr8AAAAAy26QPwAAACBqf1K/AAAA4LbQdj8AAAAAl4hsPwAAAGDDw1g/AAAAIKZ8cb8AAACAqKCmvwAAAOBc4XS/AAAAwKrEi78AAAAgVuGYPwAAAECJHHE/AAAAQIDfhr8AAAAgrg6QPwAAAKAWLoI/AAAAwOEXdj8AAACgRMmOvwAAAODd/5M/AAAAoM15nD8AAABAiRxxvwAAAMBj4YC/AAAAIC+ym78AAADAM3V5PwAAAKBM1pC/AAAAwIOVjj8AAABglH1gPwAAAOCLooC/AAAAwH7rWT8AAABAoumbvwAAACBJpaW/AAAAoOLCkb8AAADgvmJ1PwAAAMDuUxm/AAAAwFhnmL8AAADAJ+SBPwAAACB4ZnE/AAAAIE2knr8AAACgmrmHPwAAAABKUGE/AAAAoJz2hT8AAABgbxCevwAAAOC5PY2/AAAAwBIWgL8AAABgyqqLPwAAAKC9VZ8/AAAAAHjrnT8AAACgswF2PwAAAEBaW5W/AAAAYCSajb8AAABAXlp+vwAAAAAWam2/AAAA4Ey9d78AAABgNL5KvwAAAMB/lpW/AAAAwEaBgD8AAACg7BaLPwAAAMBqyJO/AAAAAPF3bj8AAADgFhWZPwAAAKAnaX4/AAAAIMfber8AAADAdwSXPwAAAMA8spM/AAAAYPlrd78AAABgw8OIvwAAAAC5DaU/AAAAAMkxkj8AAAAAjTSjvwAAAGCu9Xa/AAAAwBmCjz8AAABg4bWbPwAAAMAfUpM/AAAA4Lm4YL8AAAAADlOSPwAAACB1fpe/AAAAwNxtgb8AAACgCMx/vwAAAKCCA1y/AAAAwMckjL8AAACgIIJrPwAAAEBVsaC/AAAAgBdeir8AAAAAK7OSPwAAAKC0rKE/AAAAwB0Vpb8AAABgML+RvwAAAGBmZ5C/AAAAoLw+kD8AAAAA1m11vwAAAIAkFTG/AAAAAKzRgb8AAACgCMx/vwAAAACDZZa/AAAAYMPDmL8AAABgbU5jPwAAACDZPJY/AAAAYN22kj8AAADgKHaUPwAAAGBt03+/AAAAADNFkT8AAACAHIOCvwAAAOCaG4K/AAAAYCVFaT8AAABAmld9vwAAACDmeGk/AAAAwBmCnz8AAACgJaeDPwAAAAAjIaQ/AAAAwPU6nD8AAADAoPUevwAAACAGwXM/AAAAYJvpfz8AAADAasiTPwAAAKCc9oU/AAAAAKnphz8AAACAWkJcPwAAAADRw5C/AAAA4Co4fz8AAAAgmBqPPwAAAABbi42/AAAAwM+2er8AAAAAfruhvwAAAOCsAYo/AAAAoHOKmj8AAABA2JF6PwAAAGDazlg/AAAAAKqUk78AAABATR+ivwAAAKAewGA/AAAAYLHdkD8AAAAgJV5CPwAAAEDUknE/AAAAwPCQp78AAAAgvYehvwAAAKAb2IY/AAAAQGnUdr8AAACAXSqWPwAAAEDRqoc/AAAAYIIclT8AAAAA8Xd+vwAAAIAFeIK/AAAAYA2PfT8AAADglzOYPwAAACA8aaK/AAAAoFYqej8AAAAA2KqjvwAAAEDQ/0s/AAAAYIfGeT8AAAAALXWNvwAAAGBrEaU/AAAAoKwagz8AAADgtJOIPwAAAGBOsZQ/AAAAYMqqiz8AAAAgd7uFPwAAAICyb5O/AAAAQAo7oD8AAABgEHd3vwAAAEB2EHq/AAAAoKGgmr8AAADAz7aqvwAAAGAGqIo/AAAAAJLel78AAABAkAOUPwAAAED0Rn8/AAAAAOXmdj8AAADAVX+OPwAAAKAewKC/AAAAwEaBgL8AAAAgTk96PwAAAOCnV6U/AAAAIMD0R78AAABg9MGSPwAAAGBB+p0/AAAAIEj6Sb8AAACArJ9vPwAAAMC66Hg/AAAAACuzkj8AAADAzEl0vwAAAGDdtpI/AAAAIOJ5oD8AAADAojKdvwAAAEAKO4A/AAAAwAoJLj8AAAAgbeyIvwAAAOAtIIm/AAAAICSzpr8AAABAtzJxvwAAAIDCk6A/AAAAQLINmT8AAADgCoSBvwAAAIB+iU+/AAAAwL+Snb8AAACgJ2mePwAAAIAWs46/AAAAwOEXlj8AAACg6lSQPwAAAMD4IoY/AAAAwDsHaL8AAADgOJqhPwAAAECsuHi/AAAAoBvYpj8AAADgZjV+vwAAAMA+74E/AAAAIEvic78AAADg4qmIvwAAAOAZ/XI/AAAAgDMTPz8AAACAVZiXPwAAAEArmnk/AAAAICcgfb8AAAAgTaR+vwAAAICtSps/AAAAYJGVZr8AAACAJBWRvwAAAOBmNX4/AAAA4HWuPz8AAADAW0+iPwAAAGAGqIq/AAAAYJyUm78AAAAgWwahvwAAAIAkFYG/AAAAIGCwlT8AAACALmlqPwAAAMCHKJS/AAAAoJF8nT8AAADgLSBpvwAAAGA3ppQ/AAAAYDemlD8AAABgR8pxvwAAAGAsLHw/AAAAYETidz8AAACAhFlzPwAAAKDqVIA/AAAA4EeYT78AAACgLTlyPwAAAGBe1ZE/AAAAQGLto78AAABgyqqbvwAAAKAb2Ha/AAAAIMfbej8AAAAgOYGYPwAAAGBB+n2/AAAAIDKapb8AAACgl0xxPwAAAIDm2qM/AAAAIK4OkL8AAACgMKZ4PwAAAMD5zZE/AAAA4AqEoT8AAACAF16avwAAAMB8rmu/AAAAwNKehL8AAAAAhk2gvwAAACBBE5c/AAAAgPVThb8AAAAA0tqfvwAAAOCNZJu/AAAAAPIiir8AAADAFYOWPwAAAGDXYaI/AAAAAJXGIb8AAAAgBsGTPwAAAOC+YoU/AAAAoDCmOL8AAADgEWtUPwAAAEBufns/AAAAYEYflj8AAAAAy26AvwAAAIC6AZK/AAAAYEYflj8AAAAADBaEvwAAAAD6tJg/AAAAQCMIe78AAADg5ZGivwAAAICbZFM/AAAAoExbrb8AAADglEuOvwAAAKCKlZq/AAAAgE0Gib8AAACAxFWLvwAAAADJMVI/AAAAQLINib8AAACgTNaAPwAAAKAWLoK/AAAAgDFRhD8AAAAAy26QvwAAAOCxq44/AAAAYGsRlT8AAADACglePwAAAGCzn2u/AAAA4KwBij8AAADgT6WhvwAAAKDc8p2/AAAAwAVfWT8AAADggxBiPwAAAGDiYIe/AAAAYGpmWT8AAACg4IVDPwAAAGBHyqE/AAAAoPeQkz8AAACA9v6gvwAAAOBXN6C/AAAA4Pd3mr8AAAAgw9yhvwAAAGANj40/AAAA4Ii6hr8AAABAMyyIPwAAAACfGnu/AAAAYJR9gD8AAABAQ1CVvwAAAKCkiJQ/AAAAwLAZnL8AAADgmhuCPwAAAKB4r5K/AAAAgDsggT8AAAAAWclSvwAAAKAMX5U/AAAA4EeYfz8AAACgTNaAPwAAAOA1sme/AAAAIDKadb8AAADg7SNhvwAAAGBTW5k/AAAAwMoMhr8AAAAgUIyoPwAAAECNG5q/AAAAIHe7lb8AAADg6juHvwAAAOAmOZa/AAAAQCFGkD8AAAAAxkmIPwAAAODtI4G/AAAA4IuigL8AAADA3G1BPwAAAGDknZU/AAAAQPXxir8AAABgw8OYvwAAAEA6E5s/AAAA4Ld7kj8AAACg2POEvwAAAIBxTYw/AAAA4E+lkb8AAACADQqRvwAAAADqkHu/AAAAgItANr8AAABg33iNPwAAAEA9+4S/AAAAgKP2gT8AAACgmrmnPwAAAECA34Y/AAAAAFSkWr8AAAAgfGWavwAAAGBRHnu/AAAAANZtdT8AAACAxz11vwAAACDFGZC/AAAAoG01mr8AAACAtxloPwAAAOApIaC/AAAAgFKwjT8AAABgiq6TPwAAAECGNIe/AAAAAFSker8AAAAApgGOvwAAAKAy46a/AAAA4PpflD8AAACgOnWFvwAAAADgPJK/AAAAoJ9jjD8AAADgcARrvwAAAADvtXO/AAAAYLHdkL8AAAAgCP6BvwAAAIACkJi/AAAAAFeMZL8AAADgn8WWPwAAAICDrpe/AAAAQDVpZr8AAAAAWcmivwAAAGCMcH4/AAAAAEUrmT8AAADgubigvwAAAKBJ7oa/AAAAoN/axz8AAAAglliEPwAAAADLbpA/AAAAwLromD8AAAAgMpqFvwAAACAnm6C/AAAAgA0KkT8AAABAXJiTPwAAAAAZUpe/AAAAwBKbnL8AAACgcB1kPwAAAOARa4Q/AAAAQMYwn78AAACgKlF4PwAAAGB6ioY/AAAAoJq5h78AAADgAvKivwAAAKCpMqm/AAAAYN/zkL8AAADgIY+BvwAAAKAiv4k/AAAAIDxpUj8AAADgjWSLvwAAAGBgl4y/AAAAQNPnhT8AAADgu3qLvwAAACCE94i/AAAA4NvChb8AAADgda6fPwAAAGCzn5s/AAAAgKAOmL8AAAAAmnCWPwAAAEAjCJs/AAAAgGQReb8AAAAg+YRwPwAAAOBJ1V2/AAAAICJ2iD8AAADAENlxPwAAAEDgI4m/AAAA4N/Bjj8AAACAwpOQvwAAAKD0qJm/AAAAoHsceb8AAACgwyWTvwAAAEDWVJw/AAAAAA7Yjr8AAAAgWB6XvwAAAOBz7FS/AAAA4NvCdT8AAADgsauePwAAAACAfay/AAAAYKG5c78AAAAg35GGPwAAAMCR93A/AAAAgObac78AAAAAyIaGvwAAAIDRDHI/AAAAgMn/j78AAADA0p6UPwAAAOBmNW4/AAAAgPjAm78AAABgKC1zvwAAAEBufps/AAAAIB3Mkz8AAADAYPmGvwAAAGB993w/AAAA4CWOar8AAABgkkCSPwAAACBYHpc/AAAAQKnQjj8AAACAdx2QvwAAAKCXTJG/AAAAIBJSm78AAABgVkOjvwAAAIAZm3i/AAAAgEM3jL8AAABAXlqePwAAAEC3MpE/AAAAoPw6iD8AAABAQGibPwAAAMAU2Gq/AAAAAJXGoT8AAACABXhyPwAAAACXiIw/AAAAwIOVfj8AAACgct9+PwAAAMBoi5U/AAAAYFNbib8AAABgkkCCPwAAAGD+FXw/AAAAQNGqh78AAADAQLF8PwAAAMAxOIu/AAAAQJiVkj8AAACAoA5oPwAAACDSVUM/AAAA4HlBpT8AAAAgtfWSPwAAAMD5zaG/AAAAYH80m78AAACAWkKMvwAAAOBkc7M/AAAAQCHLjD8AAACgct+ePwAAAMD7j2y/AAAAIFN0Uj8AAADA7lOJvwAAACD7Rou/AAAAwH+Wlb8AAAAAg2VmvwAAAKCAQZE/AAAAgFDukr8AAADg28KVPwAAAEAhRoA/AAAAIFU2bb8AAAAAfRCGPwAAAGCKrnM/AAAAgIOuNz8AAACgl0xxPwAAAGADO4Q/AAAAYCVFib8AAAAAP9aYPwAAAGAwv4G/AAAAoGGkoj8AAADA3G2hvwAAAKBGBn2/AAAAgFKwnb8AAADAxWKBvwAAAKAlp5O/AAAAYJJAor8AAADACEeTPwAAAECIcaW/AAAAQDhRgD8AAACgR7F4vwAAAED18Xo/AAAAYLjEo78AAABAgYqivwAAAEA1aXa/AAAAQGnUlr8AAADgGf2CvwAAAGCpS4I/AAAAAC11jT8AAAAgTaSOvwAAAMCEQJo/AAAA4IMQUr8AAAAgbylXvwAAAAA/1pi/AAAAoIqVmj8AAACgK/yTvwAAAOA4mnG/AAAAAESAXT8AAADAGGuAvwAAACD9g5k/AAAAQBGnn78AAABg0jx6PwAAAODQSK2/AAAAIJytlL8AAADgsSaivwAAAMCB04M/AAAAILe3bT8AAACggEGxvwAAAOAKhGE/AAAA4L8Ncb8AAABglH2APwAAACDD3EE/AAAAQNiRir8AAADgiLrGvwAAACBE+5A/AAAAIC3woD8AAABAg8egvwAAAAAtdV0/AAAAIAIubj8AAABA75yaPwAAAIAzjpK/AAAAAF8ek78AAABA23lkPwAAAAAUqJI/AAAAoBjwbD8AAACgcB2kvwAAAKDv/qS/AAAAwCyOlr8AAADAfuuJvwAAAEDvnHo/AAAA4LGrjr8AAACgvgCbPwAAAAB4650/AAAAAFeMlD8AAABAMyyovwAAAOBuQnA/AAAAoJz2pT8AAABATR9iPwAAACB003s/AAAAwM+2ir8AAADgBvGLPwAAAIDPz5M/AAAAQKXRpb8AAABAtzJBvwAAAIBQ7oI/AAAA4O/li78AAAAg2ueBvwAAAED/wIe/AAAAIFE3hD8AAABgEHd3vwAAAMB+65m/AAAAAOL+nL8AAADgGf2CPwAAAGCRlZY/AAAAgBEJij8AAACgVO2LPwAAAKAWLoK/AAAAoFkSlL8AAABgBf1+PwAAACAFFpg/AAAAoK7cnb8AAACgjz9/PwAAAMCHKHQ/AAAAABSokj8AAACgNcuAvwAAAKCpMok/AAAAYIfGib8AAABAtEqXPwAAAICdJn4/AAAAgB5FjT8AAABA8EdWPwAAAOB2WYs/AAAAAA7YXj8AAACglGSXvwAAAIDJ/5+/AAAAAMNhfj8AAAAAuQ2VvwAAAOC3e4K/AAAAILDQmr8AAADAgdOTvwAAAECDx1A/AAAAAINllr8AAABgtoeVvwAAAOBUT2a/AAAA4LEmoj8AAAAg1/9nvwAAAIDHPYU/AAAAwIZ9eD8AAADARoGgPwAAAGBvEH6/AAAAAA5Tcj8AAADA6+ZyvwAAAACs0YG/AAAAQLRKh78AAABAzj2xPwAAAGBgl3w/AAAAwPsKYL8AAACgAyKbPwAAAKDnbEY/AAAAIJcDgD8AAABgaxGlvwAAAKCCA4y/AAAAQOudgb8AAADgvmKVPwAAAADNMJs/AAAA4P5efb8AAAAA/PGWPwAAACC9h0G/AAAAYPTBgj8AAABAYu2DvwAAAADRw3C/AAAAQGbsfL8AAADAQLGcvwAAAIBBdZE/AAAAwObBej8AAADAOcqpvwAAAMAFX2m/AAAAQGLtkz8AAAAgQROHPwAAAOBwBJu/AAAA4ALygj8AAAAA1m2FPwAAAIBfZ2S/AAAAYEYfpr8AAADgYYuJPwAAAKA/H5o/AAAAAOXmlj8AAABg5J2lvwAAAIBhKZ8/AAAAQEWNkz8AAABAMESevwAAAMC90KI/AAAAANHDgL8AAADgda6vPwAAAADQGIW/AAAA4FRPhj8AAADgxLd1vwAAAICtSns/AAAAYH33bL8AAABgc6OzvwAAACCRM3y/AAAAgMzneT8AAABAAqmRPwAAACA016O/AAAAoOUveL8AAABAAqmRvwAAAGC7MWq/AAAAQJpXnb8AAACgIr+ZPwAAACChV3k/AAAAABblkL8AAABAWbCZvwAAAOCaG5K/AAAAYA46eb8AAADg8s2FPwAAAGAoLZO/AAAAIPaclr8AAADg8s1FPwAAAMDFYpE/AAAAIPaclj8AAABgR8qRPwAAAIDubGK/AAAAYNI8ej8AAACA3kh1PwAAAIBkEUm/AAAAwBxqib8AAABAESJzvwAAAGBvEI4/AAAAQBGnnz8AAACgj7qCPwAAACDSVYO/AAAAwGWjWz8AAADAjNKYvwAAAKBhpII/AAAA4EqAWT8AAADg7SOBvwAAAMAZgo+/AAAAIDxpoj8AAABgqw2NvwAAAADQGHU/AAAAAOXmdr8AAACgtKyRPwAAAIAU8XM/AAAAADzunr8AAAAAeOt9PwAAAMByWpK/AAAAoKkymT8AAADAPLJzPwAAAIBgEpC/AAAAgMRVe78AAADgubiQvwAAAEAbdpy/AAAAwBhroL8AAAAg45CfPwAAACBgsGU/AAAAIE2kbr8AAADA62tfPwAAAAA474W/AAAAYGZnkD8AAABA7V+MvwAAAKDv/oQ/AAAA4K/pk78AAABAadR2vwAAAOAbv30/AAAAgCm/lT8AAAAg0lWjvwAAAGBJB3A/AAAA4EnVbT8AAADAPLKTvwAAACDKw6S/AAAAQPRGnz8AAACguVaGvwAAAKAB5Yw/AAAAAA7Ybj8AAACA4/KZPwAAAICvhyk/AAAAIGoEn78AAACA6JxuvwAAAADO23a/AAAAoCdpjr8AAACA22CLvwAAAMDra28/AAAAQD6moL8AAABgwhiNvwAAAMCyVjo/AAAAwPblhz8AAADgZjV+PwAAAAB9EKY/AAAA4PpfpL8AAAAguGKJPwAAACDUF44/AAAAoEIHpD8AAABAHwlyvwAAAMCeM3Q/AAAAoMA9ib8AAABAdhCKvwAAACAa5Hm/AAAAYN/zgL8AAACg52yWPwAAAACp6ae/AAAA4FRPlr8AAADANl2zvwAAAIDwLo0/AAAAIGCwhT8AAADA6+aSvwAAAADteHU/AAAA4LGrrr8AAAAg8fKBPwAAAEDvnIo/AAAAAKQ/gz8AAADg4GxqvwAAAGDSPKq/AAAAwNmFh78AAAAAhk2AvwAAAEC3MoG/AAAAoHscmb8AAADgIOSFvwAAAMDMSZQ/AAAAoMu3kb8AAADAo92oPwAAACBQjJg/AAAA4Fc3cL8AAADAW09yvwAAAODlkZI/AAAAIET7oD8AAABA6vKVvwAAAOCPoZm/AAAA4Fc3kL8AAADg6P6IPwAAAKBERJK/AAAAoOdslr8AAADg38F+PwAAAMDzeJG/AAAAgJPSdL8AAABA1lScPwAAAGATX5E/AAAAIAUWiL8AAABgBqiaPwAAAECNG3q/AAAAYLXciT8AAAAgmBqfPwAAAMCWoZW/AAAAYJknlb8AAABgyOiAPwAAACCTcIq/AAAAwPnNob8AAACApTOQvwAAAGAgm4Q/AAAAQNPnhT8AAADg7SNhPwAAAIBSsG0/AAAAgNa2lj8AAACgB7VwPwAAAMDR83i/AAAA4Fn5qr8AAADgWfmKPwAAAICyb4O/AAAA4CDklT8AAAAA1m2VPwAAAICyb3O/AAAAgDg4d78AAADgVfqhPwAAAIAzjpI/AAAAgFiAgT8AAADgJjmWvwAAAGAoLaM/AAAAYC8Ulr8AAABAXwWqvwAAAECQA2S/AAAAgAV4kj8AAADgeUGFvwAAACCmfJG/AAAAoLlWRj8AAACgRESSPwAAAAA3REq/AAAA4HlBZb8AAACA7cGGvwAAAMAvdpC/AAAAQNSScT8AAADgZHOTvwAAACDmeGk/AAAAwMxJlD8AAACADQqRvwAAAMAsjoY/AAAAIHIRgT8AAACgDpyjPwAAAODqOxc/AAAAoJInmb8AAABAZCqSvwAAAOA6XGy/AAAAYEx0lr8AAADgRdZ0PwAAAIB533o/AAAAYF7VYb8AAADAasiDPwAAAOC/DZE/AAAAIE5PWj8AAAAArpOcvwAAAICluHy/AAAAYDemlD8AAAAgbEGNPwAAAADgPJK/AAAAYLXcib8AAAAgAPF/vwAAAAAcOpG/AAAAYF7Vob8AAABAadR2PwAAAKC8PpC/AAAAQBd3k78AAAAAG491PwAAAOC5PV0/AAAAIO4KiD8AAADgtJOYvwAAACBNpH6/AAAAoOgXcj8AAABACjtwPwAAAOBpHZi/AAAAIADxj78AAABAFI95vwAAAOCIupa/AAAAoPlSjj8AAACgbTV6vwAAAEBeWo6/AAAAQIY0pz8AAADAeuyAPwAAAIBSsG0/AAAAoOCFgz8AAADAZ+CJPwAAAOCxJpK/AAAAYBNfYT8AAAAA04WLvwAAAGDknYW/AAAA4C7LZL8AAACAMxOfvwAAACDfkXa/AAAAoOLCkb8AAAAAXx6jvwAAAEAzLHi/AAAAQMhtnb8AAABglj87PwAAAEDLVbc/AAAAoDXLoD8AAACAZBGJPwAAAKCfY0y/AAAAINyprL8AAACA4/KZPwAAAICq3ZQ/AAAAYDKBbL8AAACgRMmevwAAAKD0qJm/AAAA4FISaL8AAAAAGKebvwAAAACkxH8/AAAAgIkDiL8AAACAFrN+PwAAAAAUqFK/AAAAYHqKlr8AAACgHsBwPwAAAGChuYM/AAAAgM4kaL8AAAAA/9mgPwAAAOB7fpM/AAAA4GwFgj8AAADg6P54PwAAAKC9VY8/AAAAYHXgcT8AAACAwpOQPwAAAKC9VY+/AAAAIBCQkD8AAADAasijvwAAAAABnJs/AAAAgIRZcz8AAADg/wmpvwAAACAVOpW/AAAAgKJLlj8AAAAgJ5uAPwAAAABbi32/AAAAQOudcT8AAACgSe6mPwAAAKB4r5I/AAAAYOSddT8AAAAAMF2XPwAAAICgDmi/AAAAgPr9mb8AAABAwYaavwAAAGCZJ5U/AAAAAPzxZr8AAADgNbKXvwAAAICOray/"}]}]}, "source_code": "class SymbolSearch:\n    \"\"\"Searches for symbols in a SymbolGraph\"\"\"\n\n    def __init__(\n        self,\n        symbol_graph: SymbolGraph,\n        symbol_similarity: SymbolSimilarity,\n        symbol_rank_config: Optional[SymbolRankConfig],\n        code_subgraph: Optional[SymbolGraph.SubGraph] = None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Args:\n            symbol_graph (SymbolGraph): A SymbolGraph\n            symbol_similarity (SymbolSimilarity): A SymbolSimilarity object\n            symbol_rank_config (Optional[SymbolRankConfig]): A SymbolRankConfig object\n            code_subgraph (Optional[SymbolGraph.SubGraph]): A subgraph of the SymbolGraph\n        \"\"\"\n\n        if not code_subgraph:\n            code_subgraph = symbol_graph.get_rankable_symbol_subgraph(\n                kwargs.get(\"flow_rank\", \"bidirectional\")\n            )\n        else:\n            if not code_subgraph.parent == symbol_graph:\n                raise ValueError(\"code_subgraph must be a subgraph of symbol_graph\")\n\n        graph_symbols = symbol_graph.get_all_available_symbols()\n        embedding_symbols = symbol_similarity.embedding_handler.get_all_supported_symbols()\n        available_symbols = set(graph_symbols).intersection(set(embedding_symbols))\n        SymbolSearch.filter_graph(code_subgraph.graph, available_symbols)\n\n        # TODO - Do we need to filter the SymbolGraph as well?\n        self.symbol_graph = symbol_graph\n        self.symbol_similarity = symbol_similarity\n        symbol_similarity.set_available_symbols(available_symbols)\n        self.symbol_rank = SymbolRank(code_subgraph.graph, config=symbol_rank_config)\n\n    def symbol_rank_search(self, query: str) -> SymbolRankResult:\n        \"\"\"\n        Fetches the list of the SymbolRank similar symbols ordered by rank\n\n        Args:\n            query (str): The query to search for\n\n        Returns:\n            A list of tuples of the form (symbol_uri, rank)\n        \"\"\"\n        query_vec = self.symbol_similarity.get_query_similarity_dict(query)\n        transformed_query_vec = SymbolSearch.transform_dict_values(\n            query_vec, SymbolSearch.shifted_z_score_sq\n        )\n        ranks = self.symbol_rank.get_ranks(query_to_symbol_similarity=transformed_query_vec)\n        return ranks\n\n    def symbol_references(self, symbol_uri: str) -> SymbolReferencesResult:\n        \"\"\"\n        Gets the list a symbol-based search\n\n        Args:\n            symbol_uri (str): The symbol to search for\n\n        Returns:\n            A dict of paths to files that contain the\n                symbol and corresponding line numbers\n        \"\"\"\n        # TODO - Add parsing upstream or here to parse references\n        return self.symbol_graph.get_references_to_symbol(parse_symbol(symbol_uri))\n\n    def retrieve_source_code_by_symbol(self, symbol_uri: str) -> SourceCodeResult:\n        \"\"\"\n        Finds the raw text of a module, class, method, or standalone function\n\n        Args:\n            symbol_uri (str): The symbol to retrieve\n\n        Returns:\n            The raw text of the symbol or None if not found\n        \"\"\"\n        node = convert_to_fst_object(parse_symbol(symbol_uri))\n        return str(node) if node else None\n\n    def exact_search(self, pattern: str) -> ExactSearchResult:\n        \"\"\"\n        Performs a exact search across the indexed codebase\n\n        Args:\n            pattern (str): The pattern to search for\n\n        Returns:\n            A dict of paths to files that contain the pattern and corresponding line numbers\n        \"\"\"\n        return SymbolSearch.find_pattern_in_modules(pattern)\n\n    def process_query(\n        self, query: str\n    ) -> Union[SymbolReferencesResult, SymbolRankResult, SourceCodeResult, ExactSearchResult,]:\n        \"\"\"\n        Processes an NLP-formatted query and return the results of the appropriate search\n\n        Args:\n            query: The query to process\n\n        Returns:\n            The results of the search\n        \"\"\"\n        parts = query.split()\n        if len(parts) < 2:\n            raise ValueError(\n                \"Invalid NLP query. It must have at least two parts: 'type:...' and 'query...'\"\n            )\n\n        search_type = parts[0][len(\"type:\") :].lower()\n        query_remainder = \" \".join(parts[1:])\n\n        if search_type == \"symbol_references\":\n            return self.symbol_references(query_remainder)\n        elif search_type == \"symbol_rank\":\n            return self.symbol_rank_search(query_remainder)\n        elif search_type == \"exact\":\n            return self.exact_search(query_remainder)\n        elif search_type == \"source\":\n            return self.retrieve_source_code_by_symbol(query_remainder)\n        else:\n            raise ValueError(f\"Unknown search type: {search_type}\")\n\n    @staticmethod\n    def filter_graph(graph: nx.DiGraph, available_symbols: Set[Symbol]):\n        \"\"\"\n        Filters a graph to only contain nodes that are in the available_symbols set\n\n        Args:\n            graph: The graph to filter\n            available_symbols: The set of symbols to keep\n        \"\"\"\n        graph_nodes = deepcopy(graph.nodes())\n        for symbol in graph_nodes:\n            if symbol not in available_symbols:\n                graph.remove_node(symbol)\n\n    @staticmethod\n    def shifted_z_score_sq(values: Union[List[float], np.ndarray]) -> np.ndarray:\n        \"\"\"\n        Compute z-score of a list of values\n\n        Args:\n            values: List of values to compute z-score for\n\n        Returns:\n            List of z-scores\n        \"\"\"\n        if not isinstance(values, np.ndarray):\n            values = np.array(values)\n\n        mean = np.mean(values)\n        std_dev = np.std(values)\n        zscores = [(value - mean) / std_dev for value in values]\n        return (zscores - np.min(zscores)) ** 2\n\n    @staticmethod\n    def transform_dict_values(\n        dictionary: Dict[Any, float], func: Callable[[List[float]], np.ndarray]\n    ):\n        \"\"\"\n        Apply a function to each value in a dictionary and return a new dictionary\n\n        Args:\n            dictionary: Dictionary to transform\n            func: Function to apply to each value\n\n        Returns:\n            Dictionary with transformed values\n        \"\"\"\n        # Apply the function to the accumulated values\n        transformed_values = func([dictionary[key] for key in dictionary])\n\n        # Re-distribute the transformed values back into the dictionary\n        transformed_dict = {}\n        for i, key in enumerate(dictionary):\n            transformed_dict[key] = transformed_values[i]\n        return transformed_dict\n\n    @staticmethod\n    def find_pattern_in_modules(pattern: str) -> Dict[str, List[int]]:\n        \"\"\"\n        Finds exact line matches for a given pattern string in all modules\n\n        Args:\n            pattern (str): The pattern string to search for\n\n        Returns:\n            Dict[str, List[int]]: A dictionary with module paths as keys and a list of line numbers as values\n        \"\"\"\n        matches = {}\n        module_map = LazyModuleTreeMap.cached_default()\n        for module_path, module in module_map.items():\n            if module:\n                lines = module.dumps().splitlines()\n                line_numbers = [i + 1 for i, line in enumerate(lines) if pattern in line.strip()]\n                if line_numbers:\n                    matches[module_path] = line_numbers\n        return matches\n", "summary": "`SymbolSearch` is a class that searches for symbols in a `SymbolGraph`, providing methods to process NLP-formatted queries and search for exact matches, symbol references, symbol rankings, and source code retrieval. The class ranks symbols based on their relevance to the query and computes a global ranking of symbols in the codebase using a symbol similarity algorithm and SymbolRank algorithm. The search results are provided in different formats depending on the search type specified in the query. However, `SymbolSearch` relies on the availability of symbols in the `SymbolGraph` and the `SymbolSimilarity` object, with limitations including the potential for incomplete or incorrect results and errors for queries that do not follow the expected format.\n\nExample usage:\n```python\nfrom automata.core.symbol.graph import SymbolGraph\nfrom automata.core.embedding.symbol_similarity import SymbolSimilarity\nfrom automata.core.symbol.search.symbol_search import SymbolSearch\n\n# Initialize necessary objects\nsymbol_graph = SymbolGraph()\nsymbol_similarity = SymbolSimilarity()\n\n# Create the SymbolSearch object\nsymbol_searcher = SymbolSearch(symbol_graph, symbol_similarity)\n\n# Process a query and get the search results\nquery = \"type:symbol_references <symbol_uri>\"\nresult = symbol_searcher.process_query(query)\n```\n", "context": "\n    Generate the documentation for SymbolSearch using the context shown below -\n  Building context for primary symbol - automata.core.symbol.search.symbol_search.SymbolSearch -\n  \n    Import Statements:\n      import networkx as nx\n      import numpy as np\n      from copy import deepcopy\n      from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Union\n      from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n      from automata.core.embedding.symbol_similarity import SymbolSimilarity\n      from automata.core.symbol.graph import SymbolGraph\n      from automata.core.symbol.parser import parse_symbol\n      from automata.core.symbol.search.rank import SymbolRank, SymbolRankConfig\n      from automata.core.symbol.symbol_types import Symbol, SymbolReference\n      from automata.core.symbol.symbol_utils import convert_to_fst_object\n      \n      # SymbolSearch\n      \n      `SymbolSearch` is a class that searches for symbols in a `SymbolGraph`. It provides methods to process NLP-formatted queries and searches for exact matches, symbol references, symbol rankings, and source code retrieval.\n      \n      ## Overview\n      \n      `SymbolSearch` is initialized with a `SymbolGraph`, a `SymbolSimilarity` object, an optional `SymbolRankConfig` object, and an optional `SymbolGraph.SubGraph`. The class contains methods such as `exact_search`, `filter_graph`, `find_pattern_in_modules`, `process_query`, `retrieve_source_code_by_symbol`, `shifted_z_score_sq`, `symbol_rank_search`, and `symbol_references` to perform various search operations.\n      \n      The class uses a symbol similarity algorithm to rank symbols based on their relevance to the input query and a SymbolRank algorithm to compute a global ranking of symbols in the codebase. It provides search results in different formats depending on the search type specified in the query.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.graph.SymbolGraph`\n      - `automata.core.symbol.parser.parse_symbol`\n      - `automata.core.symbol.symbol_utils.convert_to_fst_object`\n      - `automata.core.embedding.symbol_similarity.SymbolSimilarity`\n      - `automata.core.symbol.search.rank.SymbolRank`\n      \n      ## Example\n      \n      The following example demonstrates how to use `SymbolSearch` to process a query and retrieve the search results.\n      \n      ```python\n      from automata.core.symbol.graph import SymbolGraph\n      from automata.core.embedding.symbol_similarity import SymbolSimilarity\n      from automata.core.symbol.search.symbol_search import SymbolSearch\n      \n      # Initialize necessary objects\n      symbol_graph = SymbolGraph()\n      symbol_similarity = SymbolSimilarity()\n      \n      # Create the SymbolSearch object\n      symbol_searcher = SymbolSearch(symbol_graph, symbol_similarity)\n      \n      # Process a query and get the search results\n      query = \"type:symbol_references <symbol_uri>\"\n      result = symbol_searcher.process_query(query)\n      ```\n      \n      ## Limitations\n      \n      `SymbolSearch` relies on the availability of symbols in the `SymbolGraph` and the `SymbolSimilarity` object. If either of these objects doesn't have the necessary data, the search results might be incomplete or incorrect. Moreover, the class assumes a specific format for NLP-formatted queries and raises errors if the input query does not follow the expected format.\n      \n      ## Follow-up Questions:\n      \n      - How can we improve the search performance of the `SymbolSearch` class?\n      \n    Class Docstring:\n      Searches for symbols in a SymbolGraph\n      \n    Methods:\n      def __init__(\n              self,\n              symbol_graph: SymbolGraph,\n              symbol_similarity: SymbolSimilarity,\n              symbol_rank_config: Optional[SymbolRankConfig],\n              code_subgraph: Optional[SymbolGraph.SubGraph] = None,\n              *args,\n              **kwargs,\n          ):\n              \"\"\"\n              Args:\n                  symbol_graph (SymbolGraph): A SymbolGraph\n                  symbol_similarity (SymbolSimilarity): A SymbolSimilarity object\n                  symbol_rank_config (Optional[SymbolRankConfig]): A SymbolRankConfig object\n                  code_subgraph (Optional[SymbolGraph.SubGraph]): A subgraph of the SymbolGraph\n              \"\"\"\n      \n              if not code_subgraph:\n                  code_subgraph = symbol_graph.get_rankable_symbol_subgraph(\n                      kwargs.get(\"flow_rank\", \"bidirectional\")\n                  )\n              else:\n                  if not code_subgraph.parent == symbol_graph:\n                      raise ValueError(\"code_subgraph must be a subgraph of symbol_graph\")\n      \n              graph_symbols = symbol_graph.get_all_available_symbols()\n              embedding_symbols = symbol_similarity.embedding_handler.get_all_supported_symbols()\n              available_symbols = set(graph_symbols).intersection(set(embedding_symbols))\n              SymbolSearch.filter_graph(code_subgraph.graph, available_symbols)\n      \n              # TODO - Do we need to filter the SymbolGraph as well?\n              self.symbol_graph = symbol_graph\n              self.symbol_similarity = symbol_similarity\n              symbol_similarity.set_available_symbols(available_symbols)\n              self.symbol_rank = SymbolRank(code_subgraph.graph, config=symbol_rank_config)\n      \n          \n      def exact_search(self, pattern: str) -> ExactSearchResult:\n              \"\"\"\n              Performs a exact search across the indexed codebase\n      \n              Args:\n                  pattern (str): The pattern to search for\n      \n              Returns:\n                  A dict of paths to files that contain the pattern and corresponding line numbers\n              \"\"\"\n              return SymbolSearch.find_pattern_in_modules(pattern)\n      \n          \n      @staticmethod\n          def filter_graph(graph: nx.DiGraph, available_symbols: Set[Symbol]):\n              \"\"\"\n              Filters a graph to only contain nodes that are in the available_symbols set\n      \n              Args:\n                  graph: The graph to filter\n                  available_symbols: The set of symbols to keep\n              \"\"\"\n              graph_nodes = deepcopy(graph.nodes())\n              for symbol in graph_nodes:\n                  if symbol not in available_symbols:\n                      graph.remove_node(symbol)\n      \n          \n      @staticmethod\n          def find_pattern_in_modules(pattern: str) -> Dict[str, List[int]]:\n              \"\"\"\n              Finds exact line matches for a given pattern string in all modules\n      \n              Args:\n                  pattern (str): The pattern string to search for\n      \n              Returns:\n                  Dict[str, List[int]]: A dictionary with module paths as keys and a list of line numbers as values\n              \"\"\"\n              matches = {}\n              module_map = LazyModuleTreeMap.cached_default()\n              for module_path, module in module_map.items():\n                  if module:\n                      lines = module.dumps().splitlines()\n                      line_numbers = [i + 1 for i, line in enumerate(lines) if pattern in line.strip()]\n                      if line_numbers:\n                          matches[module_path] = line_numbers\n              return matches\n      \n      def process_query(\n              self, query: str\n          ) -> Union[SymbolReferencesResult, SymbolRankResult, SourceCodeResult, ExactSearchResult,]:\n              \"\"\"\n              Processes an NLP-formatted query and return the results of the appropriate search\n      \n              Args:\n                  query: The query to process\n      \n              Returns:\n                  The results of the search\n              \"\"\"\n              parts = query.split()\n              if len(parts) < 2:\n                  raise ValueError(\n                      \"Invalid NLP query. It must have at least two parts: 'type:...' and 'query...'\"\n                  )\n      \n              search_type = parts[0][len(\"type:\") :].lower()\n              query_remainder = \" \".join(parts[1:])\n      \n              if search_type == \"symbol_references\":\n                  return self.symbol_references(query_remainder)\n              elif search_type == \"symbol_rank\":\n                  return self.symbol_rank_search(query_remainder)\n              elif search_type == \"exact\":\n                  return self.exact_search(query_remainder)\n              elif search_type == \"source\":\n                  return self.retrieve_source_code_by_symbol(query_remainder)\n              else:\n                  raise ValueError(f\"Unknown search type: {search_type}\")\n      \n          \n      def retrieve_source_code_by_symbol(self, symbol_uri: str) -> SourceCodeResult:\n              \"\"\"\n              Finds the raw text of a module, class, method, or standalone function\n      \n              Args:\n                  symbol_uri (str): The symbol to retrieve\n      \n              Returns:\n                  The raw text of the symbol or None if not found\n              \"\"\"\n              node = convert_to_fst_object(parse_symbol(symbol_uri))\n              return str(node) if node else None\n      \n          \n      @staticmethod\n          def shifted_z_score_sq(values: Union[List[float], np.ndarray]) -> np.ndarray:\n              \"\"\"\n              Compute z-score of a list of values\n      \n              Args:\n                  values: List of values to compute z-score for\n      \n              Returns:\n                  List of z-scores\n              \"\"\"\n              if not isinstance(values, np.ndarray):\n                  values = np.array(values)\n      \n              mean = np.mean(values)\n              std_dev = np.std(values)\n              zscores = [(value - mean) / std_dev for value in values]\n              return (zscores - np.min(zscores)) ** 2\n      \n          \n      def symbol_rank_search(self, query: str) -> SymbolRankResult:\n              \"\"\"\n              Fetches the list of the SymbolRank similar symbols ordered by rank\n      \n              Args:\n                  query (str): The query to search for\n      \n              Returns:\n                  A list of tuples of the form (symbol_uri, rank)\n              \"\"\"\n              query_vec = self.symbol_similarity.get_query_similarity_dict(query)\n              transformed_query_vec = SymbolSearch.transform_dict_values(\n                  query_vec, SymbolSearch.shifted_z_score_sq\n              )\n              ranks = self.symbol_rank.get_ranks(query_to_symbol_similarity=transformed_query_vec)\n              return ranks\n      \n          \n      def symbol_references(self, symbol_uri: str) -> SymbolReferencesResult:\n              \"\"\"\n              Gets the list a symbol-based search\n      \n              Args:\n                  symbol_uri (str): The symbol to search for\n      \n              Returns:\n                  A dict of paths to files that contain the\n                      symbol and corresponding line numbers\n              \"\"\"\n              # TODO - Add parsing upstream or here to parse references\n              return self.symbol_graph.get_references_to_symbol(parse_symbol(symbol_uri))\n      \n          \n      @staticmethod\n          def transform_dict_values(\n              dictionary: Dict[Any, float], func: Callable[[List[float]], np.ndarray]\n          ):\n              \"\"\"\n              Apply a function to each value in a dictionary and return a new dictionary\n      \n              Args:\n                  dictionary: Dictionary to transform\n                  func: Function to apply to each value\n      \n              Returns:\n                  Dictionary with transformed values\n              \"\"\"\n              # Apply the function to the accumulated values\n              transformed_values = func([dictionary[key] for key in dictionary])\n      \n              # Re-distribute the transformed values back into the dictionary\n              transformed_dict = {}\n              for i, key in enumerate(dictionary):\n                  transformed_dict[key] = transformed_values[i]\n              return transformed_dict\n      \n          \n  Building context for related symbols -\n  \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_symbol_search.test_exact_search\n    \n        def test_exact_search(symbol_searcher):\n            with patch(\n                \"automata.core.symbol.search.symbol_search.SymbolSearch.find_pattern_in_modules\",\n                return_value=[\"file1\", \"file2\"],\n            ):\n                result = symbol_searcher.exact_search(\"pattern1\")\n                assert result == [\"file1\", \"file2\"]\n        \n        \n        \n        \n    automata.tests.unit.conftest.symbol_searcher\n    \n        @pytest.fixture\n        def symbol_searcher(mocker, symbol_graph_mock):\n            symbol_similarity_mock = mocker.MagicMock(spec=SymbolSimilarity)\n            symbol_similarity_mock.embedding_handler = mocker.MagicMock(spec=SymbolCodeEmbeddingHandler)\n            symbol_rank_config_mock = mocker.MagicMock(spec=SymbolRankConfig)\n        \n            return SymbolSearch(\n                symbol_graph_mock,\n                symbol_similarity_mock,\n                symbol_rank_config_mock,\n            )\n        \n        \n    automata.tests.unit.test_symbol_search.test_process_queries\n    \n        def test_process_queries(symbols, symbol_searcher, symbol_graph_mock):\n            with patch.object(\n                symbol_searcher, \"symbol_references\", return_value=[\"ref1\", \"ref2\"]\n            ) as mock_method_0:\n                result = symbol_searcher.process_query(\"type:symbol_references %s\" % symbols[0].uri)\n                assert result == [\"ref1\", \"ref2\"]\n            mock_method_0.assert_called_once_with(symbols[0].uri)\n        \n            with patch.object(symbol_searcher, \"exact_search\", return_value={\"test\": 0}) as mock_method_1:\n                result = symbol_searcher.process_query(\"type:exact %s\" % symbols[0].uri)\n                assert result == {\"test\": 0}\n            mock_method_1.assert_called_once_with(symbols[0].uri)\n        \n            with patch.object(\n                symbol_searcher, \"retrieve_source_code_by_symbol\", return_value=\"test\"\n            ) as mock_method_2:\n                result = symbol_searcher.process_query(\"type:source %s\" % symbols[0].uri)\n                assert result == \"test\"\n            mock_method_2.assert_called_once_with(symbols[0].uri)\n        \n            with patch.object(\n                symbol_searcher, \"symbol_rank_search\", return_value=[(\"ref1\", 0.5), (\"ref2\", 0.4)]\n            ) as mock_method_4:\n                result = symbol_searcher.process_query(\"type:symbol_rank %s\" % symbols[0].uri)\n                assert result == [(\"ref1\", 0.5), (\"ref2\", 0.4)]\n            mock_method_4.assert_called_once_with(symbols[0].uri)\n        \n            with pytest.raises(ValueError):\n                symbol_searcher.process_query(\"invalid_query\")\n        \n            with pytest.raises(ValueError):\n                symbol_searcher.process_query(\"type:unknown query\")\n        \n        \n    automata.core.symbol.graph.SymbolGraph\n    \n        The `SymbolGraph` class represents a symbol graph that captures relationships between symbols found in source code files and is built from an index protobuf file. Utilizing NetworkX's MultiDiGraph, `SymbolGraph` represents relationships as a directed graph and includes methods for querying relationships, obtaining all available symbols and files, and filtering to subgraphs of rankable symbols. A navigator interface, _SymbolGraphNavigator, is required for getting reachable objects in the symbol subgraph.\n        \n        Example usage:\n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        \n        # Replace with your own file path\n        index_path = \"path/to/index.scip\"\n        symbol_graph = SymbolGraph(index_path)\n        all_symbols = symbol_graph.get_all_available_symbols()\n        ```\n        \n        Limitations include only being built from index protobuf files and the `get_potential_symbol_callers` method requiring downstream filtering to remove non-call statements. Future improvements may address these limitations and better handle edge cases in the symbol graph building process.\n        \n      Methods:\n        def __init__(\n                self, index_path: str = DEFAULT_SCIP_PATH, build_caller_relationships: bool = False\n            ):\n                \"\"\"\n                Initializes SymbolGraph with the path of an index protobuf file.\n        \n                Args:\n                    index_path (str): Path to index protobuf file\n                Returns:\n                    SymbolGraph instance\n                \"\"\"\n                index = self._load_index_protobuf(index_path)\n                builder = GraphBuilder(index, build_caller_relationships)\n                self._graph = builder.build_graph()\n                self.navigator = _SymbolGraphNavigator(self._graph)\n        \n            \n        get_all_available_symbols(self) -> List[Symbol]\n        \n        get_all_files(self) -> List[SymbolFile]\n        \n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n        get_rankable_symbol_subgraph(self, flow_rank=\"bidirectional\", path_filter: Optional[str] = None) -> SubGraph\n        \n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n    automata.core.symbol.parser.parse_symbol\n    \n      Class Docstring:\n        Parses a symbol from a URI\n        \n        Args:\n        symbol_uri (str): The URI of the symbol\n        include_descriptors (bool): Whether to include descriptors in the symbol\n        \n        Returns:\n        Symbol - The parsed symbol\n        \n      Methods:\n        parse_symbol(symbol_uri: str, include_descriptors: bool = True) -> Symbol\n        \n    automata.core.symbol.parser.SymbolParser\n    \n        SymbolParser is a class that enables parsing URIs into structured objects, such as `Symbol`. Although it is not fully in sync with the Go version found in Sourcegraph's SCIP repository, it retains acceptable functionality. The class has methods to accept and parse various parts of symbol strings, including identifiers and namespaces. Limitations include possible difficulties in parsing symbols that the Go version can handle. An example of using the `parse_symbol` function to create a `Symbol` object from a symbol URI string is provided, although future improvements to better handle parsing limitations may be necessary.\n        \n      Class Docstring:\n        Translation of the logic defined in\n        https://github.com/sourcegraph/scip/blob/ee677ba3756cdcdb55b39942b5701f0fde9d69fa/bindings/go/scip/symbol.go\n        to parse URIs into structured objects.\n        It's not great that this implementation is not in hard sync with the Go one, but it's good enough for now.\n        \n      Methods:\n        def __init__(self, symbol: str):\n                \"\"\"\n                Args:\n                    symbol (str): The symbol URI to parse\n                \"\"\"\n                self.symbol = symbol\n                self.index = 0\n                self.symbol_str = symbol\n        \n            \n        accept_backtick_escaped_identifier(self, what: str) -> str\n        \n        accept_character(self, r: str, what: str) -> None\n        \n        accept_escaped_identifier(self, what: str, escape_character: str) -> str\n        \n        accept_identifier(self, what: str) -> str\n        \n        accept_space_escaped_identifier(self, what: str) -> str\n        \n        current(self) -> str\n        \n        error(self, message: str) -> ValueError\n        \n        is_identifier_character(c: str) -> bool\n        \n        parse_descriptor(self) -> SymbolDescriptor\n        \n        parse_descriptors(self) -> List[SymbolDescriptor]\n        \n        peek_next(self) -> Optional[str]\n        \n    automata.tests.unit.test_symbol_search.test_retrieve_source_code_by_symbol\n    \n        def test_retrieve_source_code_by_symbol(symbols, symbol_searcher):\n            with patch(\n                \"automata.core.symbol.search.symbol_search.convert_to_fst_object\",\n                return_value=\"module1\",\n            ) as mock_method:\n                result = symbol_searcher.retrieve_source_code_by_symbol(symbols[0].uri)\n                assert result == \"module1\"\n            mock_method.assert_called_once_with(symbols[0])\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.SymbolReference\n    \n        `SymbolReference` is a class representing a reference to a symbol in a file, used for managing references to symbols within a codebase. It offers utility methods for comparing and hashing symbol references based on their URI, line number, and column number. In conjunction with other symbol-related classes, it helps track and manage references to symbols in files based on their location and usage. However, there is a potential limitation of causing collisions when the same symbol is referenced in different files at the same location (line and column). This is rare, but important to consider when working with multiple symbol references across files.\n        \n        Example usage: \n        ```python\n        from automata.core.symbol.symbol_types import SymbolReference\n        from automata.core.symbol.parser import parse_symbol\n        \n        symbol_uri = \"example_uri\"\n        line_number = 10\n        column_number = 5\n        symbol = parse_symbol(symbol_uri)\n        \n        symbol_ref1 = SymbolReference(symbol, line_number, column_number)\n        symbol_ref2 = SymbolReference(symbol, line_number + 1, column_number)\n        \n        assert symbol_ref1 != symbol_ref2\n        assert hash(symbol_ref1) != hash(symbol_ref2)\n        \n        symbol_ref3 = SymbolReference(symbol, line_number, column_number)\n        assert symbol_ref1 == symbol_ref3\n        ```\n        \n      Class Docstring:\n        Represents a reference to a symbol in a file\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n    automata.tests.unit.test_database_vector.test_lookup_symbol\n    \n        def test_lookup_symbol(temp_output_filename, symbols):\n            vector_db = JSONVectorDatabase(temp_output_filename)\n            embedded_symbol_0 = SymbolEmbedding(symbols[0], \"x\", [1, 2, 3])\n            vector_db.add(embedded_symbol_0)\n            embedded_symbol_1 = SymbolEmbedding(symbols[1], \"y\", [1, 2, 3, 4])\n            vector_db.add(embedded_symbol_1)\n        \n            vector_db.get(symbols[0])\n        \n        \n        \n        \n  Building context for dependencies -\n  \n    automata.core.embedding.symbol_similarity.SymbolSimilarity.get_query_similarity_dict\n    \n      Class Docstring:\n        Get the similarity scores of all symbols for the query_text\n        \n        Args:\n        query_text (str): The query text\n        \n        Returns:\n        A dictionary mapping each symbol's uri to its similarity score with the query\n        \n      Methods:\n        get_query_similarity_dict(self, query_text: str) -> Dict[Symbol, float]\n        \n    automata.core.symbol.graph.SymbolGraph.get_all_available_symbols\n    \n      Class Docstring:\n        Gets all symbols defined in the graph.\n        \n        Args:\n        None\n        Returns:\n        List[Symbol]: List of all defined symbols.\n        \n      Methods:\n        get_all_available_symbols(self) -> List[Symbol]\n        \n    automata.core.symbol.symbol_utils.convert_to_fst_object\n    \n      Class Docstring:\n        Converts a specified symbol into a red baron FST object\n        \n        Args:\n        symbol (str): The symbol which corresponds to a module, class, or method.\n        module_map (Optional[LazyModuleTreeMap]): The module tree mapping to use. If None, the default\n        \n        Returns:\n        Union[ClassNode, DefNode]: The RedBaron FST object for the class or method, or None if not found\n        \n        Raises:\n        ValueError: If the symbol is not found\n        \n        Note:\n        The optional argument is to allow us to run this function in mulitprocessing in the future,\n        because module map is not picklable (because redbaron objects are not picklable)\n        So the indexer would have to be created and destroyed in each process.\n        \n      Methods:\n        convert_to_fst_object(symbol: Symbol, module_map: Optional[LazyModuleTreeMap] = None) -> RedBaron\n        \n    automata.core.symbol.graph.SymbolGraph.SubGraph\n    \n        `SymbolGraph.SubGraph` is a data class designed to maintain and analyze subgraphs of a `SymbolGraph`. It contains a `parent` attribute to track the parent `SymbolGraph` instance and a `graph` attribute representing the actual subgraph with nodes and edges. The class offers a convenient way to encapsulate subgraphs for further analysis, connecting it closely to the `SymbolGraph` class and related methods. However, its main limitation is that it must be created from a `SymbolGraph` instance, requiring the extraction of the desired subgraph from an existing `SymbolGraph`.\n        \n    automata.core.embedding.symbol_similarity.SymbolSimilarity.set_available_symbols\n    \n      Class Docstring:\n        Set the available symbols to use for similarity calculation\n        \n        Args:\n        available_symbols (Set[Symbol]): The available symbols to\n        use for similarity calculation\n        \n      Methods:\n        set_available_symbols(self, available_symbols: Set[Symbol]) -> None\n        \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap.items\n    \n      Class Docstring:\n        Returns:\n        A dictionary containing the module dotpath to module RedBaron FST object mapping\n        \n      Methods:\n        items(self) -> Iterable[Tuple[str, Optional[RedBaron]]]\n        \n    automata.core.symbol.search.rank.SymbolRank.get_ranks\n    \n      Class Docstring:\n        Calculate the SymbolRanks of each node in the graph\n        \n        Args:\n        query_to_symbol_similarity (Optional[Dict[Symbol, float]]):\n        query_to_symbol_similarity dictionary\n        initial_weights (Optional[Dict[Symbol, float]]): Initial weights dictionary\n        dangling (Optional[Dict[Symbol, float]]): List of dangling nodes\n        \n        Returns:\n        (Dict[str, float]): A dictionary mapping each node to its SymbolRank\n        \n      Methods:\n        get_ranks(self,\n                query_to_symbol_similarity: Optional[Dict[Symbol, float]] = None,\n                initial_weights: Optional[Dict[Symbol, float]] = None,\n                dangling: Optional[Dict[Symbol, float]] = None,\n            ) -> List[Tuple[Symbol, float]]\n        \n    automata.core.symbol.search.rank.SymbolRankConfig\n    \n        class SymbolRankConfig(BaseModel):\n            \"\"\"A configuration class for SymbolRank\"\"\"\n        \n            alpha: float = 0.25\n            max_iterations: int = 100\n            tolerance: float = 1.0e-6\n            weight_key: str = \"weight\"\n        \n            @classmethod\n            def validate(cls, config):\n                \"\"\"\n                Validate configuration parameters.\n        \n                Args:\n                    config (SymbolRankConfig): Configuration parameters.\n        \n                Raises:\n                    ValueError: If alpha is not in (0, 1), or tolerance is not in (1e-4, 1e-8).\n                \"\"\"\n                if not 0 < config.alpha < 1:\n                    raise ValueError(f\"alpha must be in (0,1), but got {config.alpha}\")\n        \n                if not 1.0e-8 < config.tolerance < 1.0e-4:\n                    raise ValueError(f\"tolerance must be in (1e-4,1e-8), but got {config.tolerance}\")\n        \n        \n        \n        \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap\n    \n        The `LazyModuleTreeMap` class is a lazy dictionary that maps module dotpaths to their corresponding RedBaron FST objects, loading and caching the modules in memory as they are accessed. It provides methods for fetching existing module dotpaths and filepaths, as well as fetching, putting, and updating modules by their dotpaths. However, it assumes a specific directory structure according to the `DotPathMap` class and does not support custom directory structures for modules.\n        \n        ```python\n        from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n        from automata.core.utils import root_fpath\n        \n        path_to_root = root_fpath()\n        module_tree_map = LazyModuleTreeMap(path_to_root)\n        \n        # Fetch an existing module by its dotpath\n        module_dotpath = \"automata.core.agent.automata_agent\"\n        module = module_tree_map.fetch_module(module_dotpath)\n        \n        # Check if a module with the given dotpath exists\n        exists = module_dotpath in module_tree_map\n        ```\n        \n      Class Docstring:\n        A lazy dictionary between module dotpaths and their corresponding RedBaron FST objects.\n        Loads and caches modules in memory as they are accessed\n        \n      Methods:\n        __contains__(self, dotpath) -> None\n        \n        def __init__(self, path: str):\n                \"\"\"\n                Args:\n                    path: The absolute path to the root of the module tree\n                \"\"\"\n                self._dotpath_map = DotPathMap(path)\n                self._loaded_modules: Dict[str, Optional[RedBaron]] = {}\n        \n            \n        cached_default(cls) -> \"LazyModuleTreeMap\"\n        \n        fetch_existing_module_dotpath(self, module_obj: RedBaron) -> Optional[str]\n        \n        fetch_existing_module_fpath_by_dotpath(self, module_dotpath: str) -> Optional[str]\n        \n        fetch_module(self, module_dotpath: str) -> Optional[RedBaron]\n        \n        get_module_dotpath_by_fpath(self, module_fpath: str) -> str\n        \n        items(self) -> Iterable[Tuple[str, Optional[RedBaron]]]\n        \n        put_module(self, module_dotpath: str, module: RedBaron) -> None\n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.symbol_types`/Symbol#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.symbol_types", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "Symbol", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# Symbol\n\n`Symbol` is a class that identifies a class, method, or local variable in a package. It works similarly to a URI and includes rich metadata such as the docstring. It has a standardized string representation that can be used interchangeably with `Symbol`. The syntax and examples of `Symbol` can be found below.\n\n## Overview\n\n`Symbol` identifies a class, method, or local variable and includes rich metadata. It has a standardized string representation that can be used interchangeably with `Symbol`. `Symbol` instances can be created from string representations and can be compared with one another. Each `Symbol` instance comes with utility methods for parsing, creating, and querying symbolic data. Related symbols include those within embedding, graph, and parser modules.\n\n## Related Symbols\n\n- `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n- `automata.core.symbol.graph.SymbolGraph`\n- `automata.tests.unit.test_symbol_parser.test_parse_symbol`\n- `automata.core.symbol.parser.parse_symbol`\n- `automata.core.database.vector.JSONVectorDatabase`\n- `automata.tests.unit.test_database_vector.test_delete_symbol`\n- `automata.tests.unit.test_database_vector.test_lookup_symbol`\n- `automata.tests.unit.test_symbol_parser.test_is_local_symbol`\n- `automata.tests.unit.test_symbol_graph.test_get_all_symbols`\n- `automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler`\n\n## Example\n\nThe following examples demonstrate how to create an instance of `Symbol` using the `parse_symbol` function.\n\n```python\nfrom automata.core.symbol.parser import parse_symbol\n\nsymbol_class = parse_symbol(\n    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n)\n\nsymbol_method = parse_symbol(\n    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n)\n```\n\n## Limitations\n\n`Symbol` assumes specific syntax when parsing string representations and can only handle specific symbol types. It does not support custom symbol types or variations in syntax.\n\n## Follow-up Questions:\n\n- How can we extend `Symbol` to support custom symbol types and variations in syntax?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 198}, false, {"py/b64": "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"}]}]}, "source_code": "@dataclass\nclass Symbol:\n    \"\"\"\n    Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n\n    Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n\n    # (<x>)+ stands for one or more repetitions of <x>\n    <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n    <package>              ::= <manager> ' ' <package-name> ' ' <version>\n    <scheme>               ::= any UTF-8, escape spaces with double space.\n    <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n    <package-name>         ::= same as above\n    <version>              ::= same as above\n    <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n    <namespace>            ::= <name> '/'\n    <type>                 ::= <name> '#'\n    <term>                 ::= <name> '.'\n    <meta>                 ::= <name> ':'\n    <macro>                ::= <name> '!'\n    <method>               ::= <name> '(' <method-disambiguator> ').'\n    <type-parameter>       ::= '[' <name> ']'\n    <parameter>            ::= '(' <name> ')'\n    <name>                 ::= <identifier>\n    <method-disambiguator> ::= <simple-identifier>\n    <identifier>           ::= <simple-identifier> | <escaped-identifier>\n    <simple-identifier>    ::= (<identifier-character>)+\n    <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n    <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n    <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n\n    Examples -\n    from automata.core.symbol.search.symbol_parser import parse_symbol\n\n    symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n    )\n\n    symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n    )\n    \"\"\"\n\n    uri: str\n    scheme: str\n    package: SymbolPackage\n    descriptors: Tuple[SymbolDescriptor, ...]\n\n    def __repr__(self) -> str:\n        \"\"\"Converts back into URI string\"\"\"\n        return f\"Symbol({self.uri}, {self.scheme}, {self.package}, {self.descriptors})\"\n\n    def __hash__(self) -> int:\n        \"\"\"Hashes the URI string\"\"\"\n        return hash(self.uri)\n\n    def __eq__(self, other):\n        \"\"\"Compares the URI string\"\"\"\n        if isinstance(other, Symbol):\n            return self.uri == other.uri\n        elif isinstance(other, str):\n            return self.uri == other\n        return False\n\n    def symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind:\n        \"\"\"Converts the suffix of the URI into a PyKind\"\"\"\n        return SymbolDescriptor.convert_scip_to_python_suffix(self.symbol_raw_kind_by_suffix())\n\n    def symbol_raw_kind_by_suffix(self) -> DescriptorProto:\n        \"\"\"Converts the suffix of the URI into a DescriptorProto\"\"\"\n        if self.uri.startswith(\"local\"):\n            return SymbolDescriptor.ScipSuffix.Local\n        if self.uri.endswith(\"/\"):\n            return SymbolDescriptor.ScipSuffix.Namespace\n        elif self.uri.endswith(\"#\"):\n            return SymbolDescriptor.ScipSuffix.Type\n        elif self.uri.endswith(\").\"):\n            return SymbolDescriptor.ScipSuffix.Method\n        elif self.uri.endswith(\".\"):\n            return SymbolDescriptor.ScipSuffix.Term\n        elif self.uri.endswith(\":\"):\n            return SymbolDescriptor.ScipSuffix.Meta\n        elif self.uri.endswith(\")\"):\n            return SymbolDescriptor.ScipSuffix.Parameter\n        elif self.uri.endswith(\"]\"):\n            return SymbolDescriptor.ScipSuffix.TypeParameter\n        else:\n            raise ValueError(f\"Invalid descriptor suffix: {self.uri}\")\n\n    def parent(self) -> \"Symbol\":\n        \"\"\"Returns the parent symbol of the current symbol\"\"\"\n        parent_descriptors = list(self.descriptors)[:-1]\n        return Symbol(self.uri, self.scheme, self.package, tuple(parent_descriptors))\n\n    @property\n    def dotpath(self) -> str:\n        \"\"\"Returns the dotpath of the symbol\"\"\"\n        return \".\".join([ele.name for ele in self.descriptors])\n\n    @property\n    def module_name(self) -> str:\n        \"\"\"Returns the module name of the symbol\"\"\"\n        return self.descriptors[0].name\n\n    @staticmethod\n    def is_local(symbol: \"Symbol\") -> bool:\n        \"\"\"Returns True if the symbol is local\"\"\"\n        return symbol.descriptors[0].suffix == SymbolDescriptor.ScipSuffix.Local\n\n    @staticmethod\n    def is_meta(symbol: \"Symbol\") -> bool:\n        \"\"\"Returns True if the symbol is meta\"\"\"\n        return symbol.descriptors[0].suffix == SymbolDescriptor.ScipSuffix.Meta\n\n    @staticmethod\n    def is_parameter(symbol: \"Symbol\") -> bool:\n        \"\"\"Returns True if the symbol is parameter\"\"\"\n        return symbol.descriptors[0].suffix == SymbolDescriptor.ScipSuffix.Parameter\n\n    @staticmethod\n    def is_protobuf(symbol: \"Symbol\") -> bool:\n        \"\"\"Returns True if the symbol is a protobuf symbol\"\"\"\n        return symbol.module_name.endswith(\"pb2\")\n\n    @classmethod\n    def from_string(cls, symbol_str: str) -> \"Symbol\":\n        \"\"\"\n        Creates a Symbol instance from a string representation\n\n        :param symbol_str: The string representation of the Symbol\n        :return: A Symbol instance\n        \"\"\"\n        # Assuming symbol_str is in the format: \"Symbol({uri}, {scheme}, Package({manager} {name} {version}), [{Descriptor},...])\"\n        # Parse the symbol_str to extract the uri, scheme, package_str, and descriptors_str\n        match = re.search(r\"Symbol\\((.*?), (.*?), Package\\((.*?)\\), \\((.*?)\\)\\)\", symbol_str)\n        if not match:\n            raise ValueError(f\"Invalid symbol_str: {symbol_str}\")\n        uri, _, __, ___ = match.groups()\n        # In current implementation, only the uri is used in re-construcing the symbol\n        from automata.core.symbol.parser import parse_symbol\n\n        return parse_symbol(uri)\n\n\n", "summary": "`Symbol` is a class used to identify and store metadata about a class, method, or local variable in a package, similar to a URI. It has a standardized string representation that can be used interchangeably with `Symbol`. Instances of `Symbol` can be created from string representations, compared with other instances, and contain utility methods for parsing, creating, and querying symbolic data. However, `Symbol` has limitations in handling specific symbol types and syntax variations.\n\nHere is an example of creating an instance of `Symbol` using the `parse_symbol` function:\n\n```python\nfrom automata.core.symbol.parser import parse_symbol\n\nsymbol_class = parse_symbol(\n    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n)\n\nsymbol_method = parse_symbol(\n    \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n)\n```", "context": "\n    Generate the documentation for Symbol using the context shown below -\n  Building context for primary symbol - automata.core.symbol.symbol_types.Symbol -\n  \n    Import Statements:\n      import abc\n      import re\n      import numpy as np\n      from dataclasses import dataclass\n      from enum import Enum\n      from typing import Any, Dict, Optional, Tuple\n      from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n      from automata.core.symbol.parser import parse_symbol\n      \n      # Symbol\n      \n      `Symbol` is a class that identifies a class, method, or local variable in a package. It works similarly to a URI and includes rich metadata such as the docstring. It has a standardized string representation that can be used interchangeably with Symbol. The syntax and examples of Symbol can be found below.\n      \n      ## Overview\n      \n      `Symbol` identifies a class, method, or local variable and includes rich metadata. It has a standardized string representation that can be used interchangeably with Symbol. `Symbol` instances can be created from string representations and can be compared with one another. Each `Symbol` instance comes with utility methods for parsing, creating, and querying symbolic data. Related symbols include those within embedding, graph, and parser modules.\n      \n      ## Related Symbols\n      \n      - `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n      - `automata.core.symbol.graph.SymbolGraph`\n      - `automata.tests.unit.test_symbol_parser.test_parse_symbol`\n      - `automata.core.symbol.parser.parse_symbol`\n      - `automata.core.database.vector.JSONVectorDatabase`\n      - `automata.tests.unit.test_database_vector.test_delete_symbol`\n      - `automata.tests.unit.test_database_vector.test_lookup_symbol`\n      - `automata.tests.unit.test_symbol_parser.test_is_local_symbol`\n      - `automata.tests.unit.test_symbol_graph.test_get_all_symbols`\n      - `automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler`\n      \n      ## Example\n      \n      The following examples demonstrate how to create an instance of `Symbol` using the `parse_symbol` function.\n      \n      ```python\n      from automata.core.symbol.search.symbol_parser import parse_symbol\n      \n      symbol_class = parse_symbol(\n          \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n      )\n      \n      symbol_method = parse_symbol(\n          \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n      )\n      ```\n      \n      ## Limitations\n      \n      `Symbol` assumes specific syntax when parsing string representations, and it can only handle specific symbol types. It does not support custom symbol types or variations in syntax.\n      \n      ## Follow-up Questions:\n      \n      - How can we extend Symbol to support custom symbol types and variations in syntax?\n      \n    Class Docstring:\n      Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n      \n      Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n      \n      # (<x>)+ stands for one or more repetitions of <x>\n      <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n      <package>              ::= <manager> ' ' <package-name> ' ' <version>\n      <scheme>               ::= any UTF-8, escape spaces with double space.\n      <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n      <package-name>         ::= same as above\n      <version>              ::= same as above\n      <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n      <namespace>            ::= <name> '/'\n      <type>                 ::= <name> '#'\n      <term>                 ::= <name> '.'\n      <meta>                 ::= <name> ':'\n      <macro>                ::= <name> '!'\n      <method>               ::= <name> '(' <method-disambiguator> ').'\n      <type-parameter>       ::= '[' <name> ']'\n      <parameter>            ::= '(' <name> ')'\n      <name>                 ::= <identifier>\n      <method-disambiguator> ::= <simple-identifier>\n      <identifier>           ::= <simple-identifier> | <escaped-identifier>\n      <simple-identifier>    ::= (<identifier-character>)+\n      <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n      <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n      <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n      \n      Examples -\n      from automata.core.symbol.search.symbol_parser import parse_symbol\n      \n      symbol_class = parse_symbol(\n      \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n      )\n      \n      symbol_method = parse_symbol(\n      \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n      )\n      \n    Methods:\n      def __eq__(self, other):\n              \"\"\"Compares the URI string\"\"\"\n              if isinstance(other, Symbol):\n                  return self.uri == other.uri\n              elif isinstance(other, str):\n                  return self.uri == other\n              return False\n      \n          \n      def __hash__(self) -> int:\n              \"\"\"Hashes the URI string\"\"\"\n              return hash(self.uri)\n      \n          \n      def __repr__(self) -> str:\n              \"\"\"Converts back into URI string\"\"\"\n              return f\"Symbol({self.uri}, {self.scheme}, {self.package}, {self.descriptors})\"\n      \n          \n      @property\n          def dotpath(self) -> str:\n              \"\"\"Returns the dotpath of the symbol\"\"\"\n              return \".\".join([ele.name for ele in self.descriptors])\n      \n          \n      @classmethod\n          def from_string(cls, symbol_str: str) -> \"Symbol\":\n              \"\"\"\n              Creates a Symbol instance from a string representation\n      \n              :param symbol_str: The string representation of the Symbol\n              :return: A Symbol instance\n              \"\"\"\n              # Assuming symbol_str is in the format: \"Symbol({uri}, {scheme}, Package({manager} {name} {version}), [{Descriptor},...])\"\n              # Parse the symbol_str to extract the uri, scheme, package_str, and descriptors_str\n              match = re.search(r\"Symbol\\((.*?), (.*?), Package\\((.*?)\\), \\((.*?)\\)\\)\", symbol_str)\n              if not match:\n                  raise ValueError(f\"Invalid symbol_str: {symbol_str}\")\n              uri, _, __, ___ = match.groups()\n              # In current implementation, only the uri is used in re-construcing the symbol\n              from automata.core.symbol.parser import parse_symbol\n      \n              return parse_symbol(uri)\n      \n      \n      \n      @staticmethod\n          def is_local(symbol: \"Symbol\") -> bool:\n              \"\"\"Returns True if the symbol is local\"\"\"\n              return symbol.descriptors[0].suffix == SymbolDescriptor.ScipSuffix.Local\n      \n          \n      @staticmethod\n          def is_meta(symbol: \"Symbol\") -> bool:\n              \"\"\"Returns True if the symbol is meta\"\"\"\n              return symbol.descriptors[0].suffix == SymbolDescriptor.ScipSuffix.Meta\n      \n          \n      @staticmethod\n          def is_parameter(symbol: \"Symbol\") -> bool:\n              \"\"\"Returns True if the symbol is parameter\"\"\"\n              return symbol.descriptors[0].suffix == SymbolDescriptor.ScipSuffix.Parameter\n      \n          \n      @staticmethod\n          def is_protobuf(symbol: \"Symbol\") -> bool:\n              \"\"\"Returns True if the symbol is a protobuf symbol\"\"\"\n              return symbol.module_name.endswith(\"pb2\")\n      \n          \n      @property\n          def module_name(self) -> str:\n              \"\"\"Returns the module name of the symbol\"\"\"\n              return self.descriptors[0].name\n      \n          \n      def parent(self) -> \"Symbol\":\n              \"\"\"Returns the parent symbol of the current symbol\"\"\"\n              parent_descriptors = list(self.descriptors)[:-1]\n              return Symbol(self.uri, self.scheme, self.package, tuple(parent_descriptors))\n      \n          \n      def symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind:\n              \"\"\"Converts the suffix of the URI into a PyKind\"\"\"\n              return SymbolDescriptor.convert_scip_to_python_suffix(self.symbol_raw_kind_by_suffix())\n      \n          \n      def symbol_raw_kind_by_suffix(self) -> DescriptorProto:\n              \"\"\"Converts the suffix of the URI into a DescriptorProto\"\"\"\n              if self.uri.startswith(\"local\"):\n                  return SymbolDescriptor.ScipSuffix.Local\n              if self.uri.endswith(\"/\"):\n                  return SymbolDescriptor.ScipSuffix.Namespace\n              elif self.uri.endswith(\"#\"):\n                  return SymbolDescriptor.ScipSuffix.Type\n              elif self.uri.endswith(\").\"):\n                  return SymbolDescriptor.ScipSuffix.Method\n              elif self.uri.endswith(\".\"):\n                  return SymbolDescriptor.ScipSuffix.Term\n              elif self.uri.endswith(\":\"):\n                  return SymbolDescriptor.ScipSuffix.Meta\n              elif self.uri.endswith(\")\"):\n                  return SymbolDescriptor.ScipSuffix.Parameter\n              elif self.uri.endswith(\"]\"):\n                  return SymbolDescriptor.ScipSuffix.TypeParameter\n              else:\n                  raise ValueError(f\"Invalid descriptor suffix: {self.uri}\")\n      \n          \n  Building context for related symbols -\n  \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.tests.unit.test_symbol_parser.test_parse_symbol\n    \n        def test_parse_symbol(symbols):\n            for symbol in symbols:\n                assert symbol.scheme == \"scip-python\"\n                assert symbol.package.manager == \"python\"\n                assert symbol.package.name == \"automata\"\n                assert symbol.package.version == \"75482692a6fe30c72db516201a6f47d9fb4af065\"\n                assert len(symbol.descriptors) > 0\n        \n        \n        \n        \n    automata.core.symbol.parser.parse_symbol\n    \n      Class Docstring:\n        Parses a symbol from a URI\n        \n        Args:\n        symbol_uri (str): The URI of the symbol\n        include_descriptors (bool): Whether to include descriptors in the symbol\n        \n        Returns:\n        Symbol - The parsed symbol\n        \n      Methods:\n        parse_symbol(symbol_uri: str, include_descriptors: bool = True) -> Symbol\n        \n    automata.core.symbol.graph.SymbolGraph\n    \n        The `SymbolGraph` class represents a symbol graph that captures relationships between symbols found in source code files and is built from an index protobuf file. Utilizing NetworkX's MultiDiGraph, `SymbolGraph` represents relationships as a directed graph and includes methods for querying relationships, obtaining all available symbols and files, and filtering to subgraphs of rankable symbols. A navigator interface, _SymbolGraphNavigator, is required for getting reachable objects in the symbol subgraph.\n        \n        Example usage:\n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        \n        # Replace with your own file path\n        index_path = \"path/to/index.scip\"\n        symbol_graph = SymbolGraph(index_path)\n        all_symbols = symbol_graph.get_all_available_symbols()\n        ```\n        \n        Limitations include only being built from index protobuf files and the `get_potential_symbol_callers` method requiring downstream filtering to remove non-call statements. Future improvements may address these limitations and better handle edge cases in the symbol graph building process.\n        \n      Methods:\n        def __init__(\n                self, index_path: str = DEFAULT_SCIP_PATH, build_caller_relationships: bool = False\n            ):\n                \"\"\"\n                Initializes SymbolGraph with the path of an index protobuf file.\n        \n                Args:\n                    index_path (str): Path to index protobuf file\n                Returns:\n                    SymbolGraph instance\n                \"\"\"\n                index = self._load_index_protobuf(index_path)\n                builder = GraphBuilder(index, build_caller_relationships)\n                self._graph = builder.build_graph()\n                self.navigator = _SymbolGraphNavigator(self._graph)\n        \n            \n        get_all_available_symbols(self) -> List[Symbol]\n        \n        get_all_files(self) -> List[SymbolFile]\n        \n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n        get_rankable_symbol_subgraph(self, flow_rank=\"bidirectional\", path_filter: Optional[str] = None) -> SubGraph\n        \n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.tests.unit.test_database_vector.test_delete_symbol\n    \n        def test_delete_symbol(temp_output_filename, symbols):\n            vector_db = JSONVectorDatabase(temp_output_filename)\n            symbol = symbols[0]\n            embedded_symbol = SymbolEmbedding(symbol, \"x\", [1, 2, 3])\n            vector_db.add(embedded_symbol)\n            vector_db.discard(symbol)\n        \n        \n        \n        \n    automata.tests.unit.test_database_vector.test_lookup_symbol\n    \n        def test_lookup_symbol(temp_output_filename, symbols):\n            vector_db = JSONVectorDatabase(temp_output_filename)\n            embedded_symbol_0 = SymbolEmbedding(symbols[0], \"x\", [1, 2, 3])\n            vector_db.add(embedded_symbol_0)\n            embedded_symbol_1 = SymbolEmbedding(symbols[1], \"y\", [1, 2, 3, 4])\n            vector_db.add(embedded_symbol_1)\n        \n            vector_db.get(symbols[0])\n        \n        \n        \n        \n    automata.tests.unit.test_symbol_parser.test_is_local_symbol\n    \n        def test_is_local_symbol(symbols):\n            for symbol in symbols:\n                assert is_local_symbol(\"local \" + symbol.uri)\n        \n        \n        \n        \n    automata.tests.unit.test_symbol_graph.test_get_all_symbols\n    \n        def test_get_all_symbols(symbol_graph):\n            graph_symbols = symbol_graph.get_all_available_symbols()\n            assert isinstance(graph_symbols, list)\n            assert all(isinstance(s, Symbol) for s in graph_symbols)\n        \n        \n    automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler\n    \n        The `SymbolDocEmbeddingHandler` class is responsible for generating, storing, and managing document embeddings for symbols in an AutomataDocs project. It relies on the `VectorDatabaseProvider`, `EmbeddingProvider` classes, and uses methods like `build_symbol_doc_embedding`, `update_embedding`, `get_embedding`, `get_doc`, and `get_summary` for managing symbol document embeddings and their summaries. The class utilizes various other components like `SymbolGraph`, `SymbolSimilarity`, and `SymbolRankConfig` to search, rank, and generate context for symbol embeddings. However, it has limitations concerning the embedding models and algorithms used and can sometimes produce suboptimal context or examples. Improving the underlying components can potentially enhance the embedding quality.\n        \n        Example usage:\n        \n        ```python\n        from automata.core.embedding.doc_embedding import SymbolDocEmbeddingHandler\n        from automata.core.database.vector import JSONVectorDatabase, VectorDatabaseProvider\n        from automata.core.embedding.embedding_types import OpenAIEmbedding, EmbeddingProvider\n        from automata.core.symbol.symbol_types import Symbol\n        \n        # Initialize the database provider and embedding provider\n        db_provider = VectorDatabaseProvider(JSONVectorDatabase(\"path/to/symbol_doc_embedding.json\"))\n        embedding_provider = EmbeddingProvider(OpenAIEmbedding())\n        \n        # Create an instance of SymbolDocEmbeddingHandler\n        embedding_handler = SymbolDocEmbeddingHandler(db_provider, embedding_provider)\n        \n        # Example symbol and source code\n        symbol = Symbol.from_string(\"symbol-uri-as-string\")\n        source_code = \"def example_function():\\n    pass\"\n        \n        # Build the symbol document embedding\n        symbol_doc_embedding = embedding_handler.build_symbol_doc_embedding(source_code, symbol)\n        ```\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n                code_embedding_handler: SymbolCodeEmbeddingHandler,\n                embedding_db_l2: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                A constructor for SymbolDocEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (EmbeddingProvider): The provider to get the embeddings from\n                    code_embedding_handler (SymbolCodeEmbeddingHandler): The code embedding handler\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n                from automata.core.embedding.symbol_similarity import SymbolSimilarity\n                from automata.core.symbol.search.rank import SymbolRankConfig\n                from automata.core.symbol.search.symbol_search import SymbolSearch\n        \n                graph = SymbolGraph()\n                subgraph = graph.get_rankable_symbol_subgraph()\n                symbol_similarity = SymbolSimilarity(code_embedding_handler)\n                self.graph = graph\n                self.symbol_search = SymbolSearch(\n                    graph, symbol_similarity, symbol_rank_config=SymbolRankConfig(), code_subgraph=subgraph\n                )\n                self.embedding_db_l2 = embedding_db_l2\n        \n            \n        build_symbol_doc_embedding(self, source_code: str, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_doc(prompt: str) -> str\n        \n        get_embedding(self, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_summary(input_doc: str) -> str\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.symbol_types`/SymbolCodeEmbedding#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.symbol_types", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolCodeEmbedding", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolCodeEmbedding\n\n`SymbolCodeEmbedding` is a class that represents code embeddings for a given symbol. It is an extension of the `SymbolEmbedding` base class and is primarily used to store and handle code embeddings of symbols in a given codebase.\n\n## Overview\n\n`SymbolCodeEmbedding` is an extension of the `SymbolEmbedding` abstract base class. It is a class used to store the code embeddings for a given symbol, along with the symbol object, the source code, and the embedding vector. It comes with an initializer method that takes the symbol object, source code, and a vector as arguments.\n\n## Related Symbols\n\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n- `automata.core.symbol.symbol_types.SymbolEmbedding`\n- `automata.core.symbol.scip_pb2.Descriptor as DescriptorProto`\n\n## Example\n\nThe following example demonstrates how to create an instance of `SymbolCodeEmbedding`.\n\n```python\nfrom automata.core.symbol.symbol_types import SymbolCodeEmbedding\nfrom automata.core.symbol.parser import parse_symbol\nimport numpy as np\n\nsymbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\nsymbol = parse_symbol(symbol_str)\nsource_code = \"def example_function():\\n    pass\"\nvector = np.random.random((300,))\n\nembedding = SymbolCodeEmbedding(symbol, source_code, vector)\n```\n\n## Limitations\n\n`SymbolCodeEmbedding` is primarily a container for symbol code embeddings, and it does not include functionality for generating or handling embeddings on its own. To generate and manage symbol code embeddings, the `SymbolCodeEmbeddingHandler` class should be used.\n\n## Follow-up Questions:\n\n- Can we implement a method in `SymbolCodeEmbedding` to generate the code embeddings for the given source code?\n\n## Class Details\n\n- Embedding for symbol code\n\n### Methods\n\n- `__init__(self, symbol: Symbol, source_code: str, vector: np.array)`: Constructor for the SymbolCodeEmbedding class that initializes the instance with the provided symbol, source code, and vector.", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 198}, false, {"py/b64": "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"}]}]}, "source_code": "class SymbolCodeEmbedding(SymbolEmbedding):\n    \"\"\"Embedding for symbol code\"\"\"\n\n    def __init__(self, symbol: Symbol, source_code: str, vector: np.array):\n        super().__init__(symbol, source_code, vector)\n\n\n", "summary": "`SymbolCodeEmbedding` is a class extending the `SymbolEmbedding` base class and is used for storing and handling code embeddings of symbols in a given codebase. It takes in a symbol object, source code, and an embedding vector as arguments and stores the data along with the symbol object and the source code. It serves as a container for symbol code embeddings but does not include functionality for generating or handling embeddings on its own. To achieve these functionalities, the `SymbolCodeEmbeddingHandler` class should be used. \n\nHere's an example of how to create an instance of `SymbolCodeEmbedding`:\n\n```python\nfrom automata.core.symbol.symbol_types import SymbolCodeEmbedding\nfrom automata.core.symbol.parser import parse_symbol\nimport numpy as np\n\nsymbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\nsymbol = parse_symbol(symbol_str)\nsource_code = \"def example_function():\\n    pass\"\nvector = np.random.random((300,))\n\nembedding = SymbolCodeEmbedding(symbol, source_code, vector)\n```", "context": "\n    Generate the documentation for SymbolCodeEmbedding using the context shown below -\n  Building context for primary symbol - automata.core.symbol.symbol_types.SymbolCodeEmbedding -\n  \n    Import Statements:\n      import abc\n      import re\n      import numpy as np\n      from dataclasses import dataclass\n      from enum import Enum\n      from typing import Any, Dict, Optional, Tuple\n      from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n      from automata.core.symbol.parser import parse_symbol\n      \n      # SymbolCodeEmbedding\n      \n      `SymbolCodeEmbedding` is a class that represents code embeddings for a given symbol. It is an extension of the `SymbolEmbedding` base class and is primarily used to store and handle code embeddings of symbols in a given codebase.\n      \n      ## Overview\n      \n      `SymbolCodeEmbedding` is an extension of the `SymbolEmbedding` abstract base class. It is a class used to store the code embeddings for a given symbol, along with the symbol object, the source code, and the embedding vector. It comes with an initializer method that takes the symbol object, source code, and a vector as arguments.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n      - `automata.core.symbol.symbol_types.SymbolEmbedding`\n      - `automata.core.symbol.scip_pb2.Descriptor as DescriptorProto`\n      \n      ## Example\n      \n      The following example demonstrates how to create an instance of `SymbolCodeEmbedding`.\n      \n      ```python\n      from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n      from automata.core.symbol.parser import parse_symbol\n      import numpy as np\n      \n      symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n      symbol = parse_symbol(symbol_str)\n      source_code = \"def example_function():\\n    pass\"\n      vector = np.random.random((300,))\n      \n      embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n      ```\n      \n      ## Limitations\n      \n      `SymbolCodeEmbedding` is primarily a container for symbol code embeddings, and it does not include functionality for generating or handling embeddings on its own. To generate and manage symbol code embeddings, the `SymbolCodeEmbeddingHandler` class should be used.\n      \n      ## Follow-up Questions:\n      \n      - Can we implement a method in `SymbolCodeEmbedding` to generate the code embeddings for the given source code?\n      \n    Class Docstring:\n      Embedding for symbol code\n      \n    Methods:\n      def __init__(self, symbol: Symbol, source_code: str, vector: np.array):\n              super().__init__(symbol, source_code, vector)\n      \n      \n      \n  Building context for related symbols -\n  \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.core.symbol.symbol_types.SymbolEmbedding\n    \n        SymbolEmbedding is an abstract base class used to represent various symbol embeddings, such as SymbolCodeEmbedding and SymbolDocEmbedding. It provides a basic structure for initializing and managing these embeddings, taking into account their source and their vector representation in the feature space. SymbolEmbedding is utilized by different embedding handlers like SymbolCodeEmbeddingHandler and SymbolDocEmbeddingHandler. As a base class, its functionality is limited and should be extended by classes with specific embedding types. An example of creating a SymbolCodeEmbedding instance is shown below:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def __init__(self, message): pass\"\n        vector = np.array([0.1, 0.2, 0.3])\n        \n        symbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Abstract base class for different types of embeddings\n        \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n    automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler\n    \n        The `SymbolDocEmbeddingHandler` class is responsible for generating, storing, and managing document embeddings for symbols in an AutomataDocs project. It relies on the `VectorDatabaseProvider`, `EmbeddingProvider` classes, and uses methods like `build_symbol_doc_embedding`, `update_embedding`, `get_embedding`, `get_doc`, and `get_summary` for managing symbol document embeddings and their summaries. The class utilizes various other components like `SymbolGraph`, `SymbolSimilarity`, and `SymbolRankConfig` to search, rank, and generate context for symbol embeddings. However, it has limitations concerning the embedding models and algorithms used and can sometimes produce suboptimal context or examples. Improving the underlying components can potentially enhance the embedding quality.\n        \n        Example usage:\n        \n        ```python\n        from automata.core.embedding.doc_embedding import SymbolDocEmbeddingHandler\n        from automata.core.database.vector import JSONVectorDatabase, VectorDatabaseProvider\n        from automata.core.embedding.embedding_types import OpenAIEmbedding, EmbeddingProvider\n        from automata.core.symbol.symbol_types import Symbol\n        \n        # Initialize the database provider and embedding provider\n        db_provider = VectorDatabaseProvider(JSONVectorDatabase(\"path/to/symbol_doc_embedding.json\"))\n        embedding_provider = EmbeddingProvider(OpenAIEmbedding())\n        \n        # Create an instance of SymbolDocEmbeddingHandler\n        embedding_handler = SymbolDocEmbeddingHandler(db_provider, embedding_provider)\n        \n        # Example symbol and source code\n        symbol = Symbol.from_string(\"symbol-uri-as-string\")\n        source_code = \"def example_function():\\n    pass\"\n        \n        # Build the symbol document embedding\n        symbol_doc_embedding = embedding_handler.build_symbol_doc_embedding(source_code, symbol)\n        ```\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n                code_embedding_handler: SymbolCodeEmbeddingHandler,\n                embedding_db_l2: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                A constructor for SymbolDocEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (EmbeddingProvider): The provider to get the embeddings from\n                    code_embedding_handler (SymbolCodeEmbeddingHandler): The code embedding handler\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n                from automata.core.embedding.symbol_similarity import SymbolSimilarity\n                from automata.core.symbol.search.rank import SymbolRankConfig\n                from automata.core.symbol.search.symbol_search import SymbolSearch\n        \n                graph = SymbolGraph()\n                subgraph = graph.get_rankable_symbol_subgraph()\n                symbol_similarity = SymbolSimilarity(code_embedding_handler)\n                self.graph = graph\n                self.symbol_search = SymbolSearch(\n                    graph, symbol_similarity, symbol_rank_config=SymbolRankConfig(), code_subgraph=subgraph\n                )\n                self.embedding_db_l2 = embedding_db_l2\n        \n            \n        build_symbol_doc_embedding(self, source_code: str, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_doc(prompt: str) -> str\n        \n        get_embedding(self, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_summary(input_doc: str) -> str\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n    automata.core.symbol.symbol_types.SymbolDocEmbedding\n    \n        `SymbolDocEmbedding` is a class representing the embedding for symbol documents, extending the `SymbolEmbedding` class with added metadata such as source code, summary, and context. This class is utilized alongside `SymbolDocEmbeddingHandler` to manage and access these embeddings for tasks like search and similarity comparison. However, it relies on external handler classes and assumes embeddings are provided as NumPy arrays, potentially limiting usage for other embedding types.\n        \n        ```python\n        import numpy as np\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.symbol.symbol_types import SymbolDocEmbedding\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        symbol = Symbol.from_string(symbol_str)\n        \n        document = \"This is a sample document\"\n        vector = np.array([0.1, 0.2, 0.3])\n        source_code = \"class ActionIndicator(Enum): ...\"\n        summary = \"This class represents an enum for action indicators.\"\n        context = \"The ActionIndicator enum is used to describe the current state...\"\n        \n        embedding = SymbolDocEmbedding(symbol, document, vector, source_code=source_code, summary=summary, context=context)\n        ```\n        \n      Class Docstring:\n        Embedding for symbol documents\n        \n      Methods:\n        def __init__(\n                self,\n                symbol: Symbol,\n                document: str,\n                vector: np.array,\n                source_code: Optional[str] = None,\n                summary: Optional[str] = None,\n                context: Optional[str] = None,\n            ):\n                super().__init__(symbol, document, vector)\n                # begin additional meta data\n                self.source_code = source_code\n                self.summary = summary\n                self.context = context\n        \n    automata.core.embedding.embedding_types.EmbeddingProvider\n    \n        `EmbeddingProvider` is an abstract base class that serves as an interface for obtaining mathematical representations called embeddings for symbols, used in tasks such as similarity search, ranking, and other natural language processing-related work. Its single abstract method, `build_embedding`, should be implemented by all subclasses to provide specific embedding implementations. Users must create their own classes that inherit from `EmbeddingProvider` and implement these methods, which might be a limitation for those unfamiliar with custom classes and abstract methods.\n        \n        Here is an example of using the `OpenAIEmbedding` class, a concrete implementation of `EmbeddingProvider`:\n        \n        ```python\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        import numpy as np\n        \n        symbol_source = \"This is an example of a Python function.\"\n        embedding_provider = OpenAIEmbedding() \n        embedding = embedding_provider.build_embedding(symbol_source)\n        \n        # Check if the generated embedding is a numpy array\n        assert isinstance(embedding, np.ndarray)\n        ```\n        Performance and accuracy of embeddings depend on the specific model and approach used in the concrete implementation of `EmbeddingProvider`.\n        \n      Class Docstring:\n        A class to provide embeddings for symbols\n        \n      Methods:\n        build_embedding(self, symbol_source: str) -> np.ndarray\n        \n    automata.tests.unit.conftest.get_sem\n    \n        def get_sem(monkeypatch, temp_output_filename):\n            monkeypatch.setattr(\n                \"automata.core.symbol.symbol_utils.convert_to_fst_object\",\n                lambda args: \"symbol_source\",\n            )\n            return SymbolCodeEmbeddingHandler(temp_output_filename)\n        \n        \n        \n        \n    automata.core.embedding.embedding_types.SymbolEmbeddingHandler\n    \n        `SymbolEmbeddingHandler` is an abstract class that manages symbol embeddings by fetching and updating the vector embeddings related to various kinds of symbols. It must be subclassed by other classes that provide implementations of the defined abstract methods, such as `get_embedding()` and `update_embedding()`. The performance of these methods may depend on the chosen embedding provider and database used for storing the embeddings.\n        \n        Here is an example of how to subclass `SymbolEmbeddingHandler` and implement the abstract methods:\n        \n        ```python\n        from automata.core.embedding.embedding_types import SymbolEmbeddingHandler\n        from automata.core.symbol.symbol_types import Symbol\n        \n        class CustomSymbolEmbeddingHandler(SymbolEmbeddingHandler):\n            def __init__(self, embedding_db, embedding_provider):\n                super().__init__(embedding_db, embedding_provider)\n        \n            def get_embedding(self, symbol: Symbol):\n                # Implement logic to get the embedding for a custom symbol\n                pass\n        \n            def update_embedding(self, symbol: Symbol):\n                # Implement logic to update the embedding for a custom symbol\n                pass\n        \n        # Example usage:\n        custom_handler = CustomSymbolEmbeddingHandler(embedding_db, embedding_provider)\n        custom_embedding = custom_handler.get_embedding(custom_symbol)\n        ```\n        \n      Class Docstring:\n        An abstract class to handle the embedding of symbols\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"An abstract constructor for SymbolEmbeddingHandler\"\"\"\n                self.embedding_db = embedding_db\n                self.embedding_provider = embedding_provider\n        \n            \n        get_embedding(self, symbol: Symbol) -> Any\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n  Building context for dependencies -\n  \n    automata.core.symbol.symbol_types.SymbolEmbedding.__init__\n    \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.symbol_types`/SymbolDescriptor#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.symbol_types", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolDescriptor", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolDescriptor\n\n`SymbolDescriptor` is a class that wraps the descriptor component of the URI into a Python object. It represents different symbols of a URI such as local, namespace, type, method, term, macro, parameter, and type-parameter. The `SymbolDescriptor` class provides methods to convert the descriptor suffix from the URI representation to a Python representation, extract the escaped name from a given string, and represent the object as a URI string.\n\n## Related Symbols\n\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.parser.SymbolParser.parse_descriptor`\n- `automata.core.symbol.parser.SymbolParser.parse_descriptors`\n- `automata.core.symbol.parser.parse_symbol`\n- `automata.core.symbol.symbol_types.Symbol.dotpath`\n- `automata.core.symbol.symbol_types.Symbol.is_local`\n- `automata.core.symbol.symbol_types.Symbol.is_meta`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `SymbolDescriptor` using a name, suffix, and an optional disambiguator.\n\n```python\nfrom automata.core.symbol.symbol_types import SymbolDescriptor\nfrom automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n\nname = \"example_descriptor\"\nsuffix = DescriptorProto.Type\ndisambiguator = \"example_disambiguator\"\n\ndescriptor = SymbolDescriptor(name, suffix, disambiguator)\n```\n\n## Limitations\n\n`SymbolDescriptor` relies on the specific structure of the URI representation and assumes a specific format for the descriptor suffix. As a result, it may not support handling custom URI representations or descriptors that do not follow the predefined format and structure.\n\n## Follow-up Questions:\n\n- Is there a way to update `SymbolDescriptor` to handle custom URI representations or descriptors that do not follow the predefined format?\n- Are there any precautions that need to be taken when using `SymbolDescriptor`, e.g., ensuring a correct format for the descriptor suffix and disambiguator?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 198}, false, {"py/b64": "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"}]}]}, "source_code": "class SymbolDescriptor:\n    \"\"\"\n    Wraps the descriptor component of the URI into a python object\n    \"\"\"\n\n    ScipSuffix = DescriptorProto\n\n    class PyKind(Enum):\n        Local = \"local\"\n        Module = \"module\"\n        Class = \"class\"\n        Method = \"method\"\n        Value = \"value\"\n        Meta = \"meta\"\n        Macro = \"macro\"\n        Parameter = \"parameter\"\n        TypeParameter = \"type_parameter\"\n\n    def __init__(self, name: str, suffix: DescriptorProto, disambiguator: Optional[str] = None):\n        self.name = name\n        self.suffix = suffix\n        self.disambiguator = disambiguator\n\n    def __repr__(self):\n        return f\"Descriptor({self.name}, {self.suffix}\" + (\n            f\", {self.disambiguator})\" if self.disambiguator else \")\"\n        )\n\n    def unparse(self):\n        \"\"\"Converts back into URI string\"\"\"\n        escaped_name = SymbolDescriptor.get_escaped_name(self.name)\n        if self.suffix == SymbolDescriptor.ScipSuffix.Namespace:\n            return f\"{escaped_name}/\"\n        elif self.suffix == SymbolDescriptor.ScipSuffix.Type:\n            return f\"{escaped_name}#\"\n        elif self.suffix == SymbolDescriptor.ScipSuffix.Term:\n            return f\"{escaped_name}.\"\n        elif self.suffix == SymbolDescriptor.ScipSuffix.Meta:\n            return f\"{escaped_name}:\"\n        elif self.suffix == SymbolDescriptor.ScipSuffix.Method:\n            return f\"{escaped_name}({self.disambiguator}).\"\n        elif self.suffix == SymbolDescriptor.ScipSuffix.Parameter:\n            return f\"({escaped_name})\"\n        elif self.suffix == SymbolDescriptor.ScipSuffix.TypeParameter:\n            return f\"[{escaped_name}]\"\n        else:\n            raise ValueError(f\"Invalid descriptor suffix: {self.suffix}\")\n\n    @staticmethod\n    def get_escaped_name(name):\n        def is_simple_identifier(name):\n            return re.match(r\"^[\\w$+-]+$\", name) is not None\n\n        if not name:\n            return \"\"\n        if is_simple_identifier(name):\n            return name\n        return \"`\" + re.sub(\"`\", \"``\", name) + \"`\"\n\n    @staticmethod\n    def convert_scip_to_python_suffix(\n        descriptor_suffix: DescriptorProto,\n    ) -> PyKind:\n        if descriptor_suffix == SymbolDescriptor.ScipSuffix.Local:\n            return SymbolDescriptor.PyKind.Local\n\n        elif descriptor_suffix == SymbolDescriptor.ScipSuffix.Namespace:\n            return SymbolDescriptor.PyKind.Module\n\n        elif descriptor_suffix == SymbolDescriptor.ScipSuffix.Type:\n            return SymbolDescriptor.PyKind.Class\n\n        elif descriptor_suffix == SymbolDescriptor.ScipSuffix.Method:\n            return SymbolDescriptor.PyKind.Method\n\n        elif descriptor_suffix == SymbolDescriptor.ScipSuffix.Term:\n            return SymbolDescriptor.PyKind.Value\n\n        elif descriptor_suffix == SymbolDescriptor.ScipSuffix.Macro:\n            return SymbolDescriptor.PyKind.Macro\n\n        elif descriptor_suffix == SymbolDescriptor.ScipSuffix.Parameter:\n            return SymbolDescriptor.PyKind.Parameter\n\n        elif descriptor_suffix == SymbolDescriptor.ScipSuffix.TypeParameter:\n            return SymbolDescriptor.PyKind.TypeParameter\n\n        else:\n            return SymbolDescriptor.PyKind.Meta\n\n\n", "summary": "`SymbolDescriptor` is a Python class that encapsulates the descriptor component of a URI, representing various URI symbols like local, namespace, type, method, term, macro, parameter, and type-parameter. This class offers methods to convert a descriptor suffix from URI to Python representation, extract an escaped name from a string, and represent the object as a URI string. However, it may not support custom URI representations or descriptors that diverge from the predetermined format. An example of creating a `SymbolDescriptor` instance is shown below:\n```python\nfrom automata.core.symbol.symbol_types import SymbolDescriptor\nfrom automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n\nname = \"example_descriptor\"\nsuffix = DescriptorProto.Type\ndisambiguator = \"example_disambiguator\"\n\ndescriptor = SymbolDescriptor(name, suffix, disambiguator)\n```\n", "context": "\n    Generate the documentation for SymbolDescriptor using the context shown below -\n  Building context for primary symbol - automata.core.symbol.symbol_types.SymbolDescriptor -\n  \n    Import Statements:\n      import abc\n      import re\n      import numpy as np\n      from dataclasses import dataclass\n      from enum import Enum\n      from typing import Any, Dict, Optional, Tuple\n      from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n      from automata.core.symbol.parser import parse_symbol\n      \n      # SymbolDescriptor\n      \n      `SymbolDescriptor` is a class that wraps the descriptor component of the URI into a Python object. It represents different symbols of a URI such as local, namespace, type, method, term, macro, parameter, and type-parameter. The `SymbolDescriptor` class provides methods to convert the descriptor suffix from the URI representation to a Python representation, extract the escaped name from a given string, and represent the object as a URI string.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.parser.SymbolParser.parse_descriptor`\n      - `automata.core.symbol.parser.SymbolParser.parse_descriptors`\n      - `automata.core.symbol.parser.parse_symbol`\n      - `automata.core.symbol.symbol_types.Symbol.dotpath`\n      - `automata.core.symbol.symbol_types.Symbol.is_local`\n      - `automata.core.symbol.symbol_types.Symbol.is_meta`\n      \n      ## Example\n      \n      The following is an example demonstrating how to create an instance of `SymbolDescriptor` using a name, suffix, and an optional disambiguator.\n      \n      ```python\n      from automata.core.symbol.symbol_types import SymbolDescriptor\n      from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n      \n      name = \"example_descriptor\"\n      suffix = DescriptorProto.Type\n      disambiguator = \"example_disambiguator\"\n      \n      descriptor = SymbolDescriptor(name, suffix, disambiguator)\n      ```\n      \n      ## Limitations\n      \n      `SymbolDescriptor` relies on the specific structure of the URI representation and assumes a specific format for the descriptor suffix. As a result, it may not support handling custom URI representations or descriptors that do not follow the predefined format and structure.\n      \n      ## Follow-up Questions:\n      \n      - Is there a way to update `SymbolDescriptor` to handle custom URI representations or descriptors that do not follow the predefined format?\n      - Are there any precautions that need to be taken when using `SymbolDescriptor`, e.g., ensuring a correct format for the descriptor suffix and disambiguator?\n      \n    Class Docstring:\n      Wraps the descriptor component of the URI into a python object\n      \n    Methods:\n      def __init__(self, name: str, suffix: DescriptorProto, disambiguator: Optional[str] = None):\n              self.name = name\n              self.suffix = suffix\n              self.disambiguator = disambiguator\n      \n          \n      def __repr__(self):\n              return f\"Descriptor({self.name}, {self.suffix}\" + (\n                  f\", {self.disambiguator})\" if self.disambiguator else \")\"\n              )\n      \n          \n      @staticmethod\n          def convert_scip_to_python_suffix(\n              descriptor_suffix: DescriptorProto,\n          ) -> PyKind:\n              if descriptor_suffix == SymbolDescriptor.ScipSuffix.Local:\n                  return SymbolDescriptor.PyKind.Local\n      \n              elif descriptor_suffix == SymbolDescriptor.ScipSuffix.Namespace:\n                  return SymbolDescriptor.PyKind.Module\n      \n              elif descriptor_suffix == SymbolDescriptor.ScipSuffix.Type:\n                  return SymbolDescriptor.PyKind.Class\n      \n              elif descriptor_suffix == SymbolDescriptor.ScipSuffix.Method:\n                  return SymbolDescriptor.PyKind.Method\n      \n              elif descriptor_suffix == SymbolDescriptor.ScipSuffix.Term:\n                  return SymbolDescriptor.PyKind.Value\n      \n              elif descriptor_suffix == SymbolDescriptor.ScipSuffix.Macro:\n                  return SymbolDescriptor.PyKind.Macro\n      \n              elif descriptor_suffix == SymbolDescriptor.ScipSuffix.Parameter:\n                  return SymbolDescriptor.PyKind.Parameter\n      \n              elif descriptor_suffix == SymbolDescriptor.ScipSuffix.TypeParameter:\n                  return SymbolDescriptor.PyKind.TypeParameter\n      \n              else:\n                  return SymbolDescriptor.PyKind.Meta\n      \n      \n      \n      @staticmethod\n          def get_escaped_name(name):\n              def is_simple_identifier(name):\n                  return re.match(r\"^[\\w$+-]+$\", name) is not None\n      \n              if not name:\n                  return \"\"\n              if is_simple_identifier(name):\n                  return name\n              return \"`\" + re.sub(\"`\", \"``\", name) + \"`\"\n      \n          \n      def is_simple_identifier(name):\n                  return re.match(r\"^[\\w$+-]+$\", name) is not None\n      \n              \n      def unparse(self):\n              \"\"\"Converts back into URI string\"\"\"\n              escaped_name = SymbolDescriptor.get_escaped_name(self.name)\n              if self.suffix == SymbolDescriptor.ScipSuffix.Namespace:\n                  return f\"{escaped_name}/\"\n              elif self.suffix == SymbolDescriptor.ScipSuffix.Type:\n                  return f\"{escaped_name}#\"\n              elif self.suffix == SymbolDescriptor.ScipSuffix.Term:\n                  return f\"{escaped_name}.\"\n              elif self.suffix == SymbolDescriptor.ScipSuffix.Meta:\n                  return f\"{escaped_name}:\"\n              elif self.suffix == SymbolDescriptor.ScipSuffix.Method:\n                  return f\"{escaped_name}({self.disambiguator}).\"\n              elif self.suffix == SymbolDescriptor.ScipSuffix.Parameter:\n                  return f\"({escaped_name})\"\n              elif self.suffix == SymbolDescriptor.ScipSuffix.TypeParameter:\n                  return f\"[{escaped_name}]\"\n              else:\n                  raise ValueError(f\"Invalid descriptor suffix: {self.suffix}\")\n      \n          \n  Building context for related symbols -\n  \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.symbol.parser.SymbolParser.parse_descriptor\n    \n      Class Docstring:\n        Parse a single descriptor in the symbol\n        \n        Returns:\n        SymbolDescriptor - The descriptor in the symbol\n        \n      Methods:\n        parse_descriptor(self) -> SymbolDescriptor\n        \n    automata.core.symbol.parser.SymbolParser.parse_descriptors\n    \n      Class Docstring:\n        Parse all descriptors in the symbol\n        \n        Returns:\n        List[SymbolDescriptor] - The descriptors in the symbol\n        \n      Methods:\n        parse_descriptors(self) -> List[SymbolDescriptor]\n        \n    automata.core.symbol.parser.parse_symbol\n    \n      Class Docstring:\n        Parses a symbol from a URI\n        \n        Args:\n        symbol_uri (str): The URI of the symbol\n        include_descriptors (bool): Whether to include descriptors in the symbol\n        \n        Returns:\n        Symbol - The parsed symbol\n        \n      Methods:\n        parse_symbol(symbol_uri: str, include_descriptors: bool = True) -> Symbol\n        \n    automata.core.symbol.symbol_types.Symbol.dotpath\n    \n      Class Docstring:\n        Returns the dotpath of the symbol\n        \n      Methods:\n        dotpath(self) -> str\n        \n    automata.core.symbol.symbol_types.SymbolReference\n    \n        `SymbolReference` is a class representing a reference to a symbol in a file, used for managing references to symbols within a codebase. It offers utility methods for comparing and hashing symbol references based on their URI, line number, and column number. In conjunction with other symbol-related classes, it helps track and manage references to symbols in files based on their location and usage. However, there is a potential limitation of causing collisions when the same symbol is referenced in different files at the same location (line and column). This is rare, but important to consider when working with multiple symbol references across files.\n        \n        Example usage: \n        ```python\n        from automata.core.symbol.symbol_types import SymbolReference\n        from automata.core.symbol.parser import parse_symbol\n        \n        symbol_uri = \"example_uri\"\n        line_number = 10\n        column_number = 5\n        symbol = parse_symbol(symbol_uri)\n        \n        symbol_ref1 = SymbolReference(symbol, line_number, column_number)\n        symbol_ref2 = SymbolReference(symbol, line_number + 1, column_number)\n        \n        assert symbol_ref1 != symbol_ref2\n        assert hash(symbol_ref1) != hash(symbol_ref2)\n        \n        symbol_ref3 = SymbolReference(symbol, line_number, column_number)\n        assert symbol_ref1 == symbol_ref3\n        ```\n        \n      Class Docstring:\n        Represents a reference to a symbol in a file\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n    automata.core.symbol.symbol_types.Symbol.is_local\n    \n      Class Docstring:\n        Returns True if the symbol is local\n        \n      Methods:\n        is_local(symbol: \"Symbol\") -> bool\n        \n    automata.core.symbol.graph.SymbolGraph\n    \n        The `SymbolGraph` class represents a symbol graph that captures relationships between symbols found in source code files and is built from an index protobuf file. Utilizing NetworkX's MultiDiGraph, `SymbolGraph` represents relationships as a directed graph and includes methods for querying relationships, obtaining all available symbols and files, and filtering to subgraphs of rankable symbols. A navigator interface, _SymbolGraphNavigator, is required for getting reachable objects in the symbol subgraph.\n        \n        Example usage:\n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        \n        # Replace with your own file path\n        index_path = \"path/to/index.scip\"\n        symbol_graph = SymbolGraph(index_path)\n        all_symbols = symbol_graph.get_all_available_symbols()\n        ```\n        \n        Limitations include only being built from index protobuf files and the `get_potential_symbol_callers` method requiring downstream filtering to remove non-call statements. Future improvements may address these limitations and better handle edge cases in the symbol graph building process.\n        \n      Methods:\n        def __init__(\n                self, index_path: str = DEFAULT_SCIP_PATH, build_caller_relationships: bool = False\n            ):\n                \"\"\"\n                Initializes SymbolGraph with the path of an index protobuf file.\n        \n                Args:\n                    index_path (str): Path to index protobuf file\n                Returns:\n                    SymbolGraph instance\n                \"\"\"\n                index = self._load_index_protobuf(index_path)\n                builder = GraphBuilder(index, build_caller_relationships)\n                self._graph = builder.build_graph()\n                self.navigator = _SymbolGraphNavigator(self._graph)\n        \n            \n        get_all_available_symbols(self) -> List[Symbol]\n        \n        get_all_files(self) -> List[SymbolFile]\n        \n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n        get_rankable_symbol_subgraph(self, flow_rank=\"bidirectional\", path_filter: Optional[str] = None) -> SubGraph\n        \n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n    automata.core.symbol.parser.SymbolParser\n    \n        SymbolParser is a class that enables parsing URIs into structured objects, such as `Symbol`. Although it is not fully in sync with the Go version found in Sourcegraph's SCIP repository, it retains acceptable functionality. The class has methods to accept and parse various parts of symbol strings, including identifiers and namespaces. Limitations include possible difficulties in parsing symbols that the Go version can handle. An example of using the `parse_symbol` function to create a `Symbol` object from a symbol URI string is provided, although future improvements to better handle parsing limitations may be necessary.\n        \n      Class Docstring:\n        Translation of the logic defined in\n        https://github.com/sourcegraph/scip/blob/ee677ba3756cdcdb55b39942b5701f0fde9d69fa/bindings/go/scip/symbol.go\n        to parse URIs into structured objects.\n        It's not great that this implementation is not in hard sync with the Go one, but it's good enough for now.\n        \n      Methods:\n        def __init__(self, symbol: str):\n                \"\"\"\n                Args:\n                    symbol (str): The symbol URI to parse\n                \"\"\"\n                self.symbol = symbol\n                self.index = 0\n                self.symbol_str = symbol\n        \n            \n        accept_backtick_escaped_identifier(self, what: str) -> str\n        \n        accept_character(self, r: str, what: str) -> None\n        \n        accept_escaped_identifier(self, what: str, escape_character: str) -> str\n        \n        accept_identifier(self, what: str) -> str\n        \n        accept_space_escaped_identifier(self, what: str) -> str\n        \n        current(self) -> str\n        \n        error(self, message: str) -> ValueError\n        \n        is_identifier_character(c: str) -> bool\n        \n        parse_descriptor(self) -> SymbolDescriptor\n        \n        parse_descriptors(self) -> List[SymbolDescriptor]\n        \n        peek_next(self) -> Optional[str]\n        \n    automata.core.symbol.symbol_types.Symbol.is_meta\n    \n      Class Docstring:\n        Returns True if the symbol is meta\n        \n      Methods:\n        is_meta(symbol: \"Symbol\") -> bool\n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.symbol_types`/SymbolDescriptor#PyKind#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.symbol_types", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolDescriptor", "suffix": 2, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "PyKind", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolDescriptor\n\n`SymbolDescriptor` is a class that wraps the descriptor component of the URI into a Python object. It serves as a building block for creating and parsing symbols within the `automata.core.symbol` framework. Additionally, it provides methods for working with descriptor components, such as converting descriptor suffixes and unparsing descriptor objects.\n\n## Related Symbols\n\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.parser.SymbolParser`\n- `automata.core.symbol.parser.parse_symbol`\n- `automata.core.symbol.symbol_types.SymbolReference`\n- `automata.core.symbol.graph.SymbolGraph`\n\n## Example\n\nThe following example demonstrates how to create a `SymbolDescriptor` instance:\n\n```python\nfrom automata.core.symbol.symbol_types import SymbolDescriptor\nfrom automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n\ndescriptor = SymbolDescriptor(\n    name=\"ActionIndicator\",\n    suffix=DescriptorProto.TYPE,\n)\n```\n\n## Methods\n\n- `__init__(self, name: str, suffix: DescriptorProto, disambiguator: Optional[str] = None)`: Initializes a `SymbolDescriptor` instance with the given `name`, `suffix`, and an optional `disambiguator`.\n- `__repr__(self) -> None`: Represents the `SymbolDescriptor` as a string.\n- `convert_scip_to_python_suffix(descriptor_suffix: DescriptorProto) -> PyKind`: Converts a descriptor suffix from the `DescriptorProto` format to the `PyKind` format.\n- `get_escaped_name(name) -> None`: Escapes a string name with backticks.\n- `is_simple_identifier(name) -> None`: Determines if the given name is a simple identifier or not.\n- `unparse(self) -> None`: Unparses the `SymbolDescriptor` instance into a string.\n\n## Limitations\n\n`SymbolDescriptor` is closely tied to the `automata.core.symbol` framework and assumes a specific syntax and representation for descriptor components. If the underlying descriptor format or parser implementation changes, updates to `SymbolDescriptor` may be necessary.\n\n## Follow-up Questions:\n\n- How does the `SymbolDescriptor` interact with other parts of the `automata.core.symbol` framework?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/reduce": [{"py/type": "numpy.dtype"}, {"py/tuple": ["f8", false, true]}, {"py/tuple": [3, "<", null, null, null, -1, -1, 0]}]}, false, {"py/b64": "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"}]}]}, "source_code": "class PyKind(Enum):\n        Local = \"local\"\n        Module = \"module\"\n        Class = \"class\"\n        Method = \"method\"\n        Value = \"value\"\n        Meta = \"meta\"\n        Macro = \"macro\"\n        Parameter = \"parameter\"\n        TypeParameter = \"type_parameter\"\n\n    ", "summary": "`SymbolDescriptor` is a class within the `automata.core.symbol` framework that wraps the descriptor component of a URI into a Python object. It is a building block for creating and parsing symbols and provides methods for working with descriptor components, such as converting descriptor suffixes and unparsing descriptor objects. It is closely tied to the framework and may require updates if the underlying descriptor format or parser implementation changes.\n\nExample of creating a `SymbolDescriptor` instance:\n```python\nfrom automata.core.symbol.symbol_types import SymbolDescriptor\nfrom automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n\ndescriptor = SymbolDescriptor(\n    name=\"ActionIndicator\",\n    suffix=DescriptorProto.TYPE,\n)\n```", "context": "\n    Generate the documentation for SymbolDescriptor using the context shown below -\n  Building context for primary symbol - automata.core.symbol.symbol_types.SymbolDescriptor.PyKind -\n  \n    Import Statements:\n      import abc\n      import re\n      import numpy as np\n      from dataclasses import dataclass\n      from enum import Enum\n      from typing import Any, Dict, Optional, Tuple\n      from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n      from automata.core.symbol.parser import parse_symbol\n      \n      # SymbolDescriptor\n      \n      `SymbolDescriptor` is a class that wraps the descriptor component of the URI into a Python object. It serves as a building block for creating and parsing symbols within the `automata.core.symbol` framework. Additionally, it provides methods for working with descriptor components, such as converting descriptor suffixes and unparsing descriptor objects.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.parser.SymbolParser`\n      - `automata.core.symbol.parser.parse_symbol`\n      - `automata.core.symbol.symbol_types.SymbolReference`\n      - `automata.core.symbol.graph.SymbolGraph`\n      \n      ## Example\n      \n      The following example demonstrates how to create a `SymbolDescriptor` instance:\n      \n      ```python\n      from automata.core.symbol.symbol_types import SymbolDescriptor\n      from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n      \n      descriptor = SymbolDescriptor(\n          name=\"ActionIndicator\",\n          suffix=DescriptorProto.TYPE,\n      )\n      ```\n      \n      ## Methods\n      \n      - `__init__(self, name: str, suffix: DescriptorProto, disambiguator: Optional[str] = None)`: Initializes a `SymbolDescriptor` instance with the given `name`, `suffix`, and an optional `disambiguator`.\n      - `__repr__(self) -> None`: Represents the `SymbolDescriptor` as a string.\n      - `convert_scip_to_python_suffix(descriptor_suffix: DescriptorProto) -> PyKind`: Converts a descriptor suffix from the `DescriptorProto` format to the `PyKind` format.\n      - `get_escaped_name(name) -> None`: Escapes a string name with backticks.\n      - `is_simple_identifier(name) -> None`: Determines if the given name is a simple identifier or not.\n      - `unparse(self) -> None`: Unparses the `SymbolDescriptor` instance into a string.\n      \n      ## Limitations\n      \n      `SymbolDescriptor` is closely tied to the `automata.core.symbol` framework and assumes a specific syntax and representation for descriptor components. If the underlying descriptor format or parser implementation changes, updates to `SymbolDescriptor` may be necessary.\n      \n      ## Follow-up Questions:\n      \n      - How does the `SymbolDescriptor` interact with other parts of the `automata.core.symbol` framework?\n      \n  Building context for related symbols -\n  \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.symbol.symbol_types.SymbolDescriptor\n    \n        `SymbolDescriptor` is a Python class that wraps the descriptor component of a Universal Resource Identifier (URI) and represents various symbols such as local, namespace, type, method, term, macro, parameter, and type-parameter. It provides methods to convert the descriptor suffix from the URI representation to a Python representation, extract the escaped name from a string, and represent the object as a URI string. However, it may not support custom URI representations or descriptors that do not follow the predefined format and structure. For example, an instance of `SymbolDescriptor` can be created using a name, suffix, and an optional disambiguator like this:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolDescriptor\n        from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n        \n        name = \"example_descriptor\"\n        suffix = DescriptorProto.Type\n        disambiguator = \"example_disambiguator\"\n        \n        descriptor = SymbolDescriptor(name, suffix, disambiguator)\n        ```\n        \n        Follow-up questions include exploring ways to update `SymbolDescriptor` to handle custom URI representations or descriptors that do not follow the predefined format and understanding any precautions that need to be taken when using `SymbolDescriptor`.\n        \n      Class Docstring:\n        Wraps the descriptor component of the URI into a python object\n        \n      Methods:\n        def __init__(self, name: str, suffix: DescriptorProto, disambiguator: Optional[str] = None):\n                self.name = name\n                self.suffix = suffix\n                self.disambiguator = disambiguator\n        \n            \n        __repr__(self) -> None\n        \n        convert_scip_to_python_suffix(descriptor_suffix: DescriptorProto,\n            ) -> PyKind\n        \n        get_escaped_name(name) -> None\n        \n        is_simple_identifier(name) -> None\n        \n        unparse(self) -> None\n        \n    automata.core.symbol.symbol_types.SymbolDescriptor.__repr__\n    \n      Methods:\n        __repr__(self) -> None\n        \n    automata.core.symbol.parser.SymbolParser.parse_descriptor\n    \n      Class Docstring:\n        Parse a single descriptor in the symbol\n        \n        Returns:\n        SymbolDescriptor - The descriptor in the symbol\n        \n      Methods:\n        parse_descriptor(self) -> SymbolDescriptor\n        \n    automata.core.symbol.parser.SymbolParser.parse_descriptors\n    \n      Class Docstring:\n        Parse all descriptors in the symbol\n        \n        Returns:\n        List[SymbolDescriptor] - The descriptors in the symbol\n        \n      Methods:\n        parse_descriptors(self) -> List[SymbolDescriptor]\n        \n    automata.core.symbol.symbol_types.Symbol.dotpath\n    \n      Class Docstring:\n        Returns the dotpath of the symbol\n        \n      Methods:\n        dotpath(self) -> str\n        \n    automata.core.symbol.symbol_types.SymbolReference\n    \n        `SymbolReference` is a class representing a reference to a symbol in a file, used for managing references to symbols within a codebase. It offers utility methods for comparing and hashing symbol references based on their URI, line number, and column number. In conjunction with other symbol-related classes, it helps track and manage references to symbols in files based on their location and usage. However, there is a potential limitation of causing collisions when the same symbol is referenced in different files at the same location (line and column). This is rare, but important to consider when working with multiple symbol references across files.\n        \n        Example usage: \n        ```python\n        from automata.core.symbol.symbol_types import SymbolReference\n        from automata.core.symbol.parser import parse_symbol\n        \n        symbol_uri = \"example_uri\"\n        line_number = 10\n        column_number = 5\n        symbol = parse_symbol(symbol_uri)\n        \n        symbol_ref1 = SymbolReference(symbol, line_number, column_number)\n        symbol_ref2 = SymbolReference(symbol, line_number + 1, column_number)\n        \n        assert symbol_ref1 != symbol_ref2\n        assert hash(symbol_ref1) != hash(symbol_ref2)\n        \n        symbol_ref3 = SymbolReference(symbol, line_number, column_number)\n        assert symbol_ref1 == symbol_ref3\n        ```\n        \n      Class Docstring:\n        Represents a reference to a symbol in a file\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n    automata.core.symbol.parser.parse_symbol\n    \n      Class Docstring:\n        Parses a symbol from a URI\n        \n        Args:\n        symbol_uri (str): The URI of the symbol\n        include_descriptors (bool): Whether to include descriptors in the symbol\n        \n        Returns:\n        Symbol - The parsed symbol\n        \n      Methods:\n        parse_symbol(symbol_uri: str, include_descriptors: bool = True) -> Symbol\n        \n    automata.core.symbol.symbol_types.Symbol.is_local\n    \n      Class Docstring:\n        Returns True if the symbol is local\n        \n      Methods:\n        is_local(symbol: \"Symbol\") -> bool\n        \n    automata.core.symbol.symbol_types.SymbolDescriptor.convert_scip_to_python_suffix\n    \n      Methods:\n        convert_scip_to_python_suffix(descriptor_suffix: DescriptorProto,\n            ) -> PyKind\n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.symbol_types`/SymbolDocEmbedding#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.symbol_types", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolDocEmbedding", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolDocEmbedding\n\n`SymbolDocEmbedding` is a class that represents the embedding for symbol documents. It extends the `SymbolEmbedding` class and adds additional metadata such as the source code, summary, and context of the symbol.\n\n## Overview\n\n`SymbolDocEmbedding` provides a way to store and access the embeddings for symbol documents, which are important for tasks like search and similarity comparison. The class is used in conjunction with `SymbolDocEmbeddingHandler` to create, update, and retrieve embeddings for a given symbol.\n\n## Related Symbols\n\n- `Symbol`: A class representing the primary symbol URI, which can be a class, method, or a local variable.\n- `SymbolDocEmbeddingHandler`: A handler class to manage `SymbolDocEmbedding` objects, providing methods to create, update, and retrieve embeddings.\n- `SymbolCodeEmbedding`: A class representing the embeddings for symbol code.\n- `SymbolCodeEmbeddingHandler`: A handler class to manage `SymbolCodeEmbedding` objects, providing methods to create, update, and retrieve embeddings.\n\n## Example\n\nThe following example demonstrates how to create an instance of `SymbolDocEmbedding`.\n\n```python\nimport numpy as np\nfrom automata.core.symbol.symbol_types import Symbol\nfrom automata.core.symbol.symbol_types import SymbolDocEmbedding\n\nsymbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\nsymbol = Symbol.from_string(symbol_str)\n\ndocument = \"This is a sample document\"\nvector = np.array([0.1, 0.2, 0.3])\nsource_code = \"class ActionIndicator(Enum): ...\"\nsummary = \"This class represents an enum for action indicators.\"\ncontext = \"The ActionIndicator enum is used to describe the current state...\"\n\nembedding = SymbolDocEmbedding(symbol, document, vector, source_code=source_code, summary=summary, context=context)\n```\n\n## Limitations\n\n`SymbolDocEmbedding` relies on external handler classes like `SymbolDocEmbeddingHandler` for proper creation, updating, and retrieval of embeddings. Moreover, it assumes the embeddings are provided as NumPy arrays, which may limit the usage of other types of embeddings.\n\n## Follow-up Questions:\n\n- Can the `SymbolDocEmbedding` class be extended to support different types of embeddings, other than NumPy arrays?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 248}, false, {"py/b64": "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"}]}]}, "source_code": "class SymbolDocEmbedding(SymbolEmbedding):\n    \"\"\"Embedding for symbol documents\"\"\"\n\n    def __init__(\n        self,\n        symbol: Symbol,\n        document: str,\n        vector: np.array,\n        source_code: Optional[str] = None,\n        summary: Optional[str] = None,\n        context: Optional[str] = None,\n    ):\n        super().__init__(symbol, document, vector)\n        # begin additional meta data\n        self.source_code = source_code\n        self.summary = summary\n        self.context = context\n", "summary": "`SymbolDocEmbedding` is a class representing the embedding for symbol documents, extending the `SymbolEmbedding` class and adding metadata such as source code, summary, and context. It is used for tasks like search and similarity comparison and works with `SymbolDocEmbeddingHandler` to create, update, and retrieve embeddings for a symbol. It relies on handler classes like `SymbolDocEmbeddingHandler` and assumes embeddings are provided as NumPy arrays, potentially limiting usage with other types of embeddings.\n\nExample usage:\n```python\nimport numpy as np\nfrom automata.core.symbol.symbol_types import Symbol\nfrom automata.core.symbol.symbol_types import SymbolDocEmbedding\n\nsymbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\nsymbol = Symbol.from_string(symbol_str)\n\ndocument = \"This is a sample document\"\nvector = np.array([0.1, 0.2, 0.3])\nsource_code = \"class ActionIndicator(Enum): ...\"\nsummary = \"This class represents an enum for action indicators.\"\ncontext = \"The ActionIndicator enum is used to describe the current state...\"\n\nembedding = SymbolDocEmbedding(symbol, document, vector, source_code=source_code, summary=summary, context=context)\n```", "context": "\n    Generate the documentation for SymbolDocEmbedding using the context shown below -\n  Building context for primary symbol - automata.core.symbol.symbol_types.SymbolDocEmbedding -\n  \n    Import Statements:\n      import abc\n      import re\n      import numpy as np\n      from dataclasses import dataclass\n      from enum import Enum\n      from typing import Any, Dict, Optional, Tuple\n      from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n      from automata.core.symbol.parser import parse_symbol\n      \n      # SymbolDocEmbedding\n      \n      `SymbolDocEmbedding` is a class that represents the embedding for symbol documents. It extends the `SymbolEmbedding` class and adds additional metadata such as the source code, summary, and context of the symbol.\n      \n      ## Overview\n      \n      `SymbolDocEmbedding` provides a way to store and access the embeddings for symbol documents, which are important for tasks like search and similarity comparison. The class is used in conjunction with `SymbolDocEmbeddingHandler` to create, update, and retrieve embeddings for a given symbol.\n      \n      ## Related Symbols\n      \n      - `Symbol`: A class representing the primary symbol URI, which can be a class, method, or a local variable.\n      - `SymbolDocEmbeddingHandler`: A handler class to manage `SymbolDocEmbedding` objects, providing methods to create, update, and retrieve embeddings.\n      - `SymbolCodeEmbedding`: A class representing the embeddings for symbol code.\n      - `SymbolCodeEmbeddingHandler`: A handler class to manage `SymbolCodeEmbedding` objects, providing methods to create, update, and retrieve embeddings.\n      \n      ## Example\n      \n      The following example demonstrates how to create an instance of `SymbolDocEmbedding`.\n      \n      ```python\n      import numpy as np\n      from automata.core.symbol.symbol_types import Symbol\n      from automata.core.symbol.symbol_types import SymbolDocEmbedding\n      \n      symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n      symbol = Symbol.from_string(symbol_str)\n      \n      document = \"This is a sample document\"\n      vector = np.array([0.1, 0.2, 0.3])\n      source_code = \"class ActionIndicator(Enum): ...\"\n      summary = \"This class represents an enum for action indicators.\"\n      context = \"The ActionIndicator enum is used to describe the current state...\"\n      \n      embedding = SymbolDocEmbedding(symbol, document, vector, source_code=source_code, summary=summary, context=context)\n      ```\n      \n      ## Limitations\n      \n      `SymbolDocEmbedding` relies on external handler classes like `SymbolDocEmbeddingHandler` for proper creation, updating, and retrieval of embeddings. Moreover, it assumes the embeddings are provided as NumPy arrays, which may limit the usage of other types of embeddings.\n      \n      ## Follow-up Questions:\n      \n      - Can the `SymbolDocEmbedding` class be extended to support different types of embeddings, other than NumPy arrays?\n      \n      \n    Class Docstring:\n      Embedding for symbol documents\n      \n    Methods:\n      def __init__(\n              self,\n              symbol: Symbol,\n              document: str,\n              vector: np.array,\n              source_code: Optional[str] = None,\n              summary: Optional[str] = None,\n              context: Optional[str] = None,\n          ):\n              super().__init__(symbol, document, vector)\n              # begin additional meta data\n              self.source_code = source_code\n              self.summary = summary\n              self.context = context\n      \n  Building context for related symbols -\n  \n    automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler\n    \n        The `SymbolDocEmbeddingHandler` class is responsible for generating, storing, and managing document embeddings for symbols in an AutomataDocs project. It relies on the `VectorDatabaseProvider`, `EmbeddingProvider` classes, and uses methods like `build_symbol_doc_embedding`, `update_embedding`, `get_embedding`, `get_doc`, and `get_summary` for managing symbol document embeddings and their summaries. The class utilizes various other components like `SymbolGraph`, `SymbolSimilarity`, and `SymbolRankConfig` to search, rank, and generate context for symbol embeddings. However, it has limitations concerning the embedding models and algorithms used and can sometimes produce suboptimal context or examples. Improving the underlying components can potentially enhance the embedding quality.\n        \n        Example usage:\n        \n        ```python\n        from automata.core.embedding.doc_embedding import SymbolDocEmbeddingHandler\n        from automata.core.database.vector import JSONVectorDatabase, VectorDatabaseProvider\n        from automata.core.embedding.embedding_types import OpenAIEmbedding, EmbeddingProvider\n        from automata.core.symbol.symbol_types import Symbol\n        \n        # Initialize the database provider and embedding provider\n        db_provider = VectorDatabaseProvider(JSONVectorDatabase(\"path/to/symbol_doc_embedding.json\"))\n        embedding_provider = EmbeddingProvider(OpenAIEmbedding())\n        \n        # Create an instance of SymbolDocEmbeddingHandler\n        embedding_handler = SymbolDocEmbeddingHandler(db_provider, embedding_provider)\n        \n        # Example symbol and source code\n        symbol = Symbol.from_string(\"symbol-uri-as-string\")\n        source_code = \"def example_function():\\n    pass\"\n        \n        # Build the symbol document embedding\n        symbol_doc_embedding = embedding_handler.build_symbol_doc_embedding(source_code, symbol)\n        ```\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n                code_embedding_handler: SymbolCodeEmbeddingHandler,\n                embedding_db_l2: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                A constructor for SymbolDocEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (EmbeddingProvider): The provider to get the embeddings from\n                    code_embedding_handler (SymbolCodeEmbeddingHandler): The code embedding handler\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n                from automata.core.embedding.symbol_similarity import SymbolSimilarity\n                from automata.core.symbol.search.rank import SymbolRankConfig\n                from automata.core.symbol.search.symbol_search import SymbolSearch\n        \n                graph = SymbolGraph()\n                subgraph = graph.get_rankable_symbol_subgraph()\n                symbol_similarity = SymbolSimilarity(code_embedding_handler)\n                self.graph = graph\n                self.symbol_search = SymbolSearch(\n                    graph, symbol_similarity, symbol_rank_config=SymbolRankConfig(), code_subgraph=subgraph\n                )\n                self.embedding_db_l2 = embedding_db_l2\n        \n            \n        build_symbol_doc_embedding(self, source_code: str, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_doc(prompt: str) -> str\n        \n        get_embedding(self, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_summary(input_doc: str) -> str\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.core.symbol.symbol_types.SymbolEmbedding\n    \n        SymbolEmbedding is an abstract base class used to represent various symbol embeddings, such as SymbolCodeEmbedding and SymbolDocEmbedding. It provides a basic structure for initializing and managing these embeddings, taking into account their source and their vector representation in the feature space. SymbolEmbedding is utilized by different embedding handlers like SymbolCodeEmbeddingHandler and SymbolDocEmbeddingHandler. As a base class, its functionality is limited and should be extended by classes with specific embedding types. An example of creating a SymbolCodeEmbedding instance is shown below:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def __init__(self, message): pass\"\n        vector = np.array([0.1, 0.2, 0.3])\n        \n        symbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Abstract base class for different types of embeddings\n        \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n    automata.tests.unit.sample_modules.sample.OuterClass.InnerClass\n    \n        class InnerClass:\n                \"\"\"Inner doc strings\"\"\"\n        \n                def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.tests.unit.sample_modules.sample.OuterClass\n    \n        class OuterClass:\n            class InnerClass:\n                \"\"\"Inner doc strings\"\"\"\n        \n                def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler.build_symbol_doc_embedding\n    \n      Class Docstring:\n        Build the embedding for a symbol's documentation\n        \n        Args:\n        source_code (str): The source code of the symbol\n        symbol (Symbol): The symbol to build the embedding for\n        \n        Returns:\n        SymbolDocEmbedding: The embedding for the symbol's documentation\n        \n      Methods:\n        build_symbol_doc_embedding(self, source_code: str, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_doc(prompt: str) -> str\n        \n        get_summary(input_doc: str) -> str\n        \n    automata.tests.unit.sample_modules.sample.OuterClass.InnerClass.inner_method\n    \n        def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.core.symbol.symbol_types.SymbolCodeEmbedding\n    \n        `SymbolCodeEmbedding` is a class extending the `SymbolEmbedding` base class, used to store code embeddings for a given symbol, the symbol object, source code, and the embedding vector. It primarily serves as a container for these embeddings and does not include functionality for generating or handling them; `SymbolCodeEmbeddingHandler` should be used for those purposes.\n        \n        Here's an example of creating a `SymbolCodeEmbedding` instance:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def example_function():\\n    pass\"\n        vector = np.random.random((300,))\n        \n        embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Embedding for symbol code\n        \n      Methods:\n        def __init__(self, symbol: Symbol, source_code: str, vector: np.array):\n                super().__init__(symbol, source_code, vector)\n        \n        \n        \n    automata.core.embedding.embedding_types.EmbeddingProvider\n    \n        `EmbeddingProvider` is an abstract base class that serves as an interface for obtaining mathematical representations called embeddings for symbols, used in tasks such as similarity search, ranking, and other natural language processing-related work. Its single abstract method, `build_embedding`, should be implemented by all subclasses to provide specific embedding implementations. Users must create their own classes that inherit from `EmbeddingProvider` and implement these methods, which might be a limitation for those unfamiliar with custom classes and abstract methods.\n        \n        Here is an example of using the `OpenAIEmbedding` class, a concrete implementation of `EmbeddingProvider`:\n        \n        ```python\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        import numpy as np\n        \n        symbol_source = \"This is an example of a Python function.\"\n        embedding_provider = OpenAIEmbedding() \n        embedding = embedding_provider.build_embedding(symbol_source)\n        \n        # Check if the generated embedding is a numpy array\n        assert isinstance(embedding, np.ndarray)\n        ```\n        Performance and accuracy of embeddings depend on the specific model and approach used in the concrete implementation of `EmbeddingProvider`.\n        \n      Class Docstring:\n        A class to provide embeddings for symbols\n        \n      Methods:\n        build_embedding(self, symbol_source: str) -> np.ndarray\n        \n  Building context for dependencies -\n  \n    automata.core.symbol.symbol_types.SymbolEmbedding.__init__\n    \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.symbol_types`/SymbolEmbedding#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.symbol_types", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolEmbedding", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolEmbedding\n\n`SymbolEmbedding` is an abstract base class for different types of embeddings representing symbols, such as `SymbolCodeEmbedding` and `SymbolDocEmbedding`. It provides a basic structure for initializing and managing symbol embeddings, considering the source of the embedding and the vector representing the embedding in the feature space. `SymbolEmbedding` is used in various embedding handlers, such as `SymbolCodeEmbeddingHandler` and `SymbolDocEmbeddingHandler`.\n\n## Related Symbols\n\n- `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.symbol_types.SymbolDocEmbedding`\n- `automata.core.symbol.symbol_types.SymbolCodeEmbedding`\n- `automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler`\n- `automata.core.embedding.embedding_types.EmbeddingProvider`\n- `automata.core.embedding.embedding_types.SymbolEmbeddingHandler`\n- `automata.core.database.vector.JSONVectorDatabase`\n\n## Example\n\nThe following example demonstrates how to create an instance of a derived class `SymbolCodeEmbedding`:\n\n```python\nfrom automata.core.symbol.symbol_types import SymbolCodeEmbedding\nfrom automata.core.symbol.parser import parse_symbol\nimport numpy as np\n\nsymbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\nsymbol = parse_symbol(symbol_str)\nsource_code = \"def __init__(self, message): pass\"\nvector = np.array([0.1, 0.2, 0.3])\n\nsymbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n```\n\n## Limitations\n\n`SymbolEmbedding` serves as a base class to be extended by classes with specific embedding types, like `SymbolCodeEmbedding` or `SymbolDocEmbedding`. So, the functionality provided by `SymbolEmbedding` is limited to its role as a base class.\n\n## Follow-up Questions:\n\n- Are there more concrete classes derived from `SymbolEmbedding` other than `SymbolCodeEmbedding` and `SymbolDocEmbedding`?\n- How are the embedding vectors for `SymbolEmbedding` instances usually generated?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 248}, false, {"py/b64": "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"}]}]}, "source_code": "class SymbolEmbedding(abc.ABC):\n    \"\"\"Abstract base class for different types of embeddings\"\"\"\n\n    def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n        self.symbol = symbol\n        self.embedding_source = embedding_source\n        self.vector = vector\n\n\n", "summary": "`SymbolEmbedding` is an abstract base class for various types of embeddings representing symbols, such as `SymbolCodeEmbedding` and `SymbolDocEmbedding`. This class provides a basic structure for initializing and managing symbol embeddings, focusing on the source of the embedding and the vector representing it in the feature space. `SymbolEmbedding` is utilized in numerous embedding handlers, including `SymbolCodeEmbeddingHandler` and `SymbolDocEmbeddingHandler`.\n\nTo create an instance of a derived class like `SymbolCodeEmbedding`, you can use the example code provided:\n```python\nfrom automata.core.symbol.symbol_types import SymbolCodeEmbedding\nfrom automata.core.symbol.parser import parse_symbol\nimport numpy as np\n\nsymbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\nsymbol = parse_symbol(symbol_str)\nsource_code = \"def __init__(self, message): pass\"\nvector = np.array([0.1, 0.2, 0.3])\n\nsymbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n```\nRemember that the functionality of `SymbolEmbedding` is limited as it serves as a base class for more specific embedding types.", "context": "\n    Generate the documentation for SymbolEmbedding using the context shown below -\n  Building context for primary symbol - automata.core.symbol.symbol_types.SymbolEmbedding -\n  \n    Import Statements:\n      import abc\n      import re\n      import numpy as np\n      from dataclasses import dataclass\n      from enum import Enum\n      from typing import Any, Dict, Optional, Tuple\n      from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n      from automata.core.symbol.parser import parse_symbol\n      \n      # SymbolEmbedding\n      \n      `SymbolEmbedding` is an abstract base class for different types of embeddings representing symbols, such as `SymbolCodeEmbedding` and `SymbolDocEmbedding`. It provides a basic structure for initializing and managing symbol embeddings, considering the source of the embedding and the vector representing the embedding in the feature space. `SymbolEmbedding` is used in various embedding handlers, such as `SymbolCodeEmbeddingHandler` and `SymbolDocEmbeddingHandler`.\n      \n      ## Related Symbols\n      \n      - `automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.symbol_types.SymbolDocEmbedding`\n      - `automata.core.symbol.symbol_types.SymbolCodeEmbedding`\n      - `automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler`\n      - `automata.core.embedding.embedding_types.EmbeddingProvider`\n      - `automata.core.embedding.embedding_types.SymbolEmbeddingHandler`\n      - `automata.core.database.vector.JSONVectorDatabase`\n      \n      ## Example\n      \n      The following example demonstrates how to create an instance of a derived class `SymbolCodeEmbedding`:\n      \n      ```python\n      from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n      from automata.core.symbol.parser import parse_symbol\n      import numpy as np\n      \n      symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n      symbol = parse_symbol(symbol_str)\n      source_code = \"def __init__(self, message): pass\"\n      vector = np.array([0.1, 0.2, 0.3])\n      \n      symbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n      ```\n      \n      ## Limitations\n      \n      `SymbolEmbedding` serves as a base class to be extended by classes with specific embedding types, like `SymbolCodeEmbedding` or `SymbolDocEmbedding`. So, the functionality provided by `SymbolEmbedding` is limited to its role as a base class.\n      \n      ## Follow-up Questions:\n      \n      - Are there more concrete classes derived from `SymbolEmbedding` other than `SymbolCodeEmbedding` and `SymbolDocEmbedding`?\n      - How are the embedding vectors for `SymbolEmbedding` instances usually generated?\n      \n    Class Docstring:\n      Abstract base class for different types of embeddings\n      \n    Methods:\n      def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n              self.symbol = symbol\n              self.embedding_source = embedding_source\n              self.vector = vector\n      \n      \n      \n  Building context for related symbols -\n  \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.symbol.symbol_types.SymbolDocEmbedding\n    \n        `SymbolDocEmbedding` is a class representing the embedding for symbol documents, extending the `SymbolEmbedding` class with added metadata such as source code, summary, and context. This class is utilized alongside `SymbolDocEmbeddingHandler` to manage and access these embeddings for tasks like search and similarity comparison. However, it relies on external handler classes and assumes embeddings are provided as NumPy arrays, potentially limiting usage for other embedding types.\n        \n        ```python\n        import numpy as np\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.symbol.symbol_types import SymbolDocEmbedding\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        symbol = Symbol.from_string(symbol_str)\n        \n        document = \"This is a sample document\"\n        vector = np.array([0.1, 0.2, 0.3])\n        source_code = \"class ActionIndicator(Enum): ...\"\n        summary = \"This class represents an enum for action indicators.\"\n        context = \"The ActionIndicator enum is used to describe the current state...\"\n        \n        embedding = SymbolDocEmbedding(symbol, document, vector, source_code=source_code, summary=summary, context=context)\n        ```\n        \n      Class Docstring:\n        Embedding for symbol documents\n        \n      Methods:\n        def __init__(\n                self,\n                symbol: Symbol,\n                document: str,\n                vector: np.array,\n                source_code: Optional[str] = None,\n                summary: Optional[str] = None,\n                context: Optional[str] = None,\n            ):\n                super().__init__(symbol, document, vector)\n                # begin additional meta data\n                self.source_code = source_code\n                self.summary = summary\n                self.context = context\n        \n    automata.core.symbol.symbol_types.SymbolCodeEmbedding\n    \n        `SymbolCodeEmbedding` is a class extending the `SymbolEmbedding` base class, used to store code embeddings for a given symbol, the symbol object, source code, and the embedding vector. It primarily serves as a container for these embeddings and does not include functionality for generating or handling them; `SymbolCodeEmbeddingHandler` should be used for those purposes.\n        \n        Here's an example of creating a `SymbolCodeEmbedding` instance:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def example_function():\\n    pass\"\n        vector = np.random.random((300,))\n        \n        embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Embedding for symbol code\n        \n      Methods:\n        def __init__(self, symbol: Symbol, source_code: str, vector: np.array):\n                super().__init__(symbol, source_code, vector)\n        \n        \n        \n    automata.core.embedding.doc_embedding.SymbolDocEmbeddingHandler\n    \n        The `SymbolDocEmbeddingHandler` class is responsible for generating, storing, and managing document embeddings for symbols in an AutomataDocs project. It relies on the `VectorDatabaseProvider`, `EmbeddingProvider` classes, and uses methods like `build_symbol_doc_embedding`, `update_embedding`, `get_embedding`, `get_doc`, and `get_summary` for managing symbol document embeddings and their summaries. The class utilizes various other components like `SymbolGraph`, `SymbolSimilarity`, and `SymbolRankConfig` to search, rank, and generate context for symbol embeddings. However, it has limitations concerning the embedding models and algorithms used and can sometimes produce suboptimal context or examples. Improving the underlying components can potentially enhance the embedding quality.\n        \n        Example usage:\n        \n        ```python\n        from automata.core.embedding.doc_embedding import SymbolDocEmbeddingHandler\n        from automata.core.database.vector import JSONVectorDatabase, VectorDatabaseProvider\n        from automata.core.embedding.embedding_types import OpenAIEmbedding, EmbeddingProvider\n        from automata.core.symbol.symbol_types import Symbol\n        \n        # Initialize the database provider and embedding provider\n        db_provider = VectorDatabaseProvider(JSONVectorDatabase(\"path/to/symbol_doc_embedding.json\"))\n        embedding_provider = EmbeddingProvider(OpenAIEmbedding())\n        \n        # Create an instance of SymbolDocEmbeddingHandler\n        embedding_handler = SymbolDocEmbeddingHandler(db_provider, embedding_provider)\n        \n        # Example symbol and source code\n        symbol = Symbol.from_string(\"symbol-uri-as-string\")\n        source_code = \"def example_function():\\n    pass\"\n        \n        # Build the symbol document embedding\n        symbol_doc_embedding = embedding_handler.build_symbol_doc_embedding(source_code, symbol)\n        ```\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n                code_embedding_handler: SymbolCodeEmbeddingHandler,\n                embedding_db_l2: Optional[VectorDatabaseProvider] = None,\n            ):\n                \"\"\"\n                A constructor for SymbolDocEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (EmbeddingProvider): The provider to get the embeddings from\n                    code_embedding_handler (SymbolCodeEmbeddingHandler): The code embedding handler\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n                from automata.core.embedding.symbol_similarity import SymbolSimilarity\n                from automata.core.symbol.search.rank import SymbolRankConfig\n                from automata.core.symbol.search.symbol_search import SymbolSearch\n        \n                graph = SymbolGraph()\n                subgraph = graph.get_rankable_symbol_subgraph()\n                symbol_similarity = SymbolSimilarity(code_embedding_handler)\n                self.graph = graph\n                self.symbol_search = SymbolSearch(\n                    graph, symbol_similarity, symbol_rank_config=SymbolRankConfig(), code_subgraph=subgraph\n                )\n                self.embedding_db_l2 = embedding_db_l2\n        \n            \n        build_symbol_doc_embedding(self, source_code: str, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_doc(prompt: str) -> str\n        \n        get_embedding(self, symbol: Symbol) -> SymbolDocEmbedding\n        \n        get_summary(input_doc: str) -> str\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n    automata.core.embedding.embedding_types.EmbeddingProvider\n    \n        `EmbeddingProvider` is an abstract base class that serves as an interface for obtaining mathematical representations called embeddings for symbols, used in tasks such as similarity search, ranking, and other natural language processing-related work. Its single abstract method, `build_embedding`, should be implemented by all subclasses to provide specific embedding implementations. Users must create their own classes that inherit from `EmbeddingProvider` and implement these methods, which might be a limitation for those unfamiliar with custom classes and abstract methods.\n        \n        Here is an example of using the `OpenAIEmbedding` class, a concrete implementation of `EmbeddingProvider`:\n        \n        ```python\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        import numpy as np\n        \n        symbol_source = \"This is an example of a Python function.\"\n        embedding_provider = OpenAIEmbedding() \n        embedding = embedding_provider.build_embedding(symbol_source)\n        \n        # Check if the generated embedding is a numpy array\n        assert isinstance(embedding, np.ndarray)\n        ```\n        Performance and accuracy of embeddings depend on the specific model and approach used in the concrete implementation of `EmbeddingProvider`.\n        \n      Class Docstring:\n        A class to provide embeddings for symbols\n        \n      Methods:\n        build_embedding(self, symbol_source: str) -> np.ndarray\n        \n    automata.core.embedding.embedding_types.SymbolEmbeddingHandler\n    \n        `SymbolEmbeddingHandler` is an abstract class that manages symbol embeddings by fetching and updating the vector embeddings related to various kinds of symbols. It must be subclassed by other classes that provide implementations of the defined abstract methods, such as `get_embedding()` and `update_embedding()`. The performance of these methods may depend on the chosen embedding provider and database used for storing the embeddings.\n        \n        Here is an example of how to subclass `SymbolEmbeddingHandler` and implement the abstract methods:\n        \n        ```python\n        from automata.core.embedding.embedding_types import SymbolEmbeddingHandler\n        from automata.core.symbol.symbol_types import Symbol\n        \n        class CustomSymbolEmbeddingHandler(SymbolEmbeddingHandler):\n            def __init__(self, embedding_db, embedding_provider):\n                super().__init__(embedding_db, embedding_provider)\n        \n            def get_embedding(self, symbol: Symbol):\n                # Implement logic to get the embedding for a custom symbol\n                pass\n        \n            def update_embedding(self, symbol: Symbol):\n                # Implement logic to update the embedding for a custom symbol\n                pass\n        \n        # Example usage:\n        custom_handler = CustomSymbolEmbeddingHandler(embedding_db, embedding_provider)\n        custom_embedding = custom_handler.get_embedding(custom_symbol)\n        ```\n        \n      Class Docstring:\n        An abstract class to handle the embedding of symbols\n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"An abstract constructor for SymbolEmbeddingHandler\"\"\"\n                self.embedding_db = embedding_db\n                self.embedding_provider = embedding_provider\n        \n            \n        get_embedding(self, symbol: Symbol) -> Any\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.tests.unit.test_symbol_embedding.test_get_embedding\n    \n        def test_get_embedding(\n            monkeypatch,\n            mock_embedding,\n            mock_simple_method_symbols,\n        ):\n            # Mock EmbeddingProvider methods\n            mock_provider = Mock(EmbeddingProvider)\n            mock_provider.build_embedding.return_value = mock_embedding\n        \n            # Mock JSONVectorDatabase methods\n            mock_db = MagicMock(JSONVectorDatabase)\n            mock_db.get.return_value = SymbolCodeEmbedding(\n                mock_simple_method_symbols[0], \"symbol_source\", mock_embedding\n            )\n        \n            # Create an instance of the class\n            cem = SymbolCodeEmbeddingHandler(embedding_provider=mock_provider, embedding_db=mock_db)\n        \n            # Call the method\n            embedding = cem.get_embedding(mock_simple_method_symbols[0])\n        \n            # Verify the results\n            assert embedding.vector.all() == mock_embedding.all()\n        \n        \n        \n        \n    automata.tests.unit.conftest.patch_get_embedding\n    \n        def patch_get_embedding(monkeypatch, mock_embedding):\n            # Define the behavior of the mock build_embedding function\n            mock_get_embedding = Mock(return_value=mock_embedding)\n            monkeypatch.setattr(\"openai.embeddings_utils.get_embedding\", mock_get_embedding)\n        \n        \n        \n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.symbol_types`/SymbolFile#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.symbol_types", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolFile", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolFile\n\n`SymbolFile` is a class that represents a file that contains a symbol. It provides methods to perform equality checks and hashing operations on a file. This class is primarily used within the `SymbolGraph` to represent files containing symbols.\n\n## Related Symbols\n\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.graph.SymbolGraph`\n- `automata.core.symbol.symbol_types.SymbolReference`\n\n## Example\n\nThe following example demonstrates how to use the `SymbolFile` class to create an instance of a file containing a symbol and compare it with another instance.\n\n```python\nfrom automata.core.symbol.symbol_types import SymbolFile\n\nfile_1 = SymbolFile(\"path/to/symbol/file\")\nfile_2 = SymbolFile(\"path/to/symbol/file\")\n\n# Comparing SymbolFile instances\nassert file_1 == file_2\n\n# Comparing SymbolFile instance with a string representing the path\nassert file_1 == \"path/to/symbol/file\"\n```\n\n## Limitations\n\n`SymbolFile` is a simple class and focuses on providing a way to represent files containing symbols. It does not provide methods to modify the file or access the symbol within the file.\n\n## Follow-up Questions:\n\n- What is the process to access the symbol within a `SymbolFile` instance?\n\n## Class\n\nRepresents a file that contains a symbol\n\n### Methods\n\n`__eq__(self, other)`: Checks the equality of the SymbolFile with other SymbolFiles and strings representing paths.\n\n`__hash__(self) -> int`: Returns the hash value of the SymbolFile, based on its path.", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 248}, false, {"py/b64": "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"}]}]}, "source_code": "@dataclass\nclass SymbolFile:\n    \"\"\"Represents a file that contains a symbol\"\"\"\n\n    path: str\n    occurrences: str\n\n    def __hash__(self) -> int:\n        return hash(self.path)\n\n    def __eq__(self, other):\n        if isinstance(other, SymbolFile):\n            return self.path == other.path\n        elif isinstance(other, str):\n            return self.path == other\n        return False\n\n\n", "summary": "The `SymbolFile` class represents a file containing a symbol and is primarily used within the `SymbolGraph`. It offers methods for equality checks and hashing operations but does not provide methods to modify the file or access the symbol within the file. To create an instance and compare it with another, use:\n\n```python\nfrom automata.core.symbol.symbol_types import SymbolFile\n\nfile_1 = SymbolFile(\"path/to/symbol/file\")\nfile_2 = SymbolFile(\"path/to/symbol/file\")\n\nassert file_1 == file_2\nassert file_1 == \"path/to/symbol/file\"\n```", "context": "\n    Generate the documentation for SymbolFile using the context shown below -\n  Building context for primary symbol - automata.core.symbol.symbol_types.SymbolFile -\n  \n    Import Statements:\n      import abc\n      import re\n      import numpy as np\n      from dataclasses import dataclass\n      from enum import Enum\n      from typing import Any, Dict, Optional, Tuple\n      from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n      from automata.core.symbol.parser import parse_symbol\n      \n      # SymbolFile\n      \n      `SymbolFile` is a class that represents a file that contains a symbol. It provides methods to perform equality checks and hashing operations on a file. This class is primarily used within the `SymbolGraph` to represent files containing symbols.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.graph.SymbolGraph`\n      - `automata.core.symbol.symbol_types.SymbolReference`\n      \n      ## Example\n      \n      The following example demonstrates how to use the `SymbolFile` class to create an instance of a file containing a symbol and compare it with another instance.\n      \n      ```python\n      from automata.core.symbol.symbol_types import SymbolFile\n      \n      file_1 = SymbolFile(\"path/to/symbol/file\")\n      file_2 = SymbolFile(\"path/to/symbol/file\")\n      \n      # Comparing SymbolFile instances\n      assert file_1 == file_2\n      \n      # Comparing SymbolFile instance with a string representing the path\n      assert file_1 == \"path/to/symbol/file\"\n      ```\n      \n      ## Limitations\n      \n      `SymbolFile` is a simple class and focuses on providing a way to represent files containing symbols. It does not provide methods to modify the file or access the symbol within the file.\n      \n      ## Follow-up Questions:\n      \n      - What is the process to access the symbol within a `SymbolFile` instance?\n      \n    Class Docstring:\n      Represents a file that contains a symbol\n      \n    Methods:\n      def __eq__(self, other):\n              if isinstance(other, SymbolFile):\n                  return self.path == other.path\n              elif isinstance(other, str):\n                  return self.path == other\n              return False\n      \n      \n      \n      def __hash__(self) -> int:\n              return hash(self.path)\n      \n          \n  Building context for related symbols -\n  \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.symbol.symbol_types.SymbolReference\n    \n        `SymbolReference` is a class representing a reference to a symbol in a file, used for managing references to symbols within a codebase. It offers utility methods for comparing and hashing symbol references based on their URI, line number, and column number. In conjunction with other symbol-related classes, it helps track and manage references to symbols in files based on their location and usage. However, there is a potential limitation of causing collisions when the same symbol is referenced in different files at the same location (line and column). This is rare, but important to consider when working with multiple symbol references across files.\n        \n        Example usage: \n        ```python\n        from automata.core.symbol.symbol_types import SymbolReference\n        from automata.core.symbol.parser import parse_symbol\n        \n        symbol_uri = \"example_uri\"\n        line_number = 10\n        column_number = 5\n        symbol = parse_symbol(symbol_uri)\n        \n        symbol_ref1 = SymbolReference(symbol, line_number, column_number)\n        symbol_ref2 = SymbolReference(symbol, line_number + 1, column_number)\n        \n        assert symbol_ref1 != symbol_ref2\n        assert hash(symbol_ref1) != hash(symbol_ref2)\n        \n        symbol_ref3 = SymbolReference(symbol, line_number, column_number)\n        assert symbol_ref1 == symbol_ref3\n        ```\n        \n      Class Docstring:\n        Represents a reference to a symbol in a file\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n    automata.tests.unit.test_symbol_graph.test_get_all_files\n    \n        def test_get_all_files(symbol_graph):\n            files = symbol_graph.get_all_files()\n            assert isinstance(files, list)\n            for f in files:\n                assert isinstance(f, SymbolFile)\n        \n        \n        \n        \n    automata.core.symbol.graph.SymbolGraph\n    \n        The `SymbolGraph` class represents a symbol graph that captures relationships between symbols found in source code files and is built from an index protobuf file. Utilizing NetworkX's MultiDiGraph, `SymbolGraph` represents relationships as a directed graph and includes methods for querying relationships, obtaining all available symbols and files, and filtering to subgraphs of rankable symbols. A navigator interface, _SymbolGraphNavigator, is required for getting reachable objects in the symbol subgraph.\n        \n        Example usage:\n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        \n        # Replace with your own file path\n        index_path = \"path/to/index.scip\"\n        symbol_graph = SymbolGraph(index_path)\n        all_symbols = symbol_graph.get_all_available_symbols()\n        ```\n        \n        Limitations include only being built from index protobuf files and the `get_potential_symbol_callers` method requiring downstream filtering to remove non-call statements. Future improvements may address these limitations and better handle edge cases in the symbol graph building process.\n        \n      Methods:\n        def __init__(\n                self, index_path: str = DEFAULT_SCIP_PATH, build_caller_relationships: bool = False\n            ):\n                \"\"\"\n                Initializes SymbolGraph with the path of an index protobuf file.\n        \n                Args:\n                    index_path (str): Path to index protobuf file\n                Returns:\n                    SymbolGraph instance\n                \"\"\"\n                index = self._load_index_protobuf(index_path)\n                builder = GraphBuilder(index, build_caller_relationships)\n                self._graph = builder.build_graph()\n                self.navigator = _SymbolGraphNavigator(self._graph)\n        \n            \n        get_all_available_symbols(self) -> List[Symbol]\n        \n        get_all_files(self) -> List[SymbolFile]\n        \n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n        get_rankable_symbol_subgraph(self, flow_rank=\"bidirectional\", path_filter: Optional[str] = None) -> SubGraph\n        \n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.tests.unit.test_database_vector.test_lookup_symbol\n    \n        def test_lookup_symbol(temp_output_filename, symbols):\n            vector_db = JSONVectorDatabase(temp_output_filename)\n            embedded_symbol_0 = SymbolEmbedding(symbols[0], \"x\", [1, 2, 3])\n            vector_db.add(embedded_symbol_0)\n            embedded_symbol_1 = SymbolEmbedding(symbols[1], \"y\", [1, 2, 3, 4])\n            vector_db.add(embedded_symbol_1)\n        \n            vector_db.get(symbols[0])\n        \n        \n        \n        \n    automata.tests.unit.conftest.get_sem\n    \n        def get_sem(monkeypatch, temp_output_filename):\n            monkeypatch.setattr(\n                \"automata.core.symbol.symbol_utils.convert_to_fst_object\",\n                lambda args: \"symbol_source\",\n            )\n            return SymbolCodeEmbeddingHandler(temp_output_filename)\n        \n        \n        \n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.tests.unit.test_database_vector.test_add_symbol\n    \n        def test_add_symbol(temp_output_filename, symbols):\n            vector_db = JSONVectorDatabase(temp_output_filename)\n            symbol = symbols[0]\n            embedded_symbol = SymbolEmbedding(symbol, \"x\", [1, 2, 3])\n            vector_db.add(embedded_symbol)\n        \n        \n        \n        \n    automata.tests.unit.test_symbol_search.test_retrieve_source_code_by_symbol\n    \n        def test_retrieve_source_code_by_symbol(symbols, symbol_searcher):\n            with patch(\n                \"automata.core.symbol.search.symbol_search.convert_to_fst_object\",\n                return_value=\"module1\",\n            ) as mock_method:\n                result = symbol_searcher.retrieve_source_code_by_symbol(symbols[0].uri)\n                assert result == \"module1\"\n            mock_method.assert_called_once_with(symbols[0])\n        \n        \n        \n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.symbol_types`/SymbolPackage#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.symbol_types", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolPackage", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolPackage\n\n`SymbolPackage` is a class that wraps the package component of the URI. It helps manage and handle packages in the context of symbols, which are like URIs identifying a class, method, or a local variable.\n\n## Overview\n\nThe `SymbolPackage` class consists of utility methods to work with packages in the context of a `Symbol`. It provides methods to unparse a package into a URI string and get the string representation of the package.\n\n## Related Symbols\n\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.parser.parse_symbol`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `SymbolPackage` and unparse it into a URI string.\n\n```python\nfrom automata.core.symbol.symbol_types import SymbolPackage\n\nexample_package = SymbolPackage(manager=\"python\", name=\"automata\", version=\"75482692a6fe30c72db516201a6f47d9fb4af065\")\nprint(repr(example_package))  # Output: Package(python automata 75482692a6fe30c72db516201a6f47d9fb4af065)\n```\n\n```python\nunparsed_package = example_package.unparse()\nprint(unparsed_package)  # Output: python automata 75482692a6fe30c72db516201a6f47d9fb4af065\n```\n\n## Limitations\n\n`SymbolPackage` is limited in its functionality and mainly serves as an abstraction of the package component of a symbol URI. It does not provide any advanced features for package management or manipulation beyond its primary functionalities of unparsing a package into a URI string and obtaining its string representation.\n\n## Follow-up Questions:\n\n- Are there any additional methods or features that would be useful to include in the `SymbolPackage` class?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 248}, false, {"py/b64": "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"}]}]}, "source_code": "@dataclass\nclass SymbolPackage:\n    \"\"\"Wraps the package component of the URI\"\"\"\n\n    manager: str\n    name: str\n    version: str\n\n    def __repr__(self):\n        return f\"Package({self.unparse()})\"\n\n    def unparse(self):\n        \"\"\"Converts back into URI string\"\"\"\n        return f\"{self.manager} {self.name} {self.version}\"\n\n\n", "summary": "The `SymbolPackage` class, within the context of symbols (URIs identifying a class, method, or local variable), helps manage and handle packages. It contains utility methods for working with packages, offering functionality to unparse a package into a URI string and obtain the package's string representation. However, `SymbolPackage` is limited in its functionality, mainly serving as an abstraction of the package component of a symbol URI and does not provide advanced features for package management or manipulation. Here is an example of using `SymbolPackage`:\n\n```python\nfrom automata.core.symbol.symbol_types import SymbolPackage\n\nexample_package = SymbolPackage(manager=\"python\", name=\"automata\", version=\"75482692a6fe30c72db516201a6f47d9fb4af065\")\nprint(repr(example_package))\n\nunparsed_package = example_package.unparse()\nprint(unparsed_package)\n```", "context": "\n    Generate the documentation for SymbolPackage using the context shown below -\n  Building context for primary symbol - automata.core.symbol.symbol_types.SymbolPackage -\n  \n    Import Statements:\n      import abc\n      import re\n      import numpy as np\n      from dataclasses import dataclass\n      from enum import Enum\n      from typing import Any, Dict, Optional, Tuple\n      from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n      from automata.core.symbol.parser import parse_symbol\n      \n      # SymbolPackage\n      \n      `SymbolPackage` is a class that wraps the package component of the URI. It helps manage and handle packages in the context of symbols, which are like URIs identifying a class, method, or a local variable.\n      \n      ## Overview\n      \n      The `SymbolPackage` class consists of utility methods to work with packages in the context of a `Symbol`. It provides methods to unparse a package into a URI string and get the string representation of the package.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.parser.parse_symbol`\n      \n      ## Example\n      \n      The following is an example demonstrating how to create an instance of `SymbolPackage` and unparse it into a URI string.\n      \n      ```python\n      from automata.core.symbol.symbol_types import SymbolPackage\n      \n      example_package = SymbolPackage(manager=\"python\", name=\"automata\", version=\"75482692a6fe30c72db516201a6f47d9fb4af065\")\n      print(repr(example_package))  # Output: Package(python automata 75482692a6fe30c72db516201a6f47d9fb4af065)\n      ```\n      \n      ```python\n      unparsed_package = example_package.unparse()\n      print(unparsed_package)  # Output: python automata 75482692a6fe30c72db516201a6f47d9fb4af065\n      ```\n      \n      ## Limitations\n      \n      `SymbolPackage` is limited in its functionality and mainly serves as an abstraction of the package component of a symbol URI. It does not provide any advanced features for package management or manipulation beyond its primary functionalities of unparsing a package into a URI string and obtaining its string representation.\n      \n      ## Follow-up Questions:\n      \n      - Are there any additional methods or features that would be useful to include in the `SymbolPackage` class?\n      \n      \n    Class Docstring:\n      Wraps the package component of the URI\n      \n    Methods:\n      def __repr__(self):\n              return f\"Package({self.unparse()})\"\n      \n          \n      def unparse(self):\n              \"\"\"Converts back into URI string\"\"\"\n              return f\"{self.manager} {self.name} {self.version}\"\n      \n      \n      \n  Building context for related symbols -\n  \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_symbol_parser.test_parse_symbol\n    \n        def test_parse_symbol(symbols):\n            for symbol in symbols:\n                assert symbol.scheme == \"scip-python\"\n                assert symbol.package.manager == \"python\"\n                assert symbol.package.name == \"automata\"\n                assert symbol.package.version == \"75482692a6fe30c72db516201a6f47d9fb4af065\"\n                assert len(symbol.descriptors) > 0\n        \n        \n        \n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.tests.unit.conftest.get_sem\n    \n        def get_sem(monkeypatch, temp_output_filename):\n            monkeypatch.setattr(\n                \"automata.core.symbol.symbol_utils.convert_to_fst_object\",\n                lambda args: \"symbol_source\",\n            )\n            return SymbolCodeEmbeddingHandler(temp_output_filename)\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample.EmptyClass\n    \n        class EmptyClass:\n            pass\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.SymbolDescriptor\n    \n        `SymbolDescriptor` is a Python class that wraps the descriptor component of a Universal Resource Identifier (URI) and represents various symbols such as local, namespace, type, method, term, macro, parameter, and type-parameter. It provides methods to convert the descriptor suffix from the URI representation to a Python representation, extract the escaped name from a string, and represent the object as a URI string. However, it may not support custom URI representations or descriptors that do not follow the predefined format and structure. For example, an instance of `SymbolDescriptor` can be created using a name, suffix, and an optional disambiguator like this:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolDescriptor\n        from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n        \n        name = \"example_descriptor\"\n        suffix = DescriptorProto.Type\n        disambiguator = \"example_disambiguator\"\n        \n        descriptor = SymbolDescriptor(name, suffix, disambiguator)\n        ```\n        \n        Follow-up questions include exploring ways to update `SymbolDescriptor` to handle custom URI representations or descriptors that do not follow the predefined format and understanding any precautions that need to be taken when using `SymbolDescriptor`.\n        \n      Class Docstring:\n        Wraps the descriptor component of the URI into a python object\n        \n      Methods:\n        def __init__(self, name: str, suffix: DescriptorProto, disambiguator: Optional[str] = None):\n                self.name = name\n                self.suffix = suffix\n                self.disambiguator = disambiguator\n        \n            \n        __repr__(self) -> None\n        \n        convert_scip_to_python_suffix(descriptor_suffix: DescriptorProto,\n            ) -> PyKind\n        \n        get_escaped_name(name) -> None\n        \n        is_simple_identifier(name) -> None\n        \n        unparse(self) -> None\n        \n    automata.core.symbol.parser.parse_symbol\n    \n      Class Docstring:\n        Parses a symbol from a URI\n        \n        Args:\n        symbol_uri (str): The URI of the symbol\n        include_descriptors (bool): Whether to include descriptors in the symbol\n        \n        Returns:\n        Symbol - The parsed symbol\n        \n      Methods:\n        parse_symbol(symbol_uri: str, include_descriptors: bool = True) -> Symbol\n        \n    automata.core.symbol.symbol_types.SymbolEmbedding\n    \n        SymbolEmbedding is an abstract base class used to represent various symbol embeddings, such as SymbolCodeEmbedding and SymbolDocEmbedding. It provides a basic structure for initializing and managing these embeddings, taking into account their source and their vector representation in the feature space. SymbolEmbedding is utilized by different embedding handlers like SymbolCodeEmbeddingHandler and SymbolDocEmbeddingHandler. As a base class, its functionality is limited and should be extended by classes with specific embedding types. An example of creating a SymbolCodeEmbedding instance is shown below:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def __init__(self, message): pass\"\n        vector = np.array([0.1, 0.2, 0.3])\n        \n        symbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Abstract base class for different types of embeddings\n        \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.symbol.symbol_types`/SymbolReference#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.symbol.symbol_types", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "SymbolReference", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# SymbolReference\n\n`SymbolReference` is a class that represents a reference to a symbol in a file. It is used for tracking and managing references to symbols within a codebase. It provides utility methods for comparing and hashing symbol references based on their URI, line number, and column number. This class is used in conjunction with other classes related to symbols, such as `Symbol`, `SymbolDescriptor`, and `SymbolEmbedding`.\n\n## Overview\n\nA `SymbolReference` object represents a unique reference to a symbol based on its URI, line number, and column number. It provides methods to check for equality and uniqueness with other symbol references. It is useful in tracking and managing references to symbols in files based on their location and use in the codebase.\n\n## Related Symbols\n\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.symbol.parser.parse_symbol`\n- `automata.core.symbol.symbol_types.SymbolDescriptor`\n- `automata.core.symbol.symbol_types.SymbolEmbedding`\n- `automata.core.symbol.graph.SymbolGraph`\n\n## Example\n\nThe following example demonstrates how to create an instance of `SymbolReference` and compare it with other symbol references.\n\n```python\nfrom automata.core.symbol.symbol_types import SymbolReference\nfrom automata.core.symbol.parser import parse_symbol\n\nsymbol_uri = \"example_uri\"\nline_number = 10\ncolumn_number = 5\nsymbol = parse_symbol(symbol_uri)\n\nsymbol_ref1 = SymbolReference(symbol, line_number, column_number)\nsymbol_ref2 = SymbolReference(symbol, line_number + 1, column_number)\n\nassert symbol_ref1 != symbol_ref2\nassert hash(symbol_ref1) != hash(symbol_ref2)\n\nsymbol_ref3 = SymbolReference(symbol, line_number, column_number)\nassert symbol_ref1 == symbol_ref3\n```\n\n## Limitations\n\nThe primary limitation of `SymbolReference` is that it could cause collisions when the same symbol is referenced in different files at the same location (line and column). This situation is relatively rare, but it is worth noting as a potential limitation when working with a large number of symbol references across multiple files.\n\n## Follow-up Questions:\n\n- Is there any way to mitigate the collision issue while maintaining the utility methods provided by `SymbolReference`?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 248}, false, {"py/b64": "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"}]}]}, "source_code": "@dataclass\nclass SymbolReference:\n    \"\"\"Represents a reference to a symbol in a file\"\"\"\n\n    symbol: Symbol\n    line_number: int\n    column_number: int\n    roles: Dict[str, Any]\n\n    def __hash__(self) -> int:\n        # This could cause collisions if the same symbol is referenced in different files at the same location\n        return hash(f\"{self.symbol.uri}-{self.line_number}-{self.column_number}\")\n\n    def __eq__(self, other):\n        if isinstance(other, SymbolReference):\n            return (\n                f\"{self.symbol.uri}-{self.line_number}-{self.column_number}\"\n                == f\"{other.symbol.uri}-{other.line_number}-{other.column_number}\"\n            )\n        return False\n\n\n", "summary": "`SymbolReference` is a class representing a reference to a symbol in a file, used for tracking and managing symbol references within a codebase. It provides methods for comparing and hashing symbol references based on their URI, line number, and column number. This class works in conjunction with other related classes such as `Symbol`, `SymbolDescriptor`, and `SymbolEmbedding`. However, a limitation is that it may cause collisions when the same symbol is referenced in different files at the same location, although this issue is relatively rare. The example below demonstrates creating an instance of `SymbolReference` and comparing it with other symbol references.\n\n```python\nfrom automata.core.symbol.symbol_types import SymbolReference\nfrom automata.core.symbol.parser import parse_symbol\n\nsymbol_uri = \"example_uri\"\nline_number = 10\ncolumn_number = 5\nsymbol = parse_symbol(symbol_uri)\n\nsymbol_ref1 = SymbolReference(symbol, line_number, column_number)\nsymbol_ref2 = SymbolReference(symbol, line_number + 1, column_number)\n\nassert symbol_ref1 != symbol_ref2\nassert hash(symbol_ref1) != hash(symbol_ref2)\n\nsymbol_ref3 = SymbolReference(symbol, line_number, column_number)\nassert symbol_ref1 == symbol_ref3\n```", "context": "\n    Generate the documentation for SymbolReference using the context shown below -\n  Building context for primary symbol - automata.core.symbol.symbol_types.SymbolReference -\n  \n    Import Statements:\n      import abc\n      import re\n      import numpy as np\n      from dataclasses import dataclass\n      from enum import Enum\n      from typing import Any, Dict, Optional, Tuple\n      from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n      from automata.core.symbol.parser import parse_symbol\n      \n      # SymbolReference\n      \n      `SymbolReference` is a class that represents a reference to a symbol in a file. It is used for tracking and managing references to symbols within a codebase. It provides utility methods for comparing and hashing symbol references based on their URI, line number, and column number. This class is used in conjunction with other classes related to symbols, such as `Symbol`, `SymbolDescriptor`, and `SymbolEmbedding`.\n      \n      ## Overview\n      \n      A `SymbolReference` object represents a unique reference to a symbol based on its URI, line number, and column number. It provides methods to check for equality and uniqueness with other symbol references. It is useful in tracking and managing references to symbols in files based on their location and use in the codebase.\n      \n      ## Related Symbols\n      \n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.symbol.parser.parse_symbol`\n      - `automata.core.symbol.symbol_types.SymbolDescriptor`\n      - `automata.core.symbol.symbol_types.SymbolEmbedding`\n      - `automata.core.symbol.graph.SymbolGraph`\n      \n      ## Example\n      \n      The following example demonstrates how to create an instance of `SymbolReference` and compare it with other symbol references.\n      \n      ```python\n      from automata.core.symbol.symbol_types import SymbolReference\n      from automata.core.symbol.parser import parse_symbol\n      \n      symbol_uri = \"example_uri\"\n      line_number = 10\n      column_number = 5\n      symbol = parse_symbol(symbol_uri)\n      \n      symbol_ref1 = SymbolReference(symbol, line_number, column_number)\n      symbol_ref2 = SymbolReference(symbol, line_number + 1, column_number)\n      \n      assert symbol_ref1 != symbol_ref2\n      assert hash(symbol_ref1) != hash(symbol_ref2)\n      \n      symbol_ref3 = SymbolReference(symbol, line_number, column_number)\n      assert symbol_ref1 == symbol_ref3\n      ```\n      \n      ## Limitations\n      \n      The primary limitation of `SymbolReference` is that it could cause collisions when the same symbol is referenced in different files at the same location (line and column). This situation is relatively rare, but it is worth noting as a potential limitation when working with a large number of symbol references across multiple files.\n      \n      ## Follow-up Questions:\n      \n      - Is there any way to mitigate the collision issue while maintaining the utility methods provided by `SymbolReference`?\n      \n    Class Docstring:\n      Represents a reference to a symbol in a file\n      \n    Methods:\n      def __eq__(self, other):\n              if isinstance(other, SymbolReference):\n                  return (\n                      f\"{self.symbol.uri}-{self.line_number}-{self.column_number}\"\n                      == f\"{other.symbol.uri}-{other.line_number}-{other.column_number}\"\n                  )\n              return False\n      \n      \n      \n      def __hash__(self) -> int:\n              # This could cause collisions if the same symbol is referenced in different files at the same location\n              return hash(f\"{self.symbol.uri}-{self.line_number}-{self.column_number}\")\n      \n          \n  Building context for related symbols -\n  \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_symbol_search.test_symbol_references\n    \n        def test_symbol_references(symbols, symbol_searcher, symbol_graph_mock):\n            symbol_graph_mock.get_references_to_symbol.return_value = [\"ref1\", \"ref2\"]\n            result = symbol_searcher.symbol_references(symbols[0].uri)\n            assert result == [\"ref1\", \"ref2\"]\n            symbol_graph_mock.get_references_to_symbol.assert_called_once_with(\n                parse_symbol(symbols[0].uri)\n            )\n        \n        \n        \n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.core.symbol.graph.SymbolGraph\n    \n        The `SymbolGraph` class represents a symbol graph that captures relationships between symbols found in source code files and is built from an index protobuf file. Utilizing NetworkX's MultiDiGraph, `SymbolGraph` represents relationships as a directed graph and includes methods for querying relationships, obtaining all available symbols and files, and filtering to subgraphs of rankable symbols. A navigator interface, _SymbolGraphNavigator, is required for getting reachable objects in the symbol subgraph.\n        \n        Example usage:\n        ```python\n        from automata.core.symbol.graph import SymbolGraph\n        \n        # Replace with your own file path\n        index_path = \"path/to/index.scip\"\n        symbol_graph = SymbolGraph(index_path)\n        all_symbols = symbol_graph.get_all_available_symbols()\n        ```\n        \n        Limitations include only being built from index protobuf files and the `get_potential_symbol_callers` method requiring downstream filtering to remove non-call statements. Future improvements may address these limitations and better handle edge cases in the symbol graph building process.\n        \n      Methods:\n        def __init__(\n                self, index_path: str = DEFAULT_SCIP_PATH, build_caller_relationships: bool = False\n            ):\n                \"\"\"\n                Initializes SymbolGraph with the path of an index protobuf file.\n        \n                Args:\n                    index_path (str): Path to index protobuf file\n                Returns:\n                    SymbolGraph instance\n                \"\"\"\n                index = self._load_index_protobuf(index_path)\n                builder = GraphBuilder(index, build_caller_relationships)\n                self._graph = builder.build_graph()\n                self.navigator = _SymbolGraphNavigator(self._graph)\n        \n            \n        get_all_available_symbols(self) -> List[Symbol]\n        \n        get_all_files(self) -> List[SymbolFile]\n        \n        get_potential_symbol_callees(self, symbol: Symbol) -> Dict[Symbol, SymbolReference]\n        \n        get_potential_symbol_callers(self, symbol: Symbol) -> Dict[SymbolReference, Symbol]\n        \n        get_rankable_symbol_subgraph(self, flow_rank=\"bidirectional\", path_filter: Optional[str] = None) -> SubGraph\n        \n        get_references_to_symbol(self, symbol: Symbol) -> Dict[str, List[SymbolReference]]\n        \n        get_symbol_dependencies(self, symbol: Symbol) -> Set[Symbol]\n        \n        get_symbol_relationships(self, symbol: Symbol) -> Set[Symbol]\n        \n    automata.core.symbol.symbol_types.SymbolEmbedding\n    \n        SymbolEmbedding is an abstract base class used to represent various symbol embeddings, such as SymbolCodeEmbedding and SymbolDocEmbedding. It provides a basic structure for initializing and managing these embeddings, taking into account their source and their vector representation in the feature space. SymbolEmbedding is utilized by different embedding handlers like SymbolCodeEmbeddingHandler and SymbolDocEmbeddingHandler. As a base class, its functionality is limited and should be extended by classes with specific embedding types. An example of creating a SymbolCodeEmbedding instance is shown below:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def __init__(self, message): pass\"\n        vector = np.array([0.1, 0.2, 0.3])\n        \n        symbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Abstract base class for different types of embeddings\n        \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n    automata.core.symbol.symbol_types.SymbolDescriptor\n    \n        `SymbolDescriptor` is a Python class that wraps the descriptor component of a Universal Resource Identifier (URI) and represents various symbols such as local, namespace, type, method, term, macro, parameter, and type-parameter. It provides methods to convert the descriptor suffix from the URI representation to a Python representation, extract the escaped name from a string, and represent the object as a URI string. However, it may not support custom URI representations or descriptors that do not follow the predefined format and structure. For example, an instance of `SymbolDescriptor` can be created using a name, suffix, and an optional disambiguator like this:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolDescriptor\n        from automata.core.symbol.scip_pb2 import Descriptor as DescriptorProto\n        \n        name = \"example_descriptor\"\n        suffix = DescriptorProto.Type\n        disambiguator = \"example_disambiguator\"\n        \n        descriptor = SymbolDescriptor(name, suffix, disambiguator)\n        ```\n        \n        Follow-up questions include exploring ways to update `SymbolDescriptor` to handle custom URI representations or descriptors that do not follow the predefined format and understanding any precautions that need to be taken when using `SymbolDescriptor`.\n        \n      Class Docstring:\n        Wraps the descriptor component of the URI into a python object\n        \n      Methods:\n        def __init__(self, name: str, suffix: DescriptorProto, disambiguator: Optional[str] = None):\n                self.name = name\n                self.suffix = suffix\n                self.disambiguator = disambiguator\n        \n            \n        __repr__(self) -> None\n        \n        convert_scip_to_python_suffix(descriptor_suffix: DescriptorProto,\n            ) -> PyKind\n        \n        get_escaped_name(name) -> None\n        \n        is_simple_identifier(name) -> None\n        \n        unparse(self) -> None\n        \n    automata.core.symbol.parser.parse_symbol\n    \n      Class Docstring:\n        Parses a symbol from a URI\n        \n        Args:\n        symbol_uri (str): The URI of the symbol\n        include_descriptors (bool): Whether to include descriptors in the symbol\n        \n        Returns:\n        Symbol - The parsed symbol\n        \n      Methods:\n        parse_symbol(symbol_uri: str, include_descriptors: bool = True) -> Symbol\n        \n    automata.core.symbol.graph._SymbolGraphNavigator._get_symbol_references_in_scope\n    \n      Class Docstring:\n        Gets all symbol references in the scope of a symbol\n        \n        Args:\n        symbol (Symbol): The symbol object to fetch references for\n        \n        Returns:\n        List[SymbolReference]: A list of SymbolReference objects in scope\n        \n      Methods:\n    automata.tests.unit.test_symbol_search.test_process_queries\n    \n        def test_process_queries(symbols, symbol_searcher, symbol_graph_mock):\n            with patch.object(\n                symbol_searcher, \"symbol_references\", return_value=[\"ref1\", \"ref2\"]\n            ) as mock_method_0:\n                result = symbol_searcher.process_query(\"type:symbol_references %s\" % symbols[0].uri)\n                assert result == [\"ref1\", \"ref2\"]\n            mock_method_0.assert_called_once_with(symbols[0].uri)\n        \n            with patch.object(symbol_searcher, \"exact_search\", return_value={\"test\": 0}) as mock_method_1:\n                result = symbol_searcher.process_query(\"type:exact %s\" % symbols[0].uri)\n                assert result == {\"test\": 0}\n            mock_method_1.assert_called_once_with(symbols[0].uri)\n        \n            with patch.object(\n                symbol_searcher, \"retrieve_source_code_by_symbol\", return_value=\"test\"\n            ) as mock_method_2:\n                result = symbol_searcher.process_query(\"type:source %s\" % symbols[0].uri)\n                assert result == \"test\"\n            mock_method_2.assert_called_once_with(symbols[0].uri)\n        \n            with patch.object(\n                symbol_searcher, \"symbol_rank_search\", return_value=[(\"ref1\", 0.5), (\"ref2\", 0.4)]\n            ) as mock_method_4:\n                result = symbol_searcher.process_query(\"type:symbol_rank %s\" % symbols[0].uri)\n                assert result == [(\"ref1\", 0.5), (\"ref2\", 0.4)]\n            mock_method_4.assert_called_once_with(symbols[0].uri)\n        \n            with pytest.raises(ValueError):\n                symbol_searcher.process_query(\"invalid_query\")\n        \n            with pytest.raises(ValueError):\n                symbol_searcher.process_query(\"type:unknown query\")\n        \n        \n    automata.core.symbol.symbol_types.SymbolDocEmbedding\n    \n        `SymbolDocEmbedding` is a class representing the embedding for symbol documents, extending the `SymbolEmbedding` class with added metadata such as source code, summary, and context. This class is utilized alongside `SymbolDocEmbeddingHandler` to manage and access these embeddings for tasks like search and similarity comparison. However, it relies on external handler classes and assumes embeddings are provided as NumPy arrays, potentially limiting usage for other embedding types.\n        \n        ```python\n        import numpy as np\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.symbol.symbol_types import SymbolDocEmbedding\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        symbol = Symbol.from_string(symbol_str)\n        \n        document = \"This is a sample document\"\n        vector = np.array([0.1, 0.2, 0.3])\n        source_code = \"class ActionIndicator(Enum): ...\"\n        summary = \"This class represents an enum for action indicators.\"\n        context = \"The ActionIndicator enum is used to describe the current state...\"\n        \n        embedding = SymbolDocEmbedding(symbol, document, vector, source_code=source_code, summary=summary, context=context)\n        ```\n        \n      Class Docstring:\n        Embedding for symbol documents\n        \n      Methods:\n        def __init__(\n                self,\n                symbol: Symbol,\n                document: str,\n                vector: np.array,\n                source_code: Optional[str] = None,\n                summary: Optional[str] = None,\n                context: Optional[str] = None,\n            ):\n                super().__init__(symbol, document, vector)\n                # begin additional meta data\n                self.source_code = source_code\n                self.summary = summary\n                self.context = context\n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.utils`/HandlerDict#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.utils", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "HandlerDict", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# HandlerDict\n\n`HandlerDict` is a Python dictionary class representing a logging handler in the context of logging configuration. This class is used together with other related symbols in different parts of the library to manage and configure logging settings.\n\n## Related Symbols\n\n- `automata.core.utils.RootDict`\n- `automata.core.utils.LoggingConfig`\n- `automata.tests.unit.sample_modules.sample_module_2.fhFSO`\n- `automata.tests.unit.sample_modules.sample_module_2.ObNMl`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.tests.unit.sample_modules.sample_module_2.EmptyClass`\n- `automata.core.coding.py_coding.writer.PyCodeWriter.ModuleNotFound`\n- `automata.core.coding.py_coding.module_tree.LazyModuleTreeMap`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `HandlerDict` and use it within the context of creating a `LoggingConfig` object.\n\n```python\nfrom automata.core.utils import HandlerDict, LoggingConfig, RootDict\n\nhandler_dict = HandlerDict({\"level\": \"WARNING\", \"class\": \"logging.StreamHandler\", \"formatter\": \"simple\"})\n\nlogging_config = LoggingConfig(\n    version=1,\n    disable_existing_loggers=False,\n    formatters={\n        \"simple\": {\n            \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n        }\n    },\n    handlers={\n        \"console\": handler_dict\n    },\n    root=RootDict({\"level\": \"DEBUG\", \"handlers\": [\"console\"]})\n)\n```\n\n## Limitations\n\n`HandlerDict` itself is a utility class with limited functionality, and its primary purpose is to serve as a structured representation for logging handlers. It is highly dependent on the context it is used in, meaning it may not provide much value when used in isolation.\n\n## Follow-up Questions\n\n- Is there any specific functionality or methods that should be added to the `HandlerDict` class for better flexibility and usage?\n- Are there any other potential use cases in which `HandlerDict` might be beneficial?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 248}, false, {"py/b64": "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"}]}]}, "source_code": "class HandlerDict(TypedDict):\n    \"\"\"A dictionary representing a logging handler\"\"\"\n\n    class_: str\n    formatter: str\n    level: int\n    filename: Optional[str]\n\n\n", "summary": "The `HandlerDict` is a Python dictionary class, used for representing a logging handler in the context of logging configuration. It is mainly utilized alongside other symbols in different parts of the library to manage and configure logging settings. The primary function of `HandlerDict` is to serve as a structured representation for logging handlers, and its effectiveness depends on the context it is used in. The example demonstrates how to create an instance of `HandlerDict` and use it within the context of creating a `LoggingConfig` object. Limitations of this utility class include limited functionality and its dependence on the context, which affects its value in isolation.", "context": "\n    Generate the documentation for HandlerDict using the context shown below -\n  Building context for primary symbol - automata.core.utils.HandlerDict -\n  \n    Import Statements:\n      import json\n      import logging\n      import os\n      import yaml\n      from typing import Any, List, Optional, TypedDict, Union, cast\n      \n      # HandlerDict\n      \n      `HandlerDict` is a dictionary class, representing a logging handler in the context of logging configuration. This class is used together with other related symbols in different parts of the library to manage and configure logging settings.\n      \n      ## Related Symbols\n      \n      - `automata.core.utils.RootDict`\n      - `automata.core.utils.LoggingConfig`\n      - `automata.tests.unit.sample_modules.sample_module_2.fhFSO`\n      - `automata.tests.unit.sample_modules.sample_module_2.ObNMl`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.tests.unit.sample_modules.sample_module_2.EmptyClass`\n      - `automata.core.coding.py_coding.writer.PyCodeWriter.ModuleNotFound`\n      - `automata.core.coding.py_coding.module_tree.LazyModuleTreeMap`\n      \n      ## Example\n      \n      The following is an example demonstrating how to create an instance of `HandlerDict` and use it within the context of creating a `LoggingConfig` object.\n      \n      ```python\n      from automata.core.utils import HandlerDict, LoggingConfig, RootDict\n      \n      handler_dict = HandlerDict({\"level\": \"WARNING\", \"class\": \"logging.StreamHandler\", \"formatter\": \"simple\"})\n      \n      logging_config = LoggingConfig(\n          version=1,\n          disable_existing_loggers=False,\n          formatters={\n              \"simple\": {\n                  \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n              }\n          },\n          handlers={\n              \"console\": handler_dict\n          },\n          root=RootDict({\"level\": \"DEBUG\", \"handlers\": [\"console\"]})\n      )\n      ```\n      \n      ## Limitations\n      \n      `HandlerDict` itself is a utility class with limited functionality and its primary purpose is to serve as a structured representation for logging handlers. It is highly dependent on the context it is used in, meaning it may not provide much value when used in isolation.\n      \n      ## Follow-up Questions\n      \n      - Is there any specific functionality or methods that should be added to the `HandlerDict` class for better flexibility and usage?\n      - Are there any other potential use cases in which `HandlerDict` might be beneficial?\n      \n    Class Docstring:\n      A dictionary representing a logging handler\n      \n  Building context for related symbols -\n  \n    automata.core.utils.RootDict\n    \n        RootDict is a typed dictionary subclass derived from TypedDict that represents the root logger in an application's logging configuration. It provides a type-safe way to store root logger information such as logging level and handlers. Primarily used with the automata.core.utils.LoggingConfig class and other related symbols, RootDict ensures the correct structure for the root logger information but doesn't provide built-in functionality for managing logging settings or interactions with other components. \n        \n        An example of creating a RootDict instance:\n        \n        ```python\n        from automata.core.utils import RootDict\n        \n        root_dict: RootDict = {\n            \"level\": \"INFO\",\n            \"handlers\": [\"console\"],\n        }\n        ```\n        \n      Class Docstring:\n        A dictionary representing the root logger\n        \n    automata.core.utils.LoggingConfig\n    \n        class LoggingConfig(TypedDict, total=False):\n            \"\"\"A dictionary representing the logging configuration\"\"\"\n        \n            version: int\n            disable_existing_loggers: bool\n            formatters: dict\n            handlers: dict[str, Union[HandlerDict, dict]]\n            root: RootDict\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.fhFSO\n    \n        def fhFSO():\n            \"\"\"GEjBUXtHLGzJDCDsnFFp\"\"\"\n        \n            pass\n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl.method\n    \n        def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl\n    \n        class ObNMl:\n            \"\"\"zFsdXovhQSBlqDNpXSvl\"\"\"\n        \n            def __init__(self):\n                pass\n        \n            def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl.__init__\n    \n        def __init__(self):\n                pass\n        \n            \n        \n    automata.core.coding.py_coding.writer.PyCodeWriter.ModuleNotFound\n    \n        PyCodeWriter is a utility class that enables the writing of Python code alongside Abstract Syntax Tree (AST) nodes. It permits the creation, updating, deletion, and manipulation of source code in Python modules while also generating documentation. Working in conjunction with PyCodeRetriever, the PyCodeWriter allows for seamless extraction and alteration of Python code. The main use of PyCodeWriter is to modify source code within Python modules using a PyCodeRetriever instance for code manipulation. However, its primary limitation is its reliance on source code structured in a specific way, as it may struggle with edge cases or unconventional coding structures.\n        \n        Example:\n        ```python\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        from automata.core.coding.py_coding.writer import PyCodeWriter\n        \n        python_retriever = PyCodeRetriever()  # create a PyCodeRetriever instance\n        code_writer = PyCodeWriter(python_retriever)  # initialize PyCodeWriter with the PyCodeRetriever instance\n        \n        source_code = \"\"\"def foo():\n            return 'Hello, world!'\n        \"\"\"\n        code_writer.create_new_module(\"sample_module\", source_code, do_write=True)\n        ```\n        \n        \n      Class Docstring:\n        Raised when a module is not found in the module dictionary\n        \n    automata.tests.unit.sample_modules.sample.EmptyClass\n    \n        class EmptyClass:\n            pass\n        \n        \n        \n        \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap\n    \n        The `LazyModuleTreeMap` class is a lazy dictionary that maps module dotpaths to their corresponding RedBaron FST objects, loading and caching the modules in memory as they are accessed. It provides methods for fetching existing module dotpaths and filepaths, as well as fetching, putting, and updating modules by their dotpaths. However, it assumes a specific directory structure according to the `DotPathMap` class and does not support custom directory structures for modules.\n        \n        ```python\n        from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n        from automata.core.utils import root_fpath\n        \n        path_to_root = root_fpath()\n        module_tree_map = LazyModuleTreeMap(path_to_root)\n        \n        # Fetch an existing module by its dotpath\n        module_dotpath = \"automata.core.agent.automata_agent\"\n        module = module_tree_map.fetch_module(module_dotpath)\n        \n        # Check if a module with the given dotpath exists\n        exists = module_dotpath in module_tree_map\n        ```\n        \n      Class Docstring:\n        A lazy dictionary between module dotpaths and their corresponding RedBaron FST objects.\n        Loads and caches modules in memory as they are accessed\n        \n      Methods:\n        __contains__(self, dotpath) -> None\n        \n        def __init__(self, path: str):\n                \"\"\"\n                Args:\n                    path: The absolute path to the root of the module tree\n                \"\"\"\n                self._dotpath_map = DotPathMap(path)\n                self._loaded_modules: Dict[str, Optional[RedBaron]] = {}\n        \n            \n        cached_default(cls) -> \"LazyModuleTreeMap\"\n        \n        fetch_existing_module_dotpath(self, module_obj: RedBaron) -> Optional[str]\n        \n        fetch_existing_module_fpath_by_dotpath(self, module_dotpath: str) -> Optional[str]\n        \n        fetch_module(self, module_dotpath: str) -> Optional[RedBaron]\n        \n        get_module_dotpath_by_fpath(self, module_fpath: str) -> str\n        \n        items(self) -> Iterable[Tuple[str, Optional[RedBaron]]]\n        \n        put_module(self, module_dotpath: str, module: RedBaron) -> None\n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.utils`/LoggingConfig#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.utils", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "LoggingConfig", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# LoggingConfig\n\n`LoggingConfig` is a typed dictionary class used to represent the logging configuration within the Automata Docs library. This class provides a structured way to store logging settings, ensuring the correct structure for the configuration.\n\n## Overview\n\nThe class contains various attributes, such as `version`, `disable_existing_loggers`, `formatters`, `handlers`, and `root`. These attributes represent key configuration settings for managing and configuring logging settings. The primary purpose of this utility class is to serve as a structured representation for logging configurations. As the class derives from TypedDict, it doesn't provide built-in functionality for managing logging settings or interactions with other components.\n\n## Related Symbols\n\n- `automata.core.utils.HandlerDict`\n- `automata.cli.commands.reconfigure_logging`\n- `automata.core.utils.RootDict`\n- `automata.core.utils.get_logging_config`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `LoggingConfig` and use it to configure a logging setup:\n\n```python\nfrom automata.core.utils import LoggingConfig\nfrom automata.cli.commands import reconfigure_logging\n\nlogging_config: LoggingConfig = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"formatters\": {\n        \"simple\": {\n            \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n        },\n    },\n    \"handlers\": {\n        \"console\": {\n            \"class\": \"logging.StreamHandler\",\n            \"level\": \"INFO\",\n            \"formatter\": \"simple\",\n            \"stream\": \"ext://sys.stdout\",\n        },\n    },\n    \"root\": {\n        \"level\": \"INFO\",\n        \"handlers\": [\"console\"],\n    },\n}\nreconfigure_logging.setup_logging(logging_config)\n```\n\n## Limitations\n\nAs the class is a TypedDict subclass, it does not provide any built-in methods to manipulate the settings or interact with logging handlers. Users need to work with included symbols like `reconfigure_logging`, `HandlerDict`, and `RootDict` to configure the logging settings effectively.\n\n## Follow-up Questions:\n\n- Is there a need for additional functionality within the `LoggingConfig` class to manage or interact with logging configurations?\n\n- Are there any other related symbols or functionality that should be covered in this documentation?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 248}, false, {"py/b64": "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"}]}]}, "source_code": "class LoggingConfig(TypedDict, total=False):\n    \"\"\"A dictionary representing the logging configuration\"\"\"\n\n    version: int\n    disable_existing_loggers: bool\n    formatters: dict\n    handlers: dict[str, Union[HandlerDict, dict]]\n    root: RootDict\n\n\n", "summary": "`LoggingConfig` is a typed dictionary class in the Automata Docs library that represents the logging configuration. It contains attributes such as `version`, `disable_existing_loggers`, `formatters`, `handlers`, and `root`, which represent key configuration settings for logging. The class serves as a structured representation for logging configurations and is derived from TypedDict, meaning it does not provide built-in functionality for managing logging settings or interactions with other components. Users must work with related symbols like `reconfigure_logging`, `HandlerDict`, and `RootDict` to configure the logging settings effectively.\n\nExample:\n\n```python\nfrom automata.core.utils import LoggingConfig\nfrom automata.cli.commands import reconfigure_logging\n\nlogging_config: LoggingConfig = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"formatters\": {\n        \"simple\": {\n            \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n        },\n    },\n    \"handlers\": {\n        \"console\": {\n            \"class\": \"logging.StreamHandler\",\n            \"level\": \"INFO\",\n            \"formatter\": \"simple\",\n            \"stream\": \"ext://sys.stdout\",\n        },\n    },\n    \"root\": {\n        \"level\": \"INFO\",\n        \"handlers\": [\"console\"],\n    },\n}\nreconfigure_logging.setup_logging(logging_config)\n```", "context": "\n    Generate the documentation for LoggingConfig using the context shown below -\n  Building context for primary symbol - automata.core.utils.LoggingConfig -\n  \n      class LoggingConfig(TypedDict, total=False):\n          \"\"\"A dictionary representing the logging configuration\"\"\"\n      \n          version: int\n          disable_existing_loggers: bool\n          formatters: dict\n          handlers: dict[str, Union[HandlerDict, dict]]\n          root: RootDict\n      \n      \n      \n      \n  Building context for related symbols -\n  \n    automata.core.utils.HandlerDict\n    \n        The `HandlerDict` class is a dictionary used to represent a logging handler in the context of logging configuration in the Automata Docs library. It's primarily used in conjunction with other related symbols to manage and configure logging settings. A sample use case of `HandlerDict` involves creating an instance of it and using it within a LoggingConfig object. The primary purpose of this utility class is to serve as a structured representation for logging handlers and it may not provide much value when used in isolation.\n        \n      Class Docstring:\n        A dictionary representing a logging handler\n        \n    automata.cli.commands.reconfigure_logging\n    \n      Class Docstring:\n        Configure the logging settings.\n        \n        :param verbose: Boolean, if True, set log level to DEBUG, else set to INFO.\n        \n      Methods:\n        reconfigure_logging(log_level_str: str) -> None\n        \n    automata.core.utils.RootDict\n    \n        RootDict is a typed dictionary subclass derived from TypedDict that represents the root logger in an application's logging configuration. It provides a type-safe way to store root logger information such as logging level and handlers. Primarily used with the automata.core.utils.LoggingConfig class and other related symbols, RootDict ensures the correct structure for the root logger information but doesn't provide built-in functionality for managing logging settings or interactions with other components. \n        \n        An example of creating a RootDict instance:\n        \n        ```python\n        from automata.core.utils import RootDict\n        \n        root_dict: RootDict = {\n            \"level\": \"INFO\",\n            \"handlers\": [\"console\"],\n        }\n        ```\n        \n      Class Docstring:\n        A dictionary representing the root logger\n        \n    automata.core.utils.get_logging_config\n    \n      Class Docstring:\n        Returns logging configuration.\n        \n        Args:\n        log_level (int): The log level.\n        log_file (Optional[str]): The log file path.\n        Returns\n        dict[str, Any]: The logging configuration.\n        \n      Methods:\n        get_logging_config(log_level: int = logging.INFO, log_file: Optional[str] = None) -> dict[str, Any]\n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl\n    \n        class ObNMl:\n            \"\"\"zFsdXovhQSBlqDNpXSvl\"\"\"\n        \n            def __init__(self):\n                pass\n        \n            def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.core.symbol.search.rank.SymbolRankConfig\n    \n        class SymbolRankConfig(BaseModel):\n            \"\"\"A configuration class for SymbolRank\"\"\"\n        \n            alpha: float = 0.25\n            max_iterations: int = 100\n            tolerance: float = 1.0e-6\n            weight_key: str = \"weight\"\n        \n            @classmethod\n            def validate(cls, config):\n                \"\"\"\n                Validate configuration parameters.\n        \n                Args:\n                    config (SymbolRankConfig): Configuration parameters.\n        \n                Raises:\n                    ValueError: If alpha is not in (0, 1), or tolerance is not in (1e-4, 1e-8).\n                \"\"\"\n                if not 0 < config.alpha < 1:\n                    raise ValueError(f\"alpha must be in (0,1), but got {config.alpha}\")\n        \n                if not 1.0e-8 < config.tolerance < 1.0e-4:\n                    raise ValueError(f\"tolerance must be in (1e-4,1e-8), but got {config.tolerance}\")\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample.EmptyClass\n    \n        class EmptyClass:\n            pass\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl.method\n    \n        def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.core.utils`/RootDict#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.core.utils", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "RootDict", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# RootDict\n\n`RootDict` is a dictionary representing the root logger in the logging configuration. \n\n## Overview\n\n`RootDict` is a typed dictionary subclass derived from the `TypedDict` base class. It provides a type-safe way to store the root logger information, which includes logging level, handlers, and others. The primary purpose of the `RootDict` class is to be used in conjunction with the `automata.core.utils.LoggingConfig` class and other related symbols for configuring logging settings in an application.\n\n## Related Symbols\n\n- `automata.core.utils.LoggingConfig`\n- `automata.core.coding.py_coding.module_tree.LazyModuleTreeMap`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.core.utils.HandlerDict`\n- `automata.tests.unit.sample_modules.sample.EmptyClass`\n- `automata.core.coding.py_coding.module_tree.DotPathMap`\n- `automata.core.coding.directory.DirectoryManager`\n\n## Example\n\nThe following example demonstrates how to create a `RootDict` instance to store root logger information:\n\n```python\nfrom automata.core.utils import RootDict\n\nroot_dict: RootDict = {\n    \"level\": \"INFO\",\n    \"handlers\": [\"console\"],\n}\n```\n\n## Limitations\n\n`RootDict` is just a typed dictionary that ensures the correct structure for the root logger information, but it doesn't provide any built-in functionality for managing logging settings or interactions with other logging components. For that purpose, you need to use other related symbols and classes as shown in the Related Symbols section.\n\n## Follow-up Questions:\n\n- Are there any other important methods or attributes that should be included in the documentation for `RootDict`?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 248}, false, {"py/b64": "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"}]}]}, "source_code": "class RootDict(TypedDict):\n    \"\"\"A dictionary representing the root logger\"\"\"\n\n    handlers: List[str]\n    level: int\n\n\n", "summary": "RootDict is a typed dictionary subclass derived from TypedDict base class that stores root logger information, including logging level and handlers. Primarily used with the automata.core.utils.LoggingConfig class and other related symbols, it provides a type-safe way to configure logging settings in an application. However, RootDict only ensures the correct structure for root logger information and does not manage logging settings or interactions with other logging components. Here's an example of using RootDict:\n\n```python\nfrom automata.core.utils import RootDict\n\nroot_dict: RootDict = {\n    \"level\": \"INFO\",\n    \"handlers\": [\"console\"],\n}\n```", "context": "\n    Generate the documentation for RootDict using the context shown below -\n  Building context for primary symbol - automata.core.utils.RootDict -\n  \n    Import Statements:\n      import json\n      import logging\n      import os\n      import yaml\n      from typing import Any, List, Optional, TypedDict, Union, cast\n      \n      # RootDict\n      \n      `RootDict` is a dictionary representing the root logger in the logging configuration.\n      \n      ## Overview\n      \n      `RootDict` is a typed dictionary subclass derived from the `TypedDict` base class. It provides a type-safe way to store the root logger information, which includes logging level, handlers, and others. The primary purpose of the `RootDict` class is to be used in conjunction with the `automata.core.utils.LoggingConfig` class and other related symbols for configuring logging settings in an application.\n      \n      ## Related Symbols\n      \n      - `automata.core.utils.LoggingConfig`\n      - `automata.core.coding.py_coding.module_tree.LazyModuleTreeMap`\n      - `automata.core.symbol.symbol_types.Symbol`\n      - `automata.core.utils.HandlerDict`\n      - `automata.tests.unit.sample_modules.sample.EmptyClass`\n      - `automata.core.coding.py_coding.module_tree.DotPathMap`\n      - `automata.tests.unit.test_py_code_retriever.module_map`\n      - `automata.core.coding.directory.DirectoryManager`\n      \n      ## Example\n      \n      The following example demonstrates how to create a `RootDict` instance to store root logger information.\n      \n      ```python\n      from automata.core.utils import RootDict\n      \n      root_dict: RootDict = {\n          \"level\": \"INFO\",\n          \"handlers\": [\"console\"],\n      }\n      ```\n      \n      ## Limitations\n      \n      `RootDict` is just a typed dictionary that ensures the correct structure for the root logger information, but it doesn't provide any built-in functionality for managing logging settings or interactions with other logging components. For that purpose, you need to use other related symbols and classes as shown in the Related Symbols section.\n      \n      ## Follow-up Questions:\n      \n      - Are there any other important methods or attributes that should be included in the documentation for `RootDict`?\n      \n    Class Docstring:\n      A dictionary representing the root logger\n      \n  Building context for related symbols -\n  \n    automata.core.utils.LoggingConfig\n    \n        class LoggingConfig(TypedDict, total=False):\n            \"\"\"A dictionary representing the logging configuration\"\"\"\n        \n            version: int\n            disable_existing_loggers: bool\n            formatters: dict\n            handlers: dict[str, Union[HandlerDict, dict]]\n            root: RootDict\n        \n        \n        \n        \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap\n    \n        The `LazyModuleTreeMap` class is a lazy dictionary that maps module dotpaths to their corresponding RedBaron FST objects, loading and caching the modules in memory as they are accessed. It provides methods for fetching existing module dotpaths and filepaths, as well as fetching, putting, and updating modules by their dotpaths. However, it assumes a specific directory structure according to the `DotPathMap` class and does not support custom directory structures for modules.\n        \n        ```python\n        from automata.core.coding.py_coding.module_tree import LazyModuleTreeMap\n        from automata.core.utils import root_fpath\n        \n        path_to_root = root_fpath()\n        module_tree_map = LazyModuleTreeMap(path_to_root)\n        \n        # Fetch an existing module by its dotpath\n        module_dotpath = \"automata.core.agent.automata_agent\"\n        module = module_tree_map.fetch_module(module_dotpath)\n        \n        # Check if a module with the given dotpath exists\n        exists = module_dotpath in module_tree_map\n        ```\n        \n      Class Docstring:\n        A lazy dictionary between module dotpaths and their corresponding RedBaron FST objects.\n        Loads and caches modules in memory as they are accessed\n        \n      Methods:\n        __contains__(self, dotpath) -> None\n        \n        def __init__(self, path: str):\n                \"\"\"\n                Args:\n                    path: The absolute path to the root of the module tree\n                \"\"\"\n                self._dotpath_map = DotPathMap(path)\n                self._loaded_modules: Dict[str, Optional[RedBaron]] = {}\n        \n            \n        cached_default(cls) -> \"LazyModuleTreeMap\"\n        \n        fetch_existing_module_dotpath(self, module_obj: RedBaron) -> Optional[str]\n        \n        fetch_existing_module_fpath_by_dotpath(self, module_dotpath: str) -> Optional[str]\n        \n        fetch_module(self, module_dotpath: str) -> Optional[RedBaron]\n        \n        get_module_dotpath_by_fpath(self, module_fpath: str) -> str\n        \n        items(self) -> Iterable[Tuple[str, Optional[RedBaron]]]\n        \n        put_module(self, module_dotpath: str, module: RedBaron) -> None\n        \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap.cached_default\n    \n      Class Docstring:\n        Creates a new LazyModuleTreeMap instance with the default root path\n        \n      Methods:\n        cached_default(cls) -> \"LazyModuleTreeMap\"\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.core.utils.HandlerDict\n    \n        The `HandlerDict` class is a dictionary used to represent a logging handler in the context of logging configuration in the Automata Docs library. It's primarily used in conjunction with other related symbols to manage and configure logging settings. A sample use case of `HandlerDict` involves creating an instance of it and using it within a LoggingConfig object. The primary purpose of this utility class is to serve as a structured representation for logging handlers and it may not provide much value when used in isolation.\n        \n      Class Docstring:\n        A dictionary representing a logging handler\n        \n    automata.tests.unit.sample_modules.sample.EmptyClass\n    \n        class EmptyClass:\n            pass\n        \n        \n        \n        \n    automata.core.coding.py_coding.module_tree.DotPathMap\n    \n        DotPathMap is a class designed to map module dotpaths to module filepaths within Python codebases, allowing for easy programmatic access. The class is initialized with the absolute path to the root of the module tree and offers utility methods, such as checking if a dotpath or filepath are in the map, getting the corresponding dotpath for a given module filepath and vice versa, and adding a module with a specific dotpath to the map. However, DotPathMap has a limitation in that it solely supports Python projects with a specific directory structure and doesn't handle cases with different structures, such as virtual environments or nested packages.\n        \n      Class Docstring:\n        A map from module dotpaths to module filepaths\n        \n      Methods:\n        def __init__(self, path: str):\n                \"\"\"\n                Args:\n                    path: The absolute path to the root of the module tree\n                \"\"\"\n                if not os.path.isabs(path):\n                    path = os.path.join(root_fpath(), path)\n                self._abs_path = path\n                self._module_dotpath_to_fpath_map = self._build_module_dotpath_to_fpath_map()\n                self._module_fpath_to_dotpath_map = {\n                    v: k for k, v in self._module_dotpath_to_fpath_map.items()\n                }\n        \n            \n        contains_dotpath(self, module_dotpath: str) -> bool\n        \n        contains_fpath(self, module_fpath: str) -> bool\n        \n        get_module_dotpath_by_fpath(self, module_fpath: str) -> str\n        \n        get_module_fpath_by_dotpath(self, module_dotpath: str) -> str\n        \n        items(self) -> Iterable[Tuple[str, str]]\n        \n        put_module(self, module_dotpath: str) -> None\n        \n    automata.core.coding.py_coding.module_tree.LazyModuleTreeMap.__init__\n    \n      Class Docstring:\n        Args:\n        path: The absolute path to the root of the module tree\n        \n      Methods:\n        def __init__(self, path: str):\n                \"\"\"\n                Args:\n                    path: The absolute path to the root of the module tree\n                \"\"\"\n                self._dotpath_map = DotPathMap(path)\n                self._loaded_modules: Dict[str, Optional[RedBaron]] = {}\n        \n            \n    automata.core.coding.directory.DirectoryManager\n    \n        DirectoryManager is a utility class for handling directory structures, providing methods for creating directories and obtaining lists of files and subdirectories within a given directory. To create a DirectoryManager instance, simply import the class and initialize it with the base path of the desired directory structure. However, it has some limitations, such as assuming a specific directory structure based on the base path provided and not having error handling for incorrect or inaccessible paths. Here's an example usage:\n        \n        ```python\n        from automata.core.coding.directory import DirectoryManager\n        \n        # Creating a new directory\n        base_path = \"/path/to/base/directory\"\n        dm = DirectoryManager(base_path)\n        dm.ensure_directory_exists(\"new_directory\")\n        \n        # Retrieving the list of files and subdirectories in a given directory\n        files = dm.get_files_in_dir(\"new_directory\")\n        subdirs = dm.get_subdirectories(\"new_directory\")\n        print(\"Files:\", files)\n        print(\"Subdirectories:\", subdirs)\n        ```\n        \n        \n      Class Docstring:\n        Handles operations related to directory structure.\n        \n      Methods:\n        def __init__(self, base_path: str):\n                \"\"\"\n                Args:\n                    base_path (str): Base path of the directory structure\n                \"\"\"\n                self.root = self._load_directory_structure(base_path)\n        \n            \n        ensure_directory_exists(self, directory_path: str) -> None\n        \n        get_files_in_dir(self, path: str) -> List[str]\n        \n        get_subdirectories(self, path: str) -> List[str]\n        \n    automata.tests.unit.test_py_code_retriever.module_map\n    \n        @pytest.fixture\n        def module_map():\n            # get latest path\n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            # Set the root directory to the folder containing test modules\n            return LazyModuleTreeMap(sample_dir)\n        \n        \n        \n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.tests.unit.sample_modules.sample`/EmptyClass#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.tests.unit.sample_modules.sample", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "EmptyClass", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# EmptyClass\n\n`EmptyClass` is a simple class with no methods or attributes and is defined in the `automata.tests.unit.sample_modules.sample module`. The class definition is as follows:\n\n```python\nclass EmptyClass:\n    pass\n```\n\n## Related Symbols\n\n- `automata.tests.unit.sample_modules.sample.OuterClass`\n- `automata.tests.unit.sample_modules.sample.OuterClass.InnerClass`\n- `automata.tests.unit.sample_modules.sample_module_2.ObNMl`\n- `automata.tests.unit.test_py_code_retriever.test_get_code_no_docstring_no_code`\n\n## Example\n\nThe following example demonstrates how to create an instance of `EmptyClass`.\n\n```python\nfrom automata.tests.unit.sample_modules.sample import EmptyClass\n\nempty_instance = EmptyClass()\n```\n\n## Limitations\n\n`EmptyClass` is an example of a trivial class with no functionality. It serves as a placeholder and can be used in testing scenarios where a simple class is needed without any specific behavior or attributes.\n\n## Follow-up Questions:\n\n- What is the purpose of `EmptyClass` in the module?\n- Are there any specific use cases for `EmptyClass` in the project?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 248}, false, {"py/b64": "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"}]}]}, "source_code": "class EmptyClass:\n    pass\n\n\n", "summary": "`EmptyClass` is a basic class with no methods or attributes, located in the `automata.tests.unit.sample_modules.sample module`. It serves as a placeholder and can be used in testing scenarios requiring a simple class with no specific behavior or attributes. To create an instance of `EmptyClass`, use the following code:\n\n```python\nfrom automata.tests.unit.sample_modules.sample import EmptyClass\nempty_instance = EmptyClass()\n```", "context": "\n    Generate the documentation for EmptyClass using the context shown below -\n  Building context for primary symbol - automata.tests.unit.sample_modules.sample.EmptyClass -\n  \n      class EmptyClass:\n          pass\n      \n      \n      \n      \n  Building context for related symbols -\n  \n    automata.tests.unit.sample_modules.sample.OuterClass\n    \n        class OuterClass:\n            class InnerClass:\n                \"\"\"Inner doc strings\"\"\"\n        \n                def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.tests.unit.sample_modules.sample.OuterClass.InnerClass\n    \n        class InnerClass:\n                \"\"\"Inner doc strings\"\"\"\n        \n                def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl\n    \n        class ObNMl:\n            \"\"\"zFsdXovhQSBlqDNpXSvl\"\"\"\n        \n            def __init__(self):\n                pass\n        \n            def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.tests.unit.test_py_code_retriever.test_get_code_no_docstring_no_code\n    \n        def test_get_code_no_docstring_no_code(getter):\n            module_name = \"sample\"\n            object_path = \"EmptyClass\"\n            result = getter.get_source_code_without_docstrings(module_name, object_path)\n            expected_match = \"class EmptyClass:\\n    pass\\n\\n\\n\"\n            assert result == expected_match\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl.__init__\n    \n        def __init__(self):\n                pass\n        \n            \n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl.method\n    \n        def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.core.coding.py_coding.writer.PyCodeWriter.ClassOrFunctionNotFound\n    \n        PyCodeWriter is a utility class for managing Python modules using AST nodes. It builds on the PyCodeRetriever object and offers methods for creating, updating, and deleting modules. To create an instance of PyCodeWriter, pass a PyCodeRetriever instance as follows:\n        \n        ```python\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        from automata.core.coding.py_coding.writer import PyCodeWriter\n        from automata.core.coding.directory import DirectoryManager\n        \n        python_retriever = PyCodeRetriever(DirectoryManager().module_tree_map)\n        code_writer = PyCodeWriter(python_retriever)\n        ```\n        \n        Note that PyCodeWriter assumes a particular module structure and may be less flexible for working with different module structures.\n        \n      Class Docstring:\n        Raised when a class or function is not found in the module\n        \n    automata.tests.unit.sample_modules.sample_module_2.fhFSO\n    \n        def fhFSO():\n            \"\"\"GEjBUXtHLGzJDCDsnFFp\"\"\"\n        \n            pass\n        \n        \n    automata.tests.unit.sample_modules.sample.Person\n    \n        class Person:\n            \"\"\"This is a sample class.\"\"\"\n        \n            def __init__(self, name):\n                \"\"\"This is the constructor.\"\"\"\n                self.name = name\n        \n            def say_hello(self):\n                \"\"\"This is a sample method.\"\"\"\n                return f\"Hello, I am {self.name}.\"\n        \n            def run(self) -> str:\n                ...\n        \n        \n        \n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.tests.unit.sample_modules.sample`/OuterClass#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.tests.unit.sample_modules.sample", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "OuterClass", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# OuterClass\n\n`OuterClass` is a sample class that contains an inner class called `InnerClass` within it. This inner class has a method named `inner_method`.\n\n## Overview\n\n`OuterClass` demonstrates an example of using nested classes in Python, with outer and inner classes structures. The `InnerClass` has its own method `inner_method`. \n\n## Related Symbols\n\n- `sample.EmptyClass`\n- `sample.OuterClass.InnerClass`\n- `sample.OuterClass.InnerClass.inner_method`\n- `sample_module_2.ObNMl`\n- `core.symbol.symbol_types.Symbol`\n- `test_py_writer.MockCodeGenerator`\n- `sample.Person`\n- `sample_module_2.ObNMl.method`\n- `core.coding.py_coding.writer.PyCodeWriter.ClassOrFunctionNotFound`\n- `sample_module_2.fhFSO`\n\n## Example\n\nThe following is an example demonstrating how to use `OuterClass` and its nested `InnerClass`.\n\n```python\nfrom automata.tests.unit.sample_modules.sample import OuterClass\n\nouter_instance = OuterClass()\ninner_instance = OuterClass.InnerClass()\n\ninner_result = inner_instance.inner_method()\n```\n\n## Limitations\n\n`OuterClass` is a simple example with limited functionality. It might not cover all functionalities related to nested classes in Python. It assumes the `InnerClass` to have only a single method, limiting the complexity it can handle.\n\n## Follow-up Questions:\n\n- Are there more complex examples of nested classes in the given context?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 248}, false, {"py/b64": "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"}]}]}, "source_code": "class OuterClass:\n    class InnerClass:\n        \"\"\"Inner doc strings\"\"\"\n\n        def inner_method(self):\n            \"\"\"Inner method doc strings\"\"\"\n", "summary": "`OuterClass` is a sample class in Python that utilizes nested classes, containing an inner class named `InnerClass` which has a method called `inner_method`. To use `OuterClass` and its nested `InnerClass`, create instances of both classes and call the `inner_method`. However, this example has limited functionality as it only assumes one method within the `InnerClass`, thus not covering all aspects of nested classes in Python.", "context": "\n    Generate the documentation for OuterClass using the context shown below -\n  Building context for primary symbol - automata.tests.unit.sample_modules.sample.OuterClass -\n  \n      class OuterClass:\n          class InnerClass:\n              \"\"\"Inner doc strings\"\"\"\n      \n              def inner_method(self):\n                  \"\"\"Inner method doc strings\"\"\"\n      \n      \n  Building context for related symbols -\n  \n    automata.tests.unit.sample_modules.sample.EmptyClass\n    \n        class EmptyClass:\n            pass\n        \n        \n        \n        \n    automata.tests.unit.test_py_code_retriever.test_get_docstring_nested_class\n    \n        def test_get_docstring_nested_class(getter):\n            module_name = \"sample\"\n            object_path = \"OuterClass.InnerClass\"\n            result = getter.get_docstring(module_name, object_path)\n            expected_match = \"Inner doc strings\"\n            assert result == expected_match\n        \n        \n        \n        \n    automata.tests.unit.test_py_code_retriever.test_get_docstring_nested_class_method\n    \n        def test_get_docstring_nested_class_method(getter):\n            module_name = \"sample\"\n            object_path = \"OuterClass.InnerClass.inner_method\"\n            result = getter.get_docstring(module_name, object_path)\n            expected_match = \"Inner method doc strings\"\n            assert result == expected_match\n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl\n    \n        class ObNMl:\n            \"\"\"zFsdXovhQSBlqDNpXSvl\"\"\"\n        \n            def __init__(self):\n                pass\n        \n            def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample.Person\n    \n        class Person:\n            \"\"\"This is a sample class.\"\"\"\n        \n            def __init__(self, name):\n                \"\"\"This is the constructor.\"\"\"\n                self.name = name\n        \n            def say_hello(self):\n                \"\"\"This is a sample method.\"\"\"\n                return f\"Hello, I am {self.name}.\"\n        \n            def run(self) -> str:\n                ...\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl.method\n    \n        def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.core.coding.py_coding.writer.PyCodeWriter.ClassOrFunctionNotFound\n    \n        PyCodeWriter is a utility class for managing Python modules using AST nodes. It builds on the PyCodeRetriever object and offers methods for creating, updating, and deleting modules. To create an instance of PyCodeWriter, pass a PyCodeRetriever instance as follows:\n        \n        ```python\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        from automata.core.coding.py_coding.writer import PyCodeWriter\n        from automata.core.coding.directory import DirectoryManager\n        \n        python_retriever = PyCodeRetriever(DirectoryManager().module_tree_map)\n        code_writer = PyCodeWriter(python_retriever)\n        ```\n        \n        Note that PyCodeWriter assumes a particular module structure and may be less flexible for working with different module structures.\n        \n      Class Docstring:\n        Raised when a class or function is not found in the module\n        \n    automata.tests.unit.sample_modules.sample_module_2.fhFSO\n    \n        def fhFSO():\n            \"\"\"GEjBUXtHLGzJDCDsnFFp\"\"\"\n        \n            pass\n        \n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.tests.unit.sample_modules.sample`/OuterClass#InnerClass#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.tests.unit.sample_modules.sample", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "OuterClass", "suffix": 2, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "InnerClass", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# OuterClass\n\n`OuterClass` is a container class that has an inner class called `InnerClass`. `InnerClass` contains a method called `inner_method`. The purpose of `OuterClass` is to provide a simple example of a nested class structure. You can create an instance of `OuterClass` and subsequently access the `InnerClass` and its methods.\n\n## Related Symbols\n\n- `automata.tests.unit.sample_modules.sample.EmptyClass`\n- `automata.tests.unit.sample_modules.sample_module_2.ObNMl`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.tests.unit.test_py_writer.MockCodeGenerator`\n- `automata.tests.unit.sample_modules.sample.Person`\n- `automata.tests.unit.sample_modules.sample_module_2.ObNMl.method`\n- `automata.core.coding.py_coding.writer.PyCodeWriter.ClassOrFunctionNotFound`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `OuterClass` and access the `InnerClass` and its method.\n\n```python\nfrom automata.tests.unit.sample_modules.sample import OuterClass\n\n# Create an instance of OuterClass\nouter_instance = OuterClass()\n\n# Create an instance of InnerClass\ninner_instance = outer_instance.InnerClass()\n\n# Call the inner_method of InnerClass\ninner_result = inner_instance.inner_method()\n```\n\n## Limitations\n\nThe primary limitation of `OuterClass` is that it has a very narrow use case, primarily for demonstrating nested class structures. It does not have any real-world application or functionality. Apart from that, it serves as a good example of how to create, access and utilize nested classes in Python.\n\n## Follow-up Questions:\n\n- Are there any other examples of nested classes and their use cases?\n- How can we extend the functionality of `OuterClass` and `InnerClass` to better demonstrate the potential of nested classes?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 248}, false, {"py/b64": "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"}]}]}, "source_code": "class InnerClass:\n        \"\"\"Inner doc strings\"\"\"\n\n        def inner_method(self):\n            \"\"\"Inner method doc strings\"\"\"\n", "summary": "`OuterClass` is a container class containing a nested class called `InnerClass` with a method named `inner_method`. It serves as a simple example of a nested class structure in Python. To create and access instances of both classes and use the `inner_method`, refer to the code example below:\n\n```python\nfrom automata.tests.unit.sample_modules.sample import OuterClass\n\n# Create an instance of OuterClass\nouter_instance = OuterClass()\n\n# Create an instance of InnerClass\ninner_instance = outer_instance.InnerClass()\n\n# Call the inner_method of InnerClass\ninner_result = inner_instance.inner_method()\n```\n\nThough `OuterClass` has a narrow use case and lacks real-world application, it demonstrates how to work with nested classes in Python.", "context": "\n    Generate the documentation for OuterClass using the context shown below -\n  Building context for primary symbol - automata.tests.unit.sample_modules.sample.OuterClass.InnerClass -\n  \n      class InnerClass:\n              \"\"\"Inner doc strings\"\"\"\n      \n              def inner_method(self):\n                  \"\"\"Inner method doc strings\"\"\"\n      \n      \n  Building context for related symbols -\n  \n    automata.tests.unit.sample_modules.sample.OuterClass\n    \n        class OuterClass:\n            class InnerClass:\n                \"\"\"Inner doc strings\"\"\"\n        \n                def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.tests.unit.sample_modules.sample.EmptyClass\n    \n        class EmptyClass:\n            pass\n        \n        \n        \n        \n    automata.tests.unit.test_py_code_retriever.test_get_docstring_nested_class\n    \n        def test_get_docstring_nested_class(getter):\n            module_name = \"sample\"\n            object_path = \"OuterClass.InnerClass\"\n            result = getter.get_docstring(module_name, object_path)\n            expected_match = \"Inner doc strings\"\n            assert result == expected_match\n        \n        \n        \n        \n    automata.tests.unit.test_py_code_retriever.test_get_docstring_nested_class_method\n    \n        def test_get_docstring_nested_class_method(getter):\n            module_name = \"sample\"\n            object_path = \"OuterClass.InnerClass.inner_method\"\n            result = getter.get_docstring(module_name, object_path)\n            expected_match = \"Inner method doc strings\"\n            assert result == expected_match\n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl\n    \n        class ObNMl:\n            \"\"\"zFsdXovhQSBlqDNpXSvl\"\"\"\n        \n            def __init__(self):\n                pass\n        \n            def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample.Person\n    \n        class Person:\n            \"\"\"This is a sample class.\"\"\"\n        \n            def __init__(self, name):\n                \"\"\"This is the constructor.\"\"\"\n                self.name = name\n        \n            def say_hello(self):\n                \"\"\"This is a sample method.\"\"\"\n                return f\"Hello, I am {self.name}.\"\n        \n            def run(self) -> str:\n                ...\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl.method\n    \n        def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.core.coding.py_coding.writer.PyCodeWriter.ClassOrFunctionNotFound\n    \n        PyCodeWriter is a utility class for managing Python modules using AST nodes. It builds on the PyCodeRetriever object and offers methods for creating, updating, and deleting modules. To create an instance of PyCodeWriter, pass a PyCodeRetriever instance as follows:\n        \n        ```python\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        from automata.core.coding.py_coding.writer import PyCodeWriter\n        from automata.core.coding.directory import DirectoryManager\n        \n        python_retriever = PyCodeRetriever(DirectoryManager().module_tree_map)\n        code_writer = PyCodeWriter(python_retriever)\n        ```\n        \n        Note that PyCodeWriter assumes a particular module structure and may be less flexible for working with different module structures.\n        \n      Class Docstring:\n        Raised when a class or function is not found in the module\n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.tests.unit.sample_modules.sample`/Person#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.tests.unit.sample_modules.sample", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "Person", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# Person\n\n`Person` is a sample class that represents a person with a name and provides methods to interact with that person.\n\n## Overview\n\n`Person` has a constructor that accepts a name parameter and initializes the instance with that name. The class also has two methods: `say_hello` and `run`. The `say_hello` method returns a greeting string including the person's name, while the `run` method is not implemented yet.\n\n## Related Symbols\n\n- `automata.tests.unit.sample_modules.sample_module_2.ObNMl`\n- `automata.tests.unit.sample_modules.sample_module_2.fhFSO`\n- `automata.core.symbol.symbol_types.Symbol`\n\n## Example\n\nHere is an example demonstrating how to create an instance of `Person` and use its `say_hello` method.\n\n```python\nfrom automata.tests.unit.sample_modules.sample import Person\n\nperson = Person(\"John Doe\")\ngreeting = person.say_hello()\nprint(greeting)  # Output: Hello, I am John Doe.\n```\n\n## Limitations\n\nThe `run` method in the `Person` class is not implemented yet, and thus it cannot provide any functionality related to running.", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 248}, false, {"py/b64": "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"}]}]}, "source_code": "class Person:\n    \"\"\"This is a sample class.\"\"\"\n\n    def __init__(self, name):\n        \"\"\"This is the constructor.\"\"\"\n        self.name = name\n\n    def say_hello(self):\n        \"\"\"This is a sample method.\"\"\"\n        return f\"Hello, I am {self.name}.\"\n\n    def run(self) -> str:\n        ...\n\n\n", "summary": "The `Person` class represents a person with a name and offers methods to interact with them. It consists of a constructor that takes a name parameter and initializes the instance, and two methods: `say_hello` and `run`. The `say_hello` method returns a greeting string with the person's name, while the `run` method is not yet implemented. To use the `Person` class, create an instance and utilize the `say_hello` method as follows:\n\n```python\nfrom automata.tests.unit.sample_modules.sample import Person\n\nperson = Person(\"John Doe\")\ngreeting = person.say_hello()\nprint(greeting)  # Output: Hello, I am John Doe.\n```\n\nNote that the `run` method currently provides no functionality related to running.", "context": "\n    Generate the documentation for Person using the context shown below -\n  Building context for primary symbol - automata.tests.unit.sample_modules.sample.Person -\n  \n      class Person:\n          \"\"\"This is a sample class.\"\"\"\n      \n          def __init__(self, name):\n              \"\"\"This is the constructor.\"\"\"\n              self.name = name\n      \n          def say_hello(self):\n              \"\"\"This is a sample method.\"\"\"\n              return f\"Hello, I am {self.name}.\"\n      \n          def run(self) -> str:\n              ...\n      \n      \n      \n      \n  Building context for related symbols -\n  \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl.method\n    \n        def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl\n    \n        class ObNMl:\n            \"\"\"zFsdXovhQSBlqDNpXSvl\"\"\"\n        \n            def __init__(self):\n                pass\n        \n            def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.fhFSO\n    \n        def fhFSO():\n            \"\"\"GEjBUXtHLGzJDCDsnFFp\"\"\"\n        \n            pass\n        \n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl.__init__\n    \n        def __init__(self):\n                pass\n        \n            \n        \n    automata.tests.unit.sample_modules.sample.EmptyClass\n    \n        class EmptyClass:\n            pass\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample.OuterClass\n    \n        class OuterClass:\n            class InnerClass:\n                \"\"\"Inner doc strings\"\"\"\n        \n                def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.tests.unit.sample_modules.sample.OuterClass.InnerClass\n    \n        class InnerClass:\n                \"\"\"Inner doc strings\"\"\"\n        \n                def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator.generate_code\n    \n        def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            \n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.tests.unit.sample_modules.sample2`/PythonAgentToolBuilder#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.tests.unit.sample_modules.sample2", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "PythonAgentToolBuilder", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# PythonAgentToolBuilder\n\n`PythonAgentToolBuilder` is a class for building tools to interact with `PythonAgent`. It helps create a list of `Tool` objects, which represent different commands that can be executed by the agent.\n\n## Overview\n\nThe `PythonAgentToolBuilder` class initializes with a `PythonAgent` instance and provides a method, `build_tools`, that creates a list of `Tool` objects with commands for interacting with the agent. The `Tool` objects have a name, a function, and a description. By using the `build_tools` method, developers can easily create a set of interactive commands for the given agent.\n\n## Related Symbols\n\n- `automata.tests.unit.test_py_code_retriever.test_get_docstring_multiline`\n- `automata.tests.unit.test_py_writer.MockCodeGenerator`\n- `automata.tests.unit.sample_modules.sample_module_2.ObNMl`\n- `automata.core.symbol.symbol_types.Symbol`\n\n## Example\n\n```python\nfrom automata.core.agent import PythonAgent\nfrom automata.tests.unit.sample_modules.sample2 import PythonAgentToolBuilder\n\n# Create an instance of PythonAgent\npython_agent = PythonAgent()\n\n# Create an instance of PythonAgentToolBuilder\ntool_builder = PythonAgentToolBuilder(python_agent)\n\n# Build the list of Tool objects\ntools = tool_builder.build_tools()\n\n# Execute a specific tool (here, we're executing the 'automata-task' tool)\ntools[0].execute()\n```\n\n## Limitations\n\nOne limitation of the `PythonAgentToolBuilder` class is that it currently supports only a single hardcoded task in the `build_tools` method. The task, `python_agent_python_task`, is just a sample and doesn't perform any action. This example may change as new tasks are added or the class functionality expands.\n\n## Follow-up Questions:\n\n- How can we add more tasks to the `build_tools` method?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 248}, false, {"py/b64": "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"}]}]}, "source_code": "class PythonAgentToolBuilder:\n    \"\"\"A class for building tools to interact with PythonAgent.\"\"\"\n\n    def __init__(self, python_agent: PythonAgent):\n        \"\"\"\n        Initializes a PythonAgentToolBuilder with the given PythonAgent.\n\n        Args:\n            python_agent (PythonAgent): A PythonAgent instance representing the agent to work with.\n        \"\"\"\n        self.python_agent = python_agent\n\n    def build_tools(self) -> List:\n        \"\"\"\n        Builds a list of Tool objects for interacting with PythonAgent.\n\n        Args:\n            - None\n\n        Returns:\n            - tools (List[Tool]): A list of Tool objects representing PythonAgent commands.\n        \"\"\"\n\n        def python_agent_python_task():\n            \"\"\"A sample task that utilizes PythonAgent.\"\"\"\n            pass\n\n        tools = [\n            Tool(\n                \"automata-task\",\n                python_agent_python_task,\n                \"Execute a Python task using the PythonAgent. Provide the task description in plain English.\",\n            )\n        ]\n        return tools\n", "summary": "The `PythonAgentToolBuilder` class helps build tools to interact with a `PythonAgent`. It initializes with a `PythonAgent` instance and provides a `build_tools` method to create a list of `Tool` objects, representing different commands that can be executed by the agent. Each `Tool` object has a name, a function, and a description. Currently, the class only supports a single hardcoded task in the `build_tools` method, called `python_agent_python_task`, which serves as a sample and doesn't perform any action. This example may change as more tasks are added or the class functionality expands. For usage, see the provided example code.", "context": "\n    Generate the documentation for PythonAgentToolBuilder using the context shown below -\n  Building context for primary symbol - automata.tests.unit.sample_modules.sample2.PythonAgentToolBuilder -\n  \n      class PythonAgentToolBuilder:\n          \"\"\"A class for building tools to interact with PythonAgent.\"\"\"\n      \n          def __init__(self, python_agent: PythonAgent):\n              \"\"\"\n              Initializes a PythonAgentToolBuilder with the given PythonAgent.\n      \n              Args:\n                  python_agent (PythonAgent): A PythonAgent instance representing the agent to work with.\n              \"\"\"\n              self.python_agent = python_agent\n      \n          def build_tools(self) -> List:\n              \"\"\"\n              Builds a list of Tool objects for interacting with PythonAgent.\n      \n              Args:\n                  - None\n      \n              Returns:\n                  - tools (List[Tool]): A list of Tool objects representing PythonAgent commands.\n              \"\"\"\n      \n              def python_agent_python_task():\n                  \"\"\"A sample task that utilizes PythonAgent.\"\"\"\n                  pass\n      \n              tools = [\n                  Tool(\n                      \"automata-task\",\n                      python_agent_python_task,\n                      \"Execute a Python task using the PythonAgent. Provide the task description in plain English.\",\n                  )\n              ]\n              return tools\n      \n      \n  Building context for related symbols -\n  \n    automata.tests.unit.test_py_code_retriever.test_get_docstring_multiline\n    \n        def test_get_docstring_multiline(getter):\n            module_name = \"sample2\"\n            object_path = \"PythonAgentToolBuilder.__init__\"\n            result = getter.get_docstring(module_name, object_path)\n            expected = \"\\n        Initializes a PythonAgentToolBuilder with the given PythonAgent.\\n\\n        Args:\\n            python_agent (PythonAgent): A PythonAgent instance representing the agent to work with.\\n        \"\n        \n            assert result == expected\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator\n    \n        class MockCodeGenerator:\n            def __init__(\n                self,\n                has_class: bool = False,\n                has_method: bool = False,\n                has_function: bool = False,\n                has_import: bool = False,\n                has_module_docstring: bool = False,\n                has_class_docstring: bool = False,\n                has_method_docstring: bool = False,\n                has_function_docstring: bool = False,\n            ):\n                self.has_class = has_class\n                self.has_method = has_method\n                self.has_function = has_function\n                self.has_import = has_import\n                self.has_module_docstring = has_module_docstring\n                self.has_class_docstring = has_class_docstring\n                self.has_method_docstring = has_method_docstring\n                self.has_function_docstring = has_function_docstring\n        \n                # self.import_class_name = MockCodeGenerator.random_string(5)\n                self.class_name = MockCodeGenerator.random_string(5)\n                self.method_name = MockCodeGenerator.random_string(5)\n                self.function_name = MockCodeGenerator.random_string(5)\n                self.module_docstring = MockCodeGenerator.random_string(20)\n                self.class_docstring = MockCodeGenerator.random_string(20)\n                self.method_docstring = MockCodeGenerator.random_string(20)\n                self.function_docstring = MockCodeGenerator.random_string(20)\n        \n            def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            def _check_function_obj(self, function_obj=None):\n                if function_obj is None:\n                    source_code = self.generate_code()\n                    function_obj = RedBaron(source_code).find(\"def\")\n                assert function_obj.name == self.function_name\n                if self.has_function_docstring:\n                    assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                    assert isinstance(function_obj[0], StringNode)\n                    assert isinstance(function_obj[1], EndlNode)\n                    assert isinstance(function_obj[2], PassNode)\n                else:\n                    assert isinstance(function_obj[0], EndlNode)\n                    assert isinstance(function_obj[1], PassNode)\n        \n            def _check_class_obj(self, class_obj=None):\n                if class_obj is None:\n                    source_code = self.generate_code()\n                    class_obj = RedBaron(source_code).find(\"class\")\n        \n                assert class_obj.name == self.class_name\n                if self.has_class_docstring:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], StringNode)\n                    assert isinstance(class_obj[1], EndlNode)\n                    assert isinstance(class_obj[2], DefNode)\n                else:\n                    assert isinstance(class_obj, ClassNode)\n                    assert isinstance(class_obj[0], EndlNode)\n                    assert isinstance(class_obj[1], DefNode)\n        \n                if self.has_method:\n                    method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                    assert method_obj.name == \"method\"\n                    if self.has_method_docstring:\n                        assert isinstance(method_obj[0], StringNode)  # docstring\n                        assert isinstance(method_obj[1], EndlNode)  # pass\n                        assert isinstance(method_obj[2], PassNode)  # pass\n                    else:\n                        assert isinstance(method_obj[0], EndlNode)\n                        assert isinstance(method_obj[1], PassNode)\n        \n            def _check_module_obj(self, module_obj=None):\n                if module_obj is None:\n                    source_code = self.generate_code()\n                    module_obj = RedBaron(source_code)\n                if self.has_module_docstring:\n                    assert isinstance(module_obj[0], StringNode)\n                    assert isinstance(module_obj[1], ClassNode)\n                else:\n                    if isinstance(module_obj[0], EndlNode):\n                        assert isinstance(module_obj[1], ClassNode)\n                    else:\n                        assert isinstance(module_obj[0], ClassNode)\n        \n            @staticmethod\n            def random_string(length: int):\n                return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample_module_2.ObNMl\n    \n        class ObNMl:\n            \"\"\"zFsdXovhQSBlqDNpXSvl\"\"\"\n        \n            def __init__(self):\n                pass\n        \n            def method(self):\n                \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n        \n                pass\n        \n        \n        \n        \n    automata.core.coding.py_coding.writer.PyCodeWriter\n    \n        PyCodeWriter is a utility class designed for writing and updating Python code in the Abstract Syntax Tree (AST) format, enabling programmatic manipulation of Python elements such as classes, functions, and imports. The main functionality includes initializing with a PyCodeRetriever instance, creating a new module object from source code, updating an existing module, and writing the updated module to disk. However, PyCodeWriter's primary limitation is its reliance on RedBaron, which has known limitations and bugs, along with relatively low support in recent years. Additionally, error reporting in PyCodeWriter can be improved for a better user experience. \n        \n        ```python\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        from automata.core.coding.py_coding.writer import PyCodeWriter\n        \n        # Initialize the PyCodeWriter with a PyCodeRetriever instance\n        retriever = PyCodeRetriever()\n        writer = PyCodeWriter(retriever)\n        \n        # Create a new module object from source code\n        module_dotpath = \"my_module\"\n        source_code = \"def hello():\\n    print('Hello, World!')\\n\"\n        writer.create_new_module(module_dotpath, source_code)\n        \n        # Update the existing module by adding a new function\n        new_function_code = \"def goodbye():\\n    print('Goodbye, World!')\\n\"\n        writer.update_existing_module(module_dotpath, new_function_code, do_write=True)\n        ```\n        \n      Class Docstring:\n        A utility class for writing Python code along AST nodes\n        \n      Methods:\n        def __init__(self, python_retriever: PyCodeRetriever):\n                \"\"\"\n                Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n                Args:\n                    python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n                \"\"\"\n                self.code_retriever = python_retriever\n        \n            \n        create_new_module(self, module_dotpath: str, source_code: str, do_write: bool = False) -> None\n        \n        delete_from_existing__module(self, module_dotpath: str, object_dotpath: str, do_write: bool = False) -> None\n        \n        replace(match) -> None\n        \n        replace_newline_chars(input_str: str) -> str\n        \n        update_existing_module(self,\n                module_dotpath: str,\n                source_code: str,\n                disambiguator: Optional[str] = \"\",\n                do_write: bool = False,\n            ) -> None\n        \n    automata.tests.unit.test_py_writer.MockCodeGenerator.generate_code\n    \n        def generate_code(self):\n                module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n                class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n                method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n                function_docstring = (\n                    f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n                )\n                import_statement = f\"import random\\n\" if self.has_import else \"\"\n        \n                method_code = textwrap.dedent(\n                    f\"\"\"def method(self):\n                            {method_docstring}\n                            pass\n                        \"\"\"\n                    if self.has_class and self.has_method\n                    else \"\"\n                )\n                class_code = textwrap.dedent(\n                    f\"\"\"\n                    class {self.class_name}:\n                        {class_docstring}\n                        def __init__(self):\n                            pass\n                        {method_code}\n                    \"\"\"\n                    if self.has_class\n                    else \"\"\n                )\n        \n                function_code = (\n                    textwrap.dedent(\n                        f\"\"\"\n                    def {self.function_name}():\n                        {function_docstring}\n                        pass\n                    \"\"\"\n                    )\n                    if self.has_function\n                    else \"\"\n                )\n        \n                return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n        \n            \n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_py_code_retriever.test_build_overview\n    \n        def test_build_overview():\n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            result = build_repository_overview(sample_dir)\n            first_module_overview = \"sample\\n     - func sample_function\\n     - cls Person\\n       - func __init__\\n       - func say_hello\\n       - func run\\n     - func f\\n     - cls EmptyClass\\n     - cls OuterClass\\n       - cls InnerClass\\n         - func inner_method\\nsample2\\n     - cls PythonAgentToolBuilder\\n       - func __init__\\n       - func build_tools\\n         - func python_agent_python_task\"\n        \n            assert first_module_overview in result\n        \n        \n        \n        \n    automata.core.embedding.code_embedding.SymbolCodeEmbeddingHandler\n    \n        The SymbolCodeEmbeddingHandler class handles embedding symbols and their source code by building, getting, and updating embeddings based on source code changes. It relies on the VectorDatabaseProvider and EmbeddingProvider for storage and generation of embeddings. However, it has limitations such as assuming a specific directory structure, not supporting custom data sources, and potential inaccuracies with the provided convert_to_fst_object function. \n        \n        Example:\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol\n        from automata.core.embedding.embedding_types import OpenAIEmbedding\n        from automata.core.embedding.code_embedding import SymbolCodeEmbeddingHandler\n        \n        # Configure the necessary components\n        embedding_db = JSONVectorDatabase(\"/path/to/embedding_file.json\")\n        embedding_provider = OpenAIEmbedding()\n        \n        # Create the instance of SymbolCodeEmbeddingHandler\n        handler = SymbolCodeEmbeddingHandler(embedding_db, embedding_provider)\n        \n        # Update the embeddings for a symbol\n        symbol = Symbol.from_string(\"symbol_string_here\")\n        handler.update_embedding(symbol)\n        ```\n        \n        \n      Methods:\n        def __init__(\n                self,\n                embedding_db: VectorDatabaseProvider,\n                embedding_provider: EmbeddingProvider,\n            ):\n                \"\"\"\n                A constructor for SymbolCodeEmbeddingHandler\n        \n                Args:\n                    embedding_db (VectorDatabaseProvider): The database to store the embeddings in\n                    embedding_provider (Optional[EmbeddingProvider]): The provider to\n                        get the embeddings from\n                \"\"\"\n                super().__init__(embedding_db, embedding_provider)\n        \n            \n        build_embedding(self, source_code: str, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        get_all_supported_symbols(self) -> List[Symbol]\n        \n        get_embedding(self, symbol: Symbol) -> SymbolCodeEmbedding\n        \n        update_embedding(self, symbol: Symbol) -> None\n        \n        update_existing_embedding(self, source_code: str, symbol: Symbol) -> None\n        \n    automata.tests.unit.conftest.patch_get_embedding\n    \n        def patch_get_embedding(monkeypatch, mock_embedding):\n            # Define the behavior of the mock build_embedding function\n            mock_get_embedding = Mock(return_value=mock_embedding)\n            monkeypatch.setattr(\"openai.embeddings_utils.get_embedding\", mock_get_embedding)\n        \n        \n        \n        \n    automata.tests.unit.sample_modules.sample.Person\n    \n        class Person:\n            \"\"\"This is a sample class.\"\"\"\n        \n            def __init__(self, name):\n                \"\"\"This is the constructor.\"\"\"\n                self.name = name\n        \n            def say_hello(self):\n                \"\"\"This is a sample method.\"\"\"\n                return f\"Hello, I am {self.name}.\"\n        \n            def run(self) -> str:\n                ...\n        \n        \n        \n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.tests.unit.sample_modules.sample_module_2`/ObNMl#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.tests.unit.sample_modules.sample_module_2", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "ObNMl", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# ObNMl\n\n`ObNMl` is a sample class with minimal functionality, primarily used for testing purposes. The class contains an `__init__` method and a `method` method.\n\n## Related Symbols\n\n- `automata.tests.unit.sample_modules.sample_module_2.fhFSO`\n- `automata.tests.unit.sample_modules.sample.EmptyClass`\n- `automata.core.embedding.embedding_types.NormType`\n- `automata.tests.unit.sample_modules.sample.OuterClass`\n- `automata.tests.unit.sample_modules.sample.OuterClass.InnerClass`\n- `automata.tests.unit.conftest.get_sem`\n- `automata.core.database.vector.JSONVectorDatabase`\n- `automata.core.symbol.symbol_types.Symbol`\n- `automata.tests.unit.test_database_vector.test_init_vector`\n- `automata.core.symbol.symbol_types.SymbolEmbedding`\n\n## Example\n\nThis class only contains a constructor and a single method, both with no functionality. The following example demonstrates how to create an instance of the `ObNMl` class and call the `method` method:\n\n```python\nfrom automata.tests.unit.sample_modules.sample_module_2 import ObNMl\n\nobnml_instance = ObNMl()\nobnml_instance.method()\n```\n\n## Limitations\n\n`ObNMl` is a barebones class that is limited in functionality. It is mainly used for testing purposes and does not contain any features or provide useful outputs.\n\n## Follow-up Questions:\n\n- What is the purpose of the `ObNMl` class?\n- Should the class be extended with additional functionality?\n- How should the class be documented and tested?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 248}, false, {"py/b64": "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"}]}]}, "source_code": "class ObNMl:\n    \"\"\"zFsdXovhQSBlqDNpXSvl\"\"\"\n\n    def __init__(self):\n        pass\n\n    def method(self):\n        \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n\n        pass\n\n\n", "summary": "The `ObNMl` class is a minimal sample class used primarily for testing purposes, containing only an `__init__` method and a `method` method. It has limited functionality and is not meant for actual use. To create an instance of the class and call the `method` method, use the following example:\n\n```python\nfrom automata.tests.unit.sample_modules.sample_module_2 import ObNMl\n\nobnml_instance = ObNMl()\nobnml_instance.method()\n```\n\nThis class does not contain any features or provide useful outputs, and any follow-up questions should address its purpose, documentation, and testing, along with potential additions to its functionality.", "context": "\n    Generate the documentation for ObNMl using the context shown below -\n  Building context for primary symbol - automata.tests.unit.sample_modules.sample_module_2.ObNMl -\n  \n      class ObNMl:\n          \"\"\"zFsdXovhQSBlqDNpXSvl\"\"\"\n      \n          def __init__(self):\n              pass\n      \n          def method(self):\n              \"\"\"zslGjfyaBRiFZlgNkAWR\"\"\"\n      \n              pass\n      \n      \n      \n      \n  Building context for related symbols -\n  \n    automata.tests.unit.sample_modules.sample_module_2.fhFSO\n    \n        def fhFSO():\n            \"\"\"GEjBUXtHLGzJDCDsnFFp\"\"\"\n        \n            pass\n        \n        \n    automata.tests.unit.sample_modules.sample.EmptyClass\n    \n        class EmptyClass:\n            pass\n        \n        \n        \n        \n    automata.core.embedding.embedding_types.NormType\n    \n        `NormType` is an enumeration class representing various normalization techniques available for calculating similarity in a `SymbolSimilarity` object, offering three options: L1, L2, and softmax. These can be used by the `SymbolSimilarity` class while computing similarities between symbols in a related codebase. However, using different normalization techniques may lead to potential limitations such as differences in interpretation and efficiency of similarity calculations. For example:\n        \n        ```python\n        from automata.core.embedding.symbol_similarity import SymbolSimilarity\n        from automata.core.embedding.embedding_types import NormType\n        from automata.core.embedding.manager.code_embedding_manager import SymbolCodeEmbeddingHandler\n        \n        symbol_embedding_manager = SymbolCodeEmbeddingHandler()\n        custom_norm_type = NormType.L1\n        \n        symbol_similarity = SymbolSimilarity(symbol_embedding_manager, custom_norm_type)\n        ```\n        Possible follow-up questions include exploring other normalization techniques to add to the `NormType` class and understanding the impact of different normalization techniques on the performance and interpretation of similarity calculations.\n        \n    automata.tests.unit.sample_modules.sample.OuterClass\n    \n        class OuterClass:\n            class InnerClass:\n                \"\"\"Inner doc strings\"\"\"\n        \n                def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.tests.unit.sample_modules.sample.OuterClass.InnerClass\n    \n        class InnerClass:\n                \"\"\"Inner doc strings\"\"\"\n        \n                def inner_method(self):\n                    \"\"\"Inner method doc strings\"\"\"\n        \n        \n    automata.tests.unit.conftest.get_sem\n    \n        def get_sem(monkeypatch, temp_output_filename):\n            monkeypatch.setattr(\n                \"automata.core.symbol.symbol_utils.convert_to_fst_object\",\n                lambda args: \"symbol_source\",\n            )\n            return SymbolCodeEmbeddingHandler(temp_output_filename)\n        \n        \n        \n        \n    automata.core.database.vector.JSONVectorDatabase\n    \n        `JSONVectorDatabase` is a class within the Automata documentation processing pipeline designed to manage a vector database saved as a JSON file. It facilitates loading, saving, adding, updating, and discarding SymbolEmbedding objects and offers methods for calculating vector similarities and retrieving symbols in the database. However, its `calculate_similarity` function is not yet implemented, raising questions about which similarity measure to use and if there could be a more efficient storage structure than a JSON file.\n        \n        ```python\n        from automata.core.database.vector import JSONVectorDatabase\n        from automata.core.symbol.symbol_types import Symbol, SymbolEmbedding\n        import numpy as np\n        \n        vector_db = JSONVectorDatabase(\"example_vector_db.json\")\n        \n        symbol_1 = Symbol.from_string(\"scip-python python automata example_symbol_1#\")\n        embedding_1 = SymbolEmbedding(symbol_1, \"embedding_source\", np.array([1, 2, 3]))\n        \n        symbol_2 = Symbol.from_string(\"scip-python python automata example_symbol_2#\")\n        embedding_2 = SymbolEmbedding(symbol_2, \"embedding_source\", np.array([4, 5, 6]))\n        \n        vector_db.add(embedding_1)\n        vector_db.add(embedding_2)\n        \n        retrieved_embedding = vector_db.get(symbol_1)\n        \n        vector_db.save()\n        ```\n        \n      Class Docstring:\n        Concrete class to provide a vector database that saves into a JSON file.\n        \n      Methods:\n        def __init__(self, file_path: str):\n                \"\"\"\n                Args:\n                    file_path: The path to the JSON file to save the vector database to\n                \"\"\"\n                self.file_path = file_path\n                self.data: List[SymbolEmbedding] = []\n                self.index: Dict[str, int] = {}\n                self.load()\n        \n            \n        add(self, embedding: SymbolEmbedding) -> None\n        \n        calculate_similarity(self, vector: np.array) -> List[Dict[Symbol, float]]\n        \n        clear(self) -> None\n        \n        contains(self, symbol: Symbol) -> bool\n        \n        discard(self, symbol: Symbol) -> None\n        \n        get(self, symbol: Symbol) -> SymbolEmbedding\n        \n        get_all_symbols(self) -> List[Symbol]\n        \n        load(self) -> None\n        \n        save(self) -> None\n        \n        update(self, embedding: SymbolEmbedding) -> None\n        \n    automata.core.symbol.symbol_types.Symbol\n    \n        Symbol is a class used for identifying a class, method, or local variable in a package, complete with rich metadata. It has a standardized string representation that can be used interchangeably with Symbol, and comes with utility methods for parsing, creating, and querying symbolic data. Instance creation and comparison are also supported.\n        \n        Here's an example on creating an instance of Symbol using the `parse_symbol` function:\n        ```python\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n            \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        ```\n        However, Symbol has some limitations as it assumes specific syntax when parsing string representations and does not support custom symbol types or variations in syntax.\n        \n      Class Docstring:\n        Symbol is similar to a URI, it identifies a class, method, or a local variable. SymbolInformation contains rich metadata about symbols such as the docstring.\n        \n        Symbol has a standardized string representation, which can be used interchangeably with Symbol. The syntax for Symbol is the following:\n        \n        # (<x>)+ stands for one or more repetitions of <x>\n        <symbol>               ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>\n        <package>              ::= <manager> ' ' <package-name> ' ' <version>\n        <scheme>               ::= any UTF-8, escape spaces with double space.\n        <manager>              ::= same as above, use the placeholder '.' to indicate an empty value\n        <package-name>         ::= same as above\n        <version>              ::= same as above\n        <descriptor>           ::= <namespace> | <type> | <term> | <method> | <type-parameter> | <parameter> | <meta> | <macro>\n        <namespace>            ::= <name> '/'\n        <type>                 ::= <name> '#'\n        <term>                 ::= <name> '.'\n        <meta>                 ::= <name> ':'\n        <macro>                ::= <name> '!'\n        <method>               ::= <name> '(' <method-disambiguator> ').'\n        <type-parameter>       ::= '[' <name> ']'\n        <parameter>            ::= '(' <name> ')'\n        <name>                 ::= <identifier>\n        <method-disambiguator> ::= <simple-identifier>\n        <identifier>           ::= <simple-identifier> | <escaped-identifier>\n        <simple-identifier>    ::= (<identifier-character>)+\n        <identifier-character> ::= '_' | '+' | '-' | '$' | ASCII letter or digit\n        <escaped-identifier>   ::= '`' (<escaped-character>)+ '`'\n        <escaped-characters>   ::= any UTF-8 character, escape backticks with double backtick.\n        \n        Examples -\n        from automata.core.symbol.search.symbol_parser import parse_symbol\n        \n        symbol_class = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.agent.automata_agent_enums`/ActionIndicator#\"\n        )\n        \n        symbol_method = parse_symbol(\n        \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        )\n        \n      Methods:\n        __eq__(self, other) -> None\n        \n        __hash__(self) -> int\n        \n        __repr__(self) -> str\n        \n        dotpath(self) -> str\n        \n        from_string(cls, symbol_str: str) -> \"Symbol\"\n        \n        is_local(symbol: \"Symbol\") -> bool\n        \n        is_meta(symbol: \"Symbol\") -> bool\n        \n        is_parameter(symbol: \"Symbol\") -> bool\n        \n        is_protobuf(symbol: \"Symbol\") -> bool\n        \n        module_name(self) -> str\n        \n        parent(self) -> \"Symbol\"\n        \n        symbol_kind_by_suffix(self) -> SymbolDescriptor.PyKind\n        \n        symbol_raw_kind_by_suffix(self) -> DescriptorProto\n        \n    automata.tests.unit.test_database_vector.test_init_vector\n    \n        def test_init_vector(temp_output_filename):\n            JSONVectorDatabase(temp_output_filename)\n        \n        \n        \n        \n    automata.core.symbol.symbol_types.SymbolEmbedding\n    \n        SymbolEmbedding is an abstract base class used to represent various symbol embeddings, such as SymbolCodeEmbedding and SymbolDocEmbedding. It provides a basic structure for initializing and managing these embeddings, taking into account their source and their vector representation in the feature space. SymbolEmbedding is utilized by different embedding handlers like SymbolCodeEmbeddingHandler and SymbolDocEmbeddingHandler. As a base class, its functionality is limited and should be extended by classes with specific embedding types. An example of creating a SymbolCodeEmbedding instance is shown below:\n        \n        ```python\n        from automata.core.symbol.symbol_types import SymbolCodeEmbedding\n        from automata.core.symbol.parser import parse_symbol\n        import numpy as np\n        \n        symbol_str = \"scip-python python automata 75482692a6fe30c72db516201a6f47d9fb4af065 `automata.core.base.tool`/ToolNotFoundError#__init__().\"\n        symbol = parse_symbol(symbol_str)\n        source_code = \"def __init__(self, message): pass\"\n        vector = np.array([0.1, 0.2, 0.3])\n        \n        symbol_code_embedding = SymbolCodeEmbedding(symbol, source_code, vector)\n        ```\n        \n      Class Docstring:\n        Abstract base class for different types of embeddings\n        \n      Methods:\n        def __init__(self, symbol: Symbol, embedding_source: str, vector: np.array):\n                self.symbol = symbol\n                self.embedding_source = embedding_source\n                self.vector = vector\n        \n        \n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}, {"py/object": "automata.core.symbol.symbol_types.SymbolDocEmbedding", "symbol": {"py/object": "automata.core.symbol.symbol_types.Symbol", "uri": "scip-python python automata f79387b50fa622d5da05992c76d99b523d9072ea `automata.tests.unit.test_py_writer`/MockCodeGenerator#", "scheme": "scip-python", "package": {"py/object": "automata.core.symbol.symbol_types.SymbolPackage", "manager": "python", "name": "automata", "version": "f79387b50fa622d5da05992c76d99b523d9072ea"}, "descriptors": {"py/tuple": [{"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "automata.tests.unit.test_py_writer", "suffix": 1, "disambiguator": null}, {"py/object": "automata.core.symbol.symbol_types.SymbolDescriptor", "name": "MockCodeGenerator", "suffix": 2, "disambiguator": null}]}}, "embedding_source": "# MockCodeGenerator\n\n`MockCodeGenerator` is a utility class designed to help create and manipulate Python code programmatically. It supports creating classes, methods, functions, imports, and docstrings for each code element.\n\n## Overview\n\n`MockCodeGenerator` allows the user to create Python code with various combinations of code elements. It provides a way to generate code with or without class definitions, functions, methods, import statements, or docstrings. The generated code can be used for testing or programmatically manipulating Python modules.\n\n## Methods\n\n- `generate_code()`: Generates the Python code based on the provided configuration in the constructor.\n\n## Example\n\n```python\nfrom automata.tests.unit.test_py_writer import MockCodeGenerator\n\nmock_generator = MockCodeGenerator(\n    has_class=True,\n    has_method=True,\n    has_function=True,\n    has_import=True,\n    has_module_docstring=True,\n    has_class_docstring=True,\n    has_method_docstring=True,\n    has_function_docstring=True,\n)\n\nsource_code = mock_generator.generate_code()\nprint(source_code)\n```\n\n## Related Symbols\n\n- `automata.core.coding.py_coding.writer.PyCodeWriter`\n- `automata.core.coding.py_coding.retriever.PyCodeRetriever`\n\n## Limitations\n\n`MockCodeGenerator` relies on the RedBaron library for manipulating Python code, which has known limitations and bugs, along with relatively low support in recent years. Additionally, error reporting in `MockCodeGenerator` can be improved for a better user experience.\n\n## Follow-up Questions:\n\n- What are the specific limitations and bugs of the RedBaron library?", "vector": {"py/reduce": [{"py/function": "numpy.core.multiarray._reconstruct"}, {"py/tuple": [{"py/type": "numpy.ndarray"}, {"py/tuple": [0]}, {"py/b64": "Yg=="}]}, {"py/tuple": [1, {"py/tuple": [1536]}, {"py/id": 248}, false, {"py/b64": "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"}]}]}, "source_code": "class MockCodeGenerator:\n    def __init__(\n        self,\n        has_class: bool = False,\n        has_method: bool = False,\n        has_function: bool = False,\n        has_import: bool = False,\n        has_module_docstring: bool = False,\n        has_class_docstring: bool = False,\n        has_method_docstring: bool = False,\n        has_function_docstring: bool = False,\n    ):\n        self.has_class = has_class\n        self.has_method = has_method\n        self.has_function = has_function\n        self.has_import = has_import\n        self.has_module_docstring = has_module_docstring\n        self.has_class_docstring = has_class_docstring\n        self.has_method_docstring = has_method_docstring\n        self.has_function_docstring = has_function_docstring\n\n        # self.import_class_name = MockCodeGenerator.random_string(5)\n        self.class_name = MockCodeGenerator.random_string(5)\n        self.method_name = MockCodeGenerator.random_string(5)\n        self.function_name = MockCodeGenerator.random_string(5)\n        self.module_docstring = MockCodeGenerator.random_string(20)\n        self.class_docstring = MockCodeGenerator.random_string(20)\n        self.method_docstring = MockCodeGenerator.random_string(20)\n        self.function_docstring = MockCodeGenerator.random_string(20)\n\n    def generate_code(self):\n        module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n        class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n        method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n        function_docstring = (\n            f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n        )\n        import_statement = f\"import random\\n\" if self.has_import else \"\"\n\n        method_code = textwrap.dedent(\n            f\"\"\"def method(self):\n                    {method_docstring}\n                    pass\n                \"\"\"\n            if self.has_class and self.has_method\n            else \"\"\n        )\n        class_code = textwrap.dedent(\n            f\"\"\"\n            class {self.class_name}:\n                {class_docstring}\n                def __init__(self):\n                    pass\n                {method_code}\n            \"\"\"\n            if self.has_class\n            else \"\"\n        )\n\n        function_code = (\n            textwrap.dedent(\n                f\"\"\"\n            def {self.function_name}():\n                {function_docstring}\n                pass\n            \"\"\"\n            )\n            if self.has_function\n            else \"\"\n        )\n\n        return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n\n    def _check_function_obj(self, function_obj=None):\n        if function_obj is None:\n            source_code = self.generate_code()\n            function_obj = RedBaron(source_code).find(\"def\")\n        assert function_obj.name == self.function_name\n        if self.has_function_docstring:\n            assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n            assert isinstance(function_obj[0], StringNode)\n            assert isinstance(function_obj[1], EndlNode)\n            assert isinstance(function_obj[2], PassNode)\n        else:\n            assert isinstance(function_obj[0], EndlNode)\n            assert isinstance(function_obj[1], PassNode)\n\n    def _check_class_obj(self, class_obj=None):\n        if class_obj is None:\n            source_code = self.generate_code()\n            class_obj = RedBaron(source_code).find(\"class\")\n\n        assert class_obj.name == self.class_name\n        if self.has_class_docstring:\n            assert isinstance(class_obj, ClassNode)\n            assert isinstance(class_obj[0], StringNode)\n            assert isinstance(class_obj[1], EndlNode)\n            assert isinstance(class_obj[2], DefNode)\n        else:\n            assert isinstance(class_obj, ClassNode)\n            assert isinstance(class_obj[0], EndlNode)\n            assert isinstance(class_obj[1], DefNode)\n\n        if self.has_method:\n            method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n            assert method_obj.name == \"method\"\n            if self.has_method_docstring:\n                assert isinstance(method_obj[0], StringNode)  # docstring\n                assert isinstance(method_obj[1], EndlNode)  # pass\n                assert isinstance(method_obj[2], PassNode)  # pass\n            else:\n                assert isinstance(method_obj[0], EndlNode)\n                assert isinstance(method_obj[1], PassNode)\n\n    def _check_module_obj(self, module_obj=None):\n        if module_obj is None:\n            source_code = self.generate_code()\n            module_obj = RedBaron(source_code)\n        if self.has_module_docstring:\n            assert isinstance(module_obj[0], StringNode)\n            assert isinstance(module_obj[1], ClassNode)\n        else:\n            if isinstance(module_obj[0], EndlNode):\n                assert isinstance(module_obj[1], ClassNode)\n            else:\n                assert isinstance(module_obj[0], ClassNode)\n\n    @staticmethod\n    def random_string(length: int):\n        return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n\n\n", "summary": "MockCodeGenerator is a utility class that aids in creating and manipulating Python code elements such as classes, methods, functions, imports, and docstrings. Users can generate code for testing or programmatically manipulating Python modules, with or without certain code elements. However, it relies on the RedBaron library, which has known limitations and bugs, as well as declining support in recent years. Error reporting in MockCodeGenerator could also be improved for a better user experience.", "context": "\n    Generate the documentation for MockCodeGenerator using the context shown below -\n  Building context for primary symbol - automata.tests.unit.test_py_writer.MockCodeGenerator -\n  \n      class MockCodeGenerator:\n          def __init__(\n              self,\n              has_class: bool = False,\n              has_method: bool = False,\n              has_function: bool = False,\n              has_import: bool = False,\n              has_module_docstring: bool = False,\n              has_class_docstring: bool = False,\n              has_method_docstring: bool = False,\n              has_function_docstring: bool = False,\n          ):\n              self.has_class = has_class\n              self.has_method = has_method\n              self.has_function = has_function\n              self.has_import = has_import\n              self.has_module_docstring = has_module_docstring\n              self.has_class_docstring = has_class_docstring\n              self.has_method_docstring = has_method_docstring\n              self.has_function_docstring = has_function_docstring\n      \n              # self.import_class_name = MockCodeGenerator.random_string(5)\n              self.class_name = MockCodeGenerator.random_string(5)\n              self.method_name = MockCodeGenerator.random_string(5)\n              self.function_name = MockCodeGenerator.random_string(5)\n              self.module_docstring = MockCodeGenerator.random_string(20)\n              self.class_docstring = MockCodeGenerator.random_string(20)\n              self.method_docstring = MockCodeGenerator.random_string(20)\n              self.function_docstring = MockCodeGenerator.random_string(20)\n      \n          def generate_code(self):\n              module_docstring = f'\"\"\"{self.module_docstring}\"\"\"\\n' if self.has_module_docstring else \"\"\n              class_docstring = f'\"\"\"{self.class_docstring}\"\"\"\\n' if self.has_class_docstring else \"\"\n              method_docstring = f'\"\"\"{self.method_docstring}\"\"\"\\n' if self.has_method_docstring else \"\"\n              function_docstring = (\n                  f'\"\"\"{self.function_docstring}\"\"\"\\n' if self.has_function_docstring else \"\"\n              )\n              import_statement = f\"import random\\n\" if self.has_import else \"\"\n      \n              method_code = textwrap.dedent(\n                  f\"\"\"def method(self):\n                          {method_docstring}\n                          pass\n                      \"\"\"\n                  if self.has_class and self.has_method\n                  else \"\"\n              )\n              class_code = textwrap.dedent(\n                  f\"\"\"\n                  class {self.class_name}:\n                      {class_docstring}\n                      def __init__(self):\n                          pass\n                      {method_code}\n                  \"\"\"\n                  if self.has_class\n                  else \"\"\n              )\n      \n              function_code = (\n                  textwrap.dedent(\n                      f\"\"\"\n                  def {self.function_name}():\n                      {function_docstring}\n                      pass\n                  \"\"\"\n                  )\n                  if self.has_function\n                  else \"\"\n              )\n      \n              return f\"{module_docstring}{import_statement}{class_code}\\n\\n{function_code}\"\n      \n          def _check_function_obj(self, function_obj=None):\n              if function_obj is None:\n                  source_code = self.generate_code()\n                  function_obj = RedBaron(source_code).find(\"def\")\n              assert function_obj.name == self.function_name\n              if self.has_function_docstring:\n                  assert function_obj[0].value.replace('\"\"\"', \"\") == self.function_docstring\n                  assert isinstance(function_obj[0], StringNode)\n                  assert isinstance(function_obj[1], EndlNode)\n                  assert isinstance(function_obj[2], PassNode)\n              else:\n                  assert isinstance(function_obj[0], EndlNode)\n                  assert isinstance(function_obj[1], PassNode)\n      \n          def _check_class_obj(self, class_obj=None):\n              if class_obj is None:\n                  source_code = self.generate_code()\n                  class_obj = RedBaron(source_code).find(\"class\")\n      \n              assert class_obj.name == self.class_name\n              if self.has_class_docstring:\n                  assert isinstance(class_obj, ClassNode)\n                  assert isinstance(class_obj[0], StringNode)\n                  assert isinstance(class_obj[1], EndlNode)\n                  assert isinstance(class_obj[2], DefNode)\n              else:\n                  assert isinstance(class_obj, ClassNode)\n                  assert isinstance(class_obj[0], EndlNode)\n                  assert isinstance(class_obj[1], DefNode)\n      \n              if self.has_method:\n                  method_obj = class_obj[3] if self.has_class_docstring else class_obj[2]\n                  assert method_obj.name == \"method\"\n                  if self.has_method_docstring:\n                      assert isinstance(method_obj[0], StringNode)  # docstring\n                      assert isinstance(method_obj[1], EndlNode)  # pass\n                      assert isinstance(method_obj[2], PassNode)  # pass\n                  else:\n                      assert isinstance(method_obj[0], EndlNode)\n                      assert isinstance(method_obj[1], PassNode)\n      \n          def _check_module_obj(self, module_obj=None):\n              if module_obj is None:\n                  source_code = self.generate_code()\n                  module_obj = RedBaron(source_code)\n              if self.has_module_docstring:\n                  assert isinstance(module_obj[0], StringNode)\n                  assert isinstance(module_obj[1], ClassNode)\n              else:\n                  if isinstance(module_obj[0], EndlNode):\n                      assert isinstance(module_obj[1], ClassNode)\n                  else:\n                      assert isinstance(module_obj[0], ClassNode)\n      \n          @staticmethod\n          def random_string(length: int):\n              return \"\".join(random.choice(string.ascii_letters) for _ in range(length))\n      \n      \n      \n      \n  Building context for related symbols -\n  \n    automata.tests.unit.test_py_writer.test_create_class_source_class\n    \n        def test_create_class_source_class():\n            mock_generator = MockCodeGenerator(has_class=True)\n            mock_generator._check_class_obj()\n        \n            mock_generator = MockCodeGenerator(has_class=True, has_class_docstring=True)\n            mock_generator._check_class_obj()\n        \n            mock_generator = MockCodeGenerator(has_class=True, has_method=True)\n            mock_generator._check_class_obj()\n        \n            mock_generator = MockCodeGenerator(has_class=True, has_class_docstring=True, has_method=True)\n            mock_generator._check_class_obj()\n        \n            mock_generator = MockCodeGenerator(\n                has_class=True, has_class_docstring=True, has_method=True, has_method_docstring=True\n            )\n            mock_generator._check_class_obj()\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.test_write_and_retrieve_mock_code\n    \n        def test_write_and_retrieve_mock_code(python_writer):\n            mock_generator = MockCodeGenerator(\n                has_class=True,\n                has_method=True,\n                has_function=True,\n                has_import=True,\n                has_module_docstring=True,\n                has_class_docstring=True,\n                has_method_docstring=True,\n                has_function_docstring=True,\n            )\n            source_code = mock_generator.generate_code()\n            python_writer._create_module_from_source_code(\"sample_module_2\", source_code)\n        \n            python_writer._write_module_to_disk(\"sample_module_2\")\n        \n            sample_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            module_map = LazyModuleTreeMap(sample_dir)\n            retriever = PyCodeRetriever(module_map)\n            module_docstring = retriever.get_docstring(\"sample_module_2\", None)\n            assert module_docstring == mock_generator.module_docstring\n        \n        \n    automata.tests.unit.test_py_writer.test_create_function_source_function\n    \n        def test_create_function_source_function():\n            mock_generator = MockCodeGenerator(has_function=True)\n            mock_generator._check_function_obj()\n        \n            mock_generator = MockCodeGenerator(has_function=True, has_function_docstring=True)\n            mock_generator._check_function_obj()\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.test_create_update_write_module\n    \n        def test_create_update_write_module(python_writer):\n            mock_generator = MockCodeGenerator(\n                has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n            )\n            source_code = mock_generator.generate_code()\n            python_writer.create_new_module(\"sample_module_write\", source_code, do_write=True)\n            root_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"sample_modules\")\n            fpath = os.path.join(root_dir, \"sample_module_write.py\")\n            assert os.path.exists(fpath)\n            with open(fpath, \"r\") as f:\n                contents = f.read()\n                assert_code_lines_equal(source_code, contents)\n        \n            mock_generator_2 = MockCodeGenerator(\n                has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n            )\n            source_code_2 = mock_generator_2.generate_code()\n        \n            assert source_code != source_code_2\n            python_writer.update_existing_module(\n                source_code=source_code_2, module_dotpath=\"sample_module_write\", do_write=True\n            )\n        \n            with open(fpath, \"r\") as f:\n                contents = f.read()\n                assert_code_lines_equal(\"\\n\".join([source_code, source_code_2]), contents)\n        \n            os.remove(fpath)\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.test_extend_module\n    \n        def test_extend_module(python_writer):\n            # Arrange\n            # create module\n            mock_generator = MockCodeGenerator(\n                has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n            )\n            source_code = mock_generator.generate_code()\n            python_writer.create_new_module(\"sample_module_2\", source_code)\n            mock_generator_2 = MockCodeGenerator(\n                has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n            )\n            source_code_2 = mock_generator_2.generate_code()\n        \n            python_writer.update_existing_module(\"sample_module_2\", source_code_2)\n        \n            # Check module 2 is merged into module 1\n            module_obj = python_writer.code_retriever.module_tree_map.fetch_module(\"sample_module_2\")\n            mock_generator._check_module_obj(module_obj)\n            mock_generator._check_class_obj(module_obj[0])\n            mock_generator._check_function_obj(module_obj[1])\n            mock_generator_2._check_class_obj(module_obj[2])\n            mock_generator_2._check_function_obj(module_obj[3])\n        \n        \n        \n        \n    automata.tests.unit.test_py_code_retriever.test_get_code_module\n    \n        def test_get_code_module(getter):\n            module_name = \"sample\"\n            object_path = None\n            result = getter.get_source_code_without_docstrings(module_name, object_path)\n            expected_match = 'import math\\n\\n\\ndef sample_function(name):\\n    return f\"Hello, {name}! Sqrt(2) = \" + str(math.sqrt(2))\\n\\n\\nclass Person:\\n\\n    def __init__(self, name):\\n        self.name = name\\n\\n    def say_hello(self):\\n        return f\"Hello, I am {self.name}.\"\\n\\n    def run(self) -> str:\\n        ...\\n\\n\\ndef f(x) -> int:\\n    return x + 1\\n\\n\\nclass EmptyClass:\\n    pass\\n\\n\\nclass OuterClass:\\n    class InnerClass:\\n\\n        def inner_method(self):\\n'\n        \n            assert result == expected_match\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.test_reduce_module\n    \n        def test_reduce_module(python_writer):\n            mock_generator = MockCodeGenerator(\n                has_class=True, has_class_docstring=True, has_function=True, has_function_docstring=True\n            )\n            source_code = mock_generator.generate_code()\n            python_writer.create_new_module(\"sample_module_2\", source_code)\n            module_obj = python_writer.code_retriever.module_tree_map.fetch_module(\"sample_module_2\")\n            class_obj = module_obj.find(\"class\")\n        \n            function_obj = module_obj.find_all(\"def\")[-1]\n            python_writer.delete_from_existing__module(\"sample_module_2\", class_obj.name)\n            assert module_obj[0] == function_obj\n        \n        \n        \n        \n    automata.core.coding.py_coding.writer.PyCodeWriter\n    \n        PyCodeWriter is a utility class designed for writing and updating Python code in the Abstract Syntax Tree (AST) format, enabling programmatic manipulation of Python elements such as classes, functions, and imports. The main functionality includes initializing with a PyCodeRetriever instance, creating a new module object from source code, updating an existing module, and writing the updated module to disk. However, PyCodeWriter's primary limitation is its reliance on RedBaron, which has known limitations and bugs, along with relatively low support in recent years. Additionally, error reporting in PyCodeWriter can be improved for a better user experience. \n        \n        ```python\n        from automata.core.coding.py_coding.retriever import PyCodeRetriever\n        from automata.core.coding.py_coding.writer import PyCodeWriter\n        \n        # Initialize the PyCodeWriter with a PyCodeRetriever instance\n        retriever = PyCodeRetriever()\n        writer = PyCodeWriter(retriever)\n        \n        # Create a new module object from source code\n        module_dotpath = \"my_module\"\n        source_code = \"def hello():\\n    print('Hello, World!')\\n\"\n        writer.create_new_module(module_dotpath, source_code)\n        \n        # Update the existing module by adding a new function\n        new_function_code = \"def goodbye():\\n    print('Goodbye, World!')\\n\"\n        writer.update_existing_module(module_dotpath, new_function_code, do_write=True)\n        ```\n        \n      Class Docstring:\n        A utility class for writing Python code along AST nodes\n        \n      Methods:\n        def __init__(self, python_retriever: PyCodeRetriever):\n                \"\"\"\n                Initialize the PyCodeWriter with a PyCodeRetriever instance\n        \n                Args:\n                    python_retriever (PyCodeRetriever): The PyCodeRetriever instance to use\n                \"\"\"\n                self.code_retriever = python_retriever\n        \n            \n        create_new_module(self, module_dotpath: str, source_code: str, do_write: bool = False) -> None\n        \n        delete_from_existing__module(self, module_dotpath: str, object_dotpath: str, do_write: bool = False) -> None\n        \n        replace(match) -> None\n        \n        replace_newline_chars(input_str: str) -> str\n        \n        update_existing_module(self,\n                module_dotpath: str,\n                source_code: str,\n                disambiguator: Optional[str] = \"\",\n                do_write: bool = False,\n            ) -> None\n        \n    automata.tests.unit.test_py_writer.test_create_class_inheritance\n    \n        def test_create_class_inheritance():\n            mock_generator = MockCodeGenerator(has_class=True)\n            source_code = mock_generator.generate_code()\n            # Add a subclass that inherits from the parent class\n            source_code += textwrap.dedent(\n                f\"\"\"\n                class {mock_generator.class_name}_child({mock_generator.class_name}):\n                    pass\n                \"\"\"\n            )\n            module_obj = RedBaron(source_code)\n            class_obj = find_syntax_tree_node(module_obj, f\"{mock_generator.class_name}_child\")\n            assert class_obj.inherit_from.name.value == mock_generator.class_name\n        \n        \n        \n        \n    automata.tests.unit.test_py_writer.test_create_function_with_arguments\n    \n        def test_create_function_with_arguments():\n            mock_generator = MockCodeGenerator(has_function=True, has_function_docstring=True)\n            source_code = mock_generator.generate_code()\n            # Add a function with different types of arguments\n            source_code += textwrap.dedent(\n                f\"\"\"\n                def {mock_generator.function_name}_with_args(pos_arg, kw_arg=None, *args, **kwargs):\n                    pass\n                \"\"\"\n            )\n            module_obj = RedBaron(source_code)\n            function_obj = find_syntax_tree_node(module_obj, f\"{mock_generator.function_name}_with_args\")\n            assert function_obj.name == f\"{mock_generator.function_name}_with_args\"\n            def_arg_nodes = module_obj.find_all(\"def_argument\")\n            assert len(def_arg_nodes) == 2\n            assert def_arg_nodes[0].name.value == \"pos_arg\"\n            assert def_arg_nodes[1].name.value == \"kw_arg\"\n            assert def_arg_nodes[1].value.value == \"None\"\n            list_arg_nodes = module_obj.find_all(\"list_argument\")\n            assert len(list_arg_nodes) == 1\n            assert list_arg_nodes[0].name.value == \"args\"\n            dict_arg_nodes = module_obj.find_all(\"dict_argument\")\n            assert len(dict_arg_nodes) == 1\n            assert dict_arg_nodes[0].name.value == \"kwargs\"\n        \n        \n        \n        \n  Building context for dependencies -\n  \n\n\n    The output documentation should include an overview section, related symbols, examples, and discussion around limitations.\n    Examples should be comprehensive and readily executable (e.g. correct imports and values).\n    If there are references to 'Mock' objects in test files from your context, do your best to replace these with the actual underlying object.\n    If that is not possible, note this in a footnote. Mock objects are used in testing to simplify working with complex objects.\n    For reference, write in the style of in the original Python Library documentation -\n\n...\n## Usage Example\n\n```python\nfrom transformers import PegasusForConditionalGeneration, PegasusTokenizer\nimport torch\n\nsrc_text = [\n    \"\"\" PG&E .... \"\"\"\n]\n\nmodel_name = \"google/pegasus-xsum\"\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntokenizer = PegasusTokenizer.from_pretrained(model_name)\nmodel = PegasusForConditionalGeneration.from_pretrained(model_name).to(device)\nbatch = tokenizer(src_text, truncation=True, padding=\"longest\", return_tensors=\"pt\").to(device)\ntranslated = model.generate(**batch)\ntgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)\nassert (\n    tgt_text[0]\n    == \"California's...\"\n)\n\n\n    For further reference, see the local documentation here -\n\n# AutomataAgentConfig\n\n`AutomataAgentConfig` is a configuration class that helps configure, setup, and interact with an `AutomataAgent`. It contains various attributes such as `config_name`, `instruction_payload`, `llm_toolkits`, and others to provide the necessary setup and settings to be used by the agent.\n\n## Overview\n\n`AutomataAgentConfig` provides a way to load the agent configurations specified by the `AgentConfigName`. The configuration options can be set during the instantiation of the class or can be loaded using the `load` classmethod. It provides utility methods to load and setup agent configurations while also validating the provided settings. The class offers a convenient way to create an agent with custom configurations and includes closely related symbols like `AgentConfigName`.\n\n## Related Symbols\n\n- `config.config_enums.AgentConfigName`\n- `automata.core.agent.automata_agent.AutomataAgent`\n- `config.automata_agent_config_utils.AutomataAgentConfigBuilder`\n- `automata.core.coordinator.automata_instance.AutomataInstance`\n\n## Example\n\nThe following is an example demonstrating how to create an instance of `AutomataAgentConfig` using a predefined configuration name.\n\n```python\nfrom config.automata_agent_config import AutomataAgentConfig\nfrom config.config_enums import AgentConfigName\n\nconfig_name = AgentConfigName.AUTOMATA_MAIN_DEV\nconfig = AutomataAgentConfig.load(config_name)\n```\n\n## Limitations\n\nThe primary limitation of `AutomataAgentConfig` is that it relies on the predefined configuration files based on `AgentConfigName`. It can only load configurations from those files and cannot load custom configuration files. In addition, it assumes a specific directory structure for the configuration files.\n\n## Follow-up Questions:\n\n- How can we include custom configuration files for loading into the `AutomataAgentConfig` class?\n\n\n\n    Some information is just included for contextual reference, and this may be omitted from the output documentation.\n    Start the documentation with a header that includes only the class name.\n    Lastly, if some points are unclear, note these in a footnote that begins with ## Follow-up Questions:"}]